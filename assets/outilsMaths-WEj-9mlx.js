import{m as T,r as P}from"./embellissements-BYV7mIDn.js";import"decimal.js";import"mathjs";import"katex";import"earcut";import"roughjs";import{m as O}from"./Matrice-C65I2nuw.js";import{P as S}from"./Polynome-BIt5zaQj.js";import{g as k,e as h}from"./comparisonFunctions-B45ZZ3C7.js";function J(s){let o,e,r,p;do e=P(-5,5,0),r=P(-5,5,0),p=P(-5,5,0),o=r*r-4*e*p;while(s?o<=0:o>=0);return[e,r,p]}function K(s){const o=s.sort((f,t)=>f.x-t.x),e=[];for(let f=1;f<o.length;f++)o[f-1].x!==o[f].x&&e.push(o[f-1]);if(e.push(o[o.length-1]),e.length<2)throw Error("Pour une interpolation de Lagrange, il faut au moins deux points d'abscisses diffÃ©rentes");const r=e.length-1;let p=new S({coeffs:[0]});for(let f=0;f<=r;f++){let t=new S({coeffs:[1]});for(let l=0;l<=r;l++)if(f!==l){const d=e[f].x-e[l].x;t=new S({coeffs:[-e[l].x/d,1/d]}).multiply(t)}t=t.multiply(e[f].y),p=t.add(p)}return p}function Q(s,o,e,r,p){const f=O([[s**2,s],[o**2,o]]);if(f.determinant()===0)return[0,0];const[t,l]=f.inverse().multiply([e-p,r-p]).toArray();return[t,l]}function R(s,o,e,r,p,f,t){const l=O([[s**3,s**2,s],[o**3,o**2,o],[e**3,e**2,e]]),d=r-t,a=p-t,n=f-t;if(l&&l.determinant()===0)return[0,0,0];const[i,c,$]=l.inverse().multiply([d,a,n]).toArray();return[i,c,$]}const u=(s,o,e)=>e?T(s,o):s;function E(s){return s.head!=="Add"?h.function("Multiply",[s,"-1"]):h.function("Add",s.ops.map(E),{canonical:!1})}function A(s){if(s.head==="Negate"){const e=E(s.op1);return h.function("Add",[e],{canonical:!1})}if(s.head==="Subtract"){const e=E(s.op2),r=h.function("Add",[s.op1,e],{canonical:!1});return A(r)}if(s.head!=="Add")return s;const o=[];for(let e of s.ops)e=A(e),e.head==="Add"||e.head==="Delimiter"?o.push(...e.ops.map(A)):o.push(e);return h.function("Add",o,{canonical:!1})}function U(s,o){const e=o.couleurs??["red","blue","green","black","red","blue","green","black"],r=o?.isColored;s=k(["parentheses","espaces","virgules","fractions"])(s);const f=h.parse(s,{canonical:!1}),l=A(A(f)).ops;let d="";for(let a=0;a<l.length;a++){const n=l[a].latex.startsWith("-")||a===0?l[a].latex:`+${l[a].latex}`,i=l[a].getSubexpressions("Power")[0];let c=0;i!=null?c=i.op2.value:l[a].head==="Square"?c=2:l[a].head==="Negate"?l[a].op1.isConstant?c=0:c=1:l[a].isConstant?c=0:c=1,d+=u(n,e[Math.max(0,2-c)],r)}return d}function X(s,o){const e=o.couleurs??["red","blue","green","black","red","blue","green","black"],r=o?.isColored;if(s=k(["parentheses","espaces","virgules","fractions"])(s),s.length===0)return"";const f=h.parse(s,{canonical:!1}),t=A(f).ops,l=[];for(let a=0;a<t.length;a++){let n=0;const i=t[a];i.getSubexpressions("Power")[0]!=null?n=i.getSubexpressions("Power")[0].op2.numericValue:i.head==="Square"?n=2:i.head==="Negate"?i.op1.isConstant?n=0:n=1:i.isConstant?n=0:n=1;const c=t[a].latex.startsWith("-")||a===0?t[a].latex:`+${t[a].latex}`;l[n]==null&&(l[n]=[]),l[n].push(c)}const d=[];for(let a=l.length;a>0;a--){const n=l[a-1];if(n!=null&&n.length>0){let i="";for(let c of n)c.startsWith("+")&&i===""&&(c=c.substring(1)),i+=c;d.push(`(${u(i,e[Math.max(0,2-(a-1))],r)})`)}}return d.join("+")}function Y(s,o){const e=o?.isColored,r=o.colorOffset??0,p=o?.level??0,f=k(["parentheses","fractions"]),t=o.isColored??["red","blue","green","black","red","blue","green","black"];s=f(s);const l=h.parse(s);if(!["Square","Multiply","Power"].includes(l.head))return s.replaceAll("\\frac","\\dfrac");if(l.head==="Square"||l.head==="Power"){if(l.op2.numericValue!==2)return s.replaceAll("\\frac","\\dfrac");const d=l.op1,a=d.head==="Add",n=d.op1,i=d.op2,c=n.isAlgebraic?n.latex.startsWith("-")?`\\left( ${n.latex}\\right) ^2`:`${n.latex}^2`:`\\left( ${n.latex}\\right) ^2`,$=i.isAlgebraic?i.latex.startsWith("-")?`\\left( ${i.latex}\\right) ^2`:`${i.latex}^2`:`\\left( ${i.latex}\\right) ^2`,g=`2\\times ${n.isConstant?n.latex.startsWith("-")?`\\left( ${n.latex}\\right) `:`${n.latex}`:`\\left( ${n.latex}\\right) `}\\times ${i.isConstant?i.latex.startsWith("-")?`\\left( ${i.latex}\\right) `:`${i.latex}`:`${i.latex}`}`;if(p===2)return`${u(c,t[r],e)}${a?"+":"-"}${u(g,t[r+1],e)}+${u($,t[r+2],e)}`.replaceAll("\\frac","\\dfrac");{const m=h.parse(g).simplify().latex,W=h.box(["Multiply",n,n]).evaluate().latex,v=h.box(["Multiply",i,i]).evaluate().latex;return`${u(W,t[r],e)}${a?"+":"-"}${u(m,t[r+1],e)}+${u(v,t[r+2],e)}`.replaceAll("\\frac","\\dfrac")}}else{const d=l.op1,a=l.op2,n=d.op1,i=d.op2,c=d.head==="Add",$=a.op1,g=a.op2,m=a.head==="Add",W=n.latex.startsWith("-")?`\\left( ${n.latex}\\right) `:n.latex,v=i.latex.startsWith("-")?`\\left( ${i.latex}\\right) `:i.latex,q=$.latex.startsWith("-")?`\\left( ${$.latex}\\right) `:$.latex,D=g.latex.startsWith("-")?`\\left( ${g.latex}\\right) `:g.latex;if(p===2)return`${u(W,t[r],e)}\\times ${u(q,t[r],e)}
    ${m?"+":"-"}${u(W,t[r+1],e)}\\times ${u(D,t[r+1],e)}
    ${c?"+":"-"}${u(v,t[r+1],e)}\\times ${u(q,t[r+1],e)}
    ${c===m?"+":"-"}${u(v,t[r+2],e)}\\times ${u(D,t[r+2],e)}`.replaceAll("\\frac","\\dfrac");{const L=h.box(["Multiply",n,$]).evaluate().simplify().latex,x=h.box(["Multiply",n,g]).evaluate().simplify().latex,b=h.box(["Multiply",i,$]).evaluate().simplify().latex,y=h.box(["Multiply",i,g]).evaluate().simplify().latex;if(p===1){const w=x.startsWith("-")?`\\left( ${x}\\right)`:x,C=b.startsWith("-")?`\\left( ${b}\\right)`:b,M=y.startsWith("-")?`\\left( ${y}\\right)`:y;return`${u(L,t[r],e)}
        ${m?"+":"-"}${u(w,t[r+1],e)}
        ${c?"+":"-"}${u(C,t[r+1],e)}
        ${c===m?"+":"-"}${u(M,t[r+1],e)}`.replaceAll("\\frac","\\dfrac")}else{const w=x.startsWith("-")?m?x:`+${x.substring(1)}`:m?`+${x}`:`-${x}`,C=b.startsWith("-")?c?b:`+${b.substring(1)}`:c?`+${b}`:`-${b}`,M=y.startsWith("-")?c===m?y:`+${y.substring(1)}`:c===m?`+${y}`:`-${y}`;return`${u(L,t[r],e)}
        ${u(w,t[r+1],e)}
        ${u(C,t[r+2],e)}
        ${u(M,t[r+3],e)}`.replaceAll("\\frac","\\dfrac")}}}}export{Q as a,R as b,J as c,Y as d,K as i,X as r,U as s};
