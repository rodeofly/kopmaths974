import{y as k,br as q,bt as m,r as l,t as p,S as s,l as x}from"./embellissements-BYV7mIDn.js";import{w as N}from"./message-BfjIT6jz.js";import{E as Q}from"./Exercice-DtXhjCyI.js";import{p as y}from"./qcm-BQR8Ns0N.js";import"mathjs";import"decimal.js";import"katex";import"earcut";import"roughjs";import"./exerciseMethods-CtbYPwln.js";import"./index-BUDQz6-w.js";import"crypto-js";import"seedrandom";const B="Justifier la primalité ou pas",F=!0,H="qcm",I=!0,K="qcmMono",U="36074",W={"fr-fr":["5A12-1"],"fr-ch":["9NO4-13"]};class X extends Q{constructor(){super(),this.consigne="Justifier que les nombres suivants sont premiers ou pas.",this.spacing=3,this.spacingCorr=2,this.nbQuestions=7,this.nbCols=2,this.sup=1}nouvelleVersion(){let C,h=[1,2,3,4,5,6,7];h=k(h);const v=q(h,this.nbQuestions);let f="Cette liste des nombres premiers inférieurs à 30 pourra être utile : <br>"+m(100)[0];for(let r=1;r<m(30).length;r++)f+=", "+m(30)[r];f+=".",this.introduction=N(f,"nombres","Coup de pouce");for(let r=0,u,t,S=0;r<this.nbQuestions&&S<50;){C=v[r];let e,c;switch(C){case 1:e=2*l(51,4999),u=s(e),t=`Comme ${s(e)} est pair, il admet donc au moins trois diviseurs qui sont 1, 2 et lui-même, `,t+=p(s(e)+" n'est donc pas premier."),c="non";break;case 2:{let n=0;for(e=3*l(34,3333);e%2===0||e%5===0;)e=3*l(34,3333);u=s(e),t="Comme "+e.toString().charAt(0),n=Number(e.toString().charAt(0));for(let i=1;i<e.toString().length;i++)t+=" + "+e.toString().charAt(i),n+=Number(e.toString().charAt(i));t+=` = ${n} est un multiple de 3 donc ${s(e)} aussi, il admet donc au moins trois diviseurs qui sont 1, 3 et lui-même, `,t+=p(s(e)+" n'est donc pas premier."),c="non";break}case 3:e=5*l(20,1999),u=s(e),t=`Comme le dernier chiffre de ${s(e)} est un ${e.toString().charAt(e.toString().length-1)} alors ${s(e)} est divisible par 5, `,t+="il admet donc au moins trois diviseurs qui sont 1, 5 et lui-même, ",t+=p(s(e)+" n'est donc pas premier."),c="non";break;case 4:{let n=0;for(e=9*l(12,1111);e%2===0||e%5===0;)e=9*l(34,3333);u=s(e),t="Comme "+e.toString().charAt(0),n=Number(e.toString().charAt(0));for(let i=1;i<e.toString().length;i++)t+=" + "+e.toString().charAt(i),n+=Number(e.toString().charAt(i));t+=` = ${n} est un multiple de 9 donc ${s(e)} aussi, il admet donc au moins trois diviseurs qui sont 1, 9 et lui-même, `,t+=p(s(e)+" n'est donc pas premier."),c="non";break}case 5:e=10*l(10,999),u=s(e),t=`Comme le nombre ${s(e)} se termine par un ${e.toString().charAt(e.toString().length-1)} alors ${s(e)} est un multiple de 10, `,t+="il admet donc au moins trois diviseurs qui sont 1, 10 et lui-même, ",t+=p(s(e)+" n'est donc pas premier."),c="non";break;case 6:{const n=l(0,m(30).length-1),i=l(0,m(30).length-1),o=m(100)[n],a=m(100)[i];e=o+"$\\times $"+a,u=e,t=`${e} est le produit de ${o} et de ${a}, il admet donc au moins `,o===a?t+=`trois divisieurs qui sont 1, ${o} et lui-même ${e}=${s(o*a)} `:t+=`quatre diviseurs qui sont 1, ${o}, ${a} et lui-même ${e}=${s(o*a)}, `,t+=p(`${e} = `+s(o*a)+" n'est donc pas premier."),c="non";break}case 7:default:{const n=l(0,m(29).length-1);e=m(29)[n];const i=m(29),o=[];let a=0;for(;i[a]**2<e;)o.push(i[a]),a++;let g="";o.length===1?g="le nombre":g="les nombres";const b=m(e);let $="";b.length===1?$="le nombre":$="les nombres",u=e+"",t="<b>Proposition de deux corrections valables :</b> <br>",t+="<b>Proposition de correction 1 :</b> <br>",t+=`En effectuant la division euclidienne de ${e} par tous les nombres premiers dont le carré est inférieur à $${e}$, c'est-à-dire par ${g} `,t+=o[0];for(let d=1;d<o.length;d++)t+=", "+o[d];t+=", le reste n'est jamais nul.",t+="<br>"+p(s(e)+" est donc un nombre premier."),t+="<hr>",t+="<b>Proposition de correction 2 :</b> <br>",t+=`En effectuant la division euclidienne de ${e} par tous les nombres premiers inférieurs à $${e}$, c'est-à-dire par ${$} `,t+=b[0];for(let d=1;d<b.length-1;d++)t+=", "+b[d];t+=", le reste n'est jamais nul.",t+="<br>"+p(s(e)+" est donc un nombre premier."),c="oui";break}}this.autoCorrection[r]={},this.autoCorrection[r].options={ordered:!0},this.autoCorrection[r].enonce=`${u}
`,this.autoCorrection[r].propositions=[{texte:"est premier",statut:c!=="non"},{texte:"n'est pas premier",statut:c!=="oui"}];const A=y(this,r);this.interactif&&(u+=A.texte),this.questionJamaisPosee(r,t)&&(this.listeQuestions[r]=u,this.listeCorrections[r]=t,r++),S++}x(this)}}export{I as amcReady,K as amcType,X as default,F as interactifReady,H as interactifType,W as refs,B as titre,U as uuid};
