import es from"decimal.js";import ts,{create as ns,randomIntDependencies as rs,largerEqDependencies as os,smallerEqDependencies as ss,largerDependencies as as,smallerDependencies as is,pickRandomDependencies as cs,randomDependencies as us,simplifyDependencies as ls,evaluateDependencies as ps,parseDependencies as gs,formatDependencies as fs,NodeDependencies as hs,nthRootDependencies as Ts,gcdDependencies as Ns,lcmDependencies as Cs,fractionDependencies as ms}from"mathjs";import{c as Es,a as Ss,r as ys,bs as Os}from"./embellissements-BYV7mIDn.js";import"katex";import"earcut";import"roughjs";var O={NO_CHANGE:"NO_CHANGE",EQUALITY:"EQUALITY",SIMPLIFY_ARITHMETIC:"SIMPLIFY_ARITHMETIC",DIVISION_BY_NEGATIVE_ONE:"DIVISION_BY_NEGATIVE_ONE",DIVISION_BY_ONE:"DIVISION_BY_ONE",MULTIPLY_BY_ZERO:"MULTIPLY_BY_ZERO",REARRANGE_COEFF:"REARRANGE_COEFF",REDUCE_EXPONENT_BY_ZERO:"REDUCE_EXPONENT_BY_ZERO",REDUCE_ZERO_NUMERATOR:"REDUCE_ZERO_NUMERATOR",REMOVE_ADDING_ZERO:"REMOVE_ADDING_ZERO",REMOVE_EXPONENT_BY_ONE:"REMOVE_EXPONENT_BY_ONE",REMOVE_EXPONENT_BASE_ONE:"REMOVE_EXPONENT_BASE_ONE",REMOVE_MULTIPLYING_BY_NEGATIVE_ONE:"REMOVE_MULTIPLYING_BY_NEGATIVE_ONE",REMOVE_MULTIPLYING_BY_ONE:"REMOVE_MULTIPLYING_BY_ONE",RESOLVE_DOUBLE_MINUS:"RESOLVE_DOUBLE_MINUS",COLLECT_AND_COMBINE_LIKE_TERMS:"COLLECT_AND_COMBINE_LIKE_TERMS",COLLECT_LIKE_TERMS:"COLLECT_LIKE_TERMS",COLLECT_CONSTANT_EXPONENTS:"COLLECT_CONSTANT_EXPONENTS",ADD_COEFFICIENT_OF_ONE:"ADD_COEFFICIENT_OF_ONE",ADD_POLYNOMIAL_TERMS:"ADD_POLYNOMIAL_TERMS",GROUP_COEFFICIENTS:"GROUP_COEFFICIENTS",UNARY_MINUS_TO_NEGATIVE_ONE:"UNARY_MINUS_TO_NEGATIVE_ONE",CROSS_PRODUCT_EQUALITY:"CROSS_PRODUCT_EQUALITY",ADD_EXPONENT_OF_ONE:"ADD_EXPONENT_OF_ONE",COLLECT_POLYNOMIAL_EXPONENTS:"COLLECT_POLYNOMIAL_EXPONENTS",MULTIPLY_COEFFICIENTS:"MULTIPLY_COEFFICIENTS",MULTIPLY_POLYNOMIAL_TERMS:"MULTIPLY_POLYNOMIAL_TERMS",BREAK_UP_FRACTION:"BREAK_UP_FRACTION",CANCEL_MINUSES:"CANCEL_MINUSES",CANCEL_TERMS:"CANCEL_TERMS",SIMPLIFY_FRACTION:"SIMPLIFY_FRACTION",SIMPLIFY_SIGNS:"SIMPLIFY_SIGNS",SIMPLIFY_SIGNS_BEFORE:"SIMPLIFY_SIGNS_BEFORE",FIND_GCD:"FIND_GCD",CANCEL_GCD:"CANCEL_GCD",CONVERT_MIXED_NUMBER_TO_IMPROPER_FRACTION:"CONVERT_MIXED_NUMBER_TO_IMPROPER_FRACTION",IMPROPER_FRACTION_NUMERATOR:"IMPROPER_FRACTION_NUMERATOR",ADD_FRACTIONS:"ADD_FRACTIONS",ADD_NUMERATORS:"ADD_NUMERATORS",COMBINE_NUMERATORS:"COMBINE_NUMERATORS",COMMON_DENOMINATOR:"COMMON_DENOMINATOR",CONVERT_INTEGER_TO_FRACTION:"CONVERT_INTEGER_TO_FRACTION",DIVIDE_FRACTION_FOR_ADDITION:"DIVIDE_FRACTION_FOR_ADDITION",MULTIPLY_DENOMINATORS:"MULTIPLY_DENOMINATORS",MULTIPLY_NUMERATORS:"MULTIPLY_NUMERATORS",MULTIPLY_FRACTIONS:"MULTIPLY_FRACTIONS",SIMPLIFY_DIVISION:"SIMPLIFY_DIVISION",MULTIPLY_BY_INVERSE:"MULTIPLY_BY_INVERSE",DISTRIBUTE:"DISTRIBUTE",DISTRIBUTE_NEGATIVE_ONE:"DISTRIBUTE_NEGATIVE_ONE",SIMPLIFY_TERMS:"SIMPLIFY_TERMS",EXPAND_EXPONENT:"EXPAND_EXPONENT",ABSOLUTE_VALUE:"ABSOLUTE_VALUE",CANCEL_EXPONENT:"CANCEL_EXPONENT",CANCEL_EXPONENT_AND_ROOT:"CANCEL_EXPONENT_AND_ROOT",CANCEL_ROOT:"CANCEL_ROOT",COMBINE_UNDER_ROOT:"COMBINE_UNDER_ROOT",CONVERT_MULTIPLICATION_TO_EXPONENT:"CONVERT_MULTIPLICATION_TO_EXPONENT",DISTRIBUTE_NTH_ROOT:"DISTRIBUTE_NTH_ROOT",EVALUATE_DISTRIBUTED_NTH_ROOT:"EVALUATE_DISTRIBUTED_NTH_ROOT",FACTOR_INTO_PRIMES:"FACTOR_INTO_PRIMES",GROUP_TERMS_BY_ROOT:"GROUP_TERMS_BY_ROOT",NTH_ROOT_VALUE:"NTH_ROOT_VALUE",ADD_NTH_ROOTS:"ADD_NTH_ROOTS",MULTIPLY_NTH_ROOTS:"MULTIPLY_NTH_ROOTS",ADD_TO_BOTH_SIDES:"ADD_TO_BOTH_SIDES",DIVIDE_FROM_BOTH_SIDES:"DIVIDE_FROM_BOTH_SIDES",MULTIPLY_BOTH_SIDES_BY_INVERSE_FRACTION:"MULTIPLY_BOTH_SIDES_BY_INVERSE_FRACTION",MULTIPLY_BOTH_SIDES_BY_NEGATIVE_ONE:"MULTIPLY_BOTH_SIDES_BY_NEGATIVE_ONE",MULTIPLY_TO_BOTH_SIDES:"MULTIPLY_TO_BOTH_SIDES",SIMPLIFY_LEFT_SIDE:"SIMPLIFY_LEFT_SIDE",SIMPLIFY_RIGHT_SIDE:"SIMPLIFY_RIGHT_SIDE",SUBTRACT_FROM_BOTH_SIDES:"SUBTRACT_FROM_BOTH_SIDES",SWAP_SIDES:"SWAP_SIDES",FIND_ROOTS:"FIND_ROOTS",STATEMENT_IS_TRUE:"STATEMENT_IS_TRUE",STATEMENT_IS_FALSE:"STATEMENT_IS_FALSE",FACTOR_SYMBOL:"FACTOR_SYMBOL",FACTOR_DIFFERENCE_OF_SQUARES:"FACTOR_DIFFERENCE_OF_SQUARES",FACTOR_PERFECT_SQUARE:"FACTOR_PERFECT_SQUARE",FACTOR_SUM_PRODUCT_RULE:"FACTOR_SUM_PRODUCT_RULE",BREAK_UP_TERM:"BREAK_UP_TERM"};const{create:_s,NodeDependencies:Is,lcmDependencies:ds,nthRootDependencies:Rs,gcdDependencies:Ms,fractionDependencies:Fs,parseDependencies:Ls,evaluateDependencies:As,simplifyDependencies:Ds,formatDependencies:Ps}=ts,$s={},ws=_s({fractionDependencies:Fs,lcmDependencies:ds,gcdDependencies:Ms,nthRootDependencies:Rs,NodeDependencies:Is,formatDependencies:Ps,parseDependencies:Ls,evaluateDependencies:As,simplifyDependencies:Ds},$s);var ge=ws;const G={};G.isOperator=function(e,t=null){return e.type==="OperatorNode"&&e.fn!=="unaryMinus"&&"*+-/^".includes(e.op)&&(t?e.op===t:!0)};G.isParenthesis=function(e){return e.type==="ParenthesisNode"};G.isUnaryMinus=function(e){return e.type==="OperatorNode"&&e.fn==="unaryMinus"};G.isFunction=function(e,t=null){return!(e.type!=="FunctionNode"||t&&e.fn.name!==t)};G.isSymbol=function(e,t=!1){return e.type==="SymbolNode"?!0:t&&G.isUnaryMinus(e)?G.isSymbol(e.args[0],!1):!1};G.isConstant=function(e,t=!1){return e.type==="ConstantNode"?!0:t&&G.isUnaryMinus(e)?!!G.isConstant(e.args[0],!1):!1};G.isConstantFraction=function(e,t=!1){return G.isOperator(e,"/")?e.args.every(n=>G.isConstant(n,t)):!1};G.isConstantOrConstantFraction=function(e,t=!1){return!!(G.isConstant(e,t)||G.isConstantFraction(e,t))};G.isIntegerFraction=function(e,t=!1){if(!G.isConstantFraction(e,t))return!1;let n=e.args[0],r=e.args[1];return t&&(G.isUnaryMinus(n)&&(n=n.args[0]),G.isUnaryMinus(r)&&(r=r.args[0])),Number.isInteger(parseFloat(n.value))&&Number.isInteger(parseFloat(r.value))};var fe=G;const ae=ge,vs=fe,Ur={operator(e,t,n=!1){switch(e){case"+":return new ae.OperatorNode("+","add",t);case"-":return new ae.OperatorNode("-","subtract",t);case"/":return new ae.OperatorNode("/","divide",t);case"*":return new ae.OperatorNode("*","multiply",t,n);case"^":return new ae.OperatorNode("^","pow",t);default:throw Error("Unsupported operation: "+e)}},unaryMinus(e){return new ae.OperatorNode("-","unaryMinus",[e])},constant(e){return new ae.ConstantNode(e)},symbol(e){return new ae.SymbolNode(e)},parenthesis(e){return new ae.ParenthesisNode(e)},list(e){return new ae.ArrayNode(e)},term(e,t,n,r=!1){let o=e;return t&&(o=this.operator("^",[o,t])),n&&(r||parseFloat(n.value)!==1)&&(vs.isConstant(n)&&parseFloat(n.value)===-1&&!r?o=this.unaryMinus(o):o=this.operator("*",[n,o],!0)),o},polynomialTerm(e,t,n,r=!1){return this.term(e,t,n,r)},nthRoot(e,t){const n=Ur.symbol("nthRoot");return new ae.FunctionNode(n,[e,t])}};var Mt=Ur;function bs(e){if(e.evaluate!=null)return e.evaluate();if(e.eval!=null)return e.eval();throw Error(`Problem, no method for evaluate this : ${e}`)}var Fe=bs;const it=Mt,Ie=fe,Us=Fe;let Pe=class xr{constructor(t,n,r=!1){const o=xr.parseNode(t,n,r);this.base=o.base,this.exponent=o.exponent,this.coeff=o.coeff}getBaseNode(){return this.base}getCoeffNode(t=!1){return!this.coeff&&t?it.constant(1):this.coeff}getCoeffValue(){return this.coeff?Us(this.coeff):1}getExponentNode(t=!1){return!this.exponent&&t?it.constant(1):this.exponent}hasFractionCoeff(){return this.coeff&&Ie.isOperator(this.coeff)}hasCoeff(){return!!this.coeff}};Pe.isTerm=function(e,t,n=!1){try{return new Pe(e,t,n),!0}catch{return!1}};Pe.parseNode=function(e,t,n){let r,o,s;if(Ie.isOperator(e))if(e.op==="^"){const i=e.args[0];if(!t(i))throw Error("Expected base term, got "+i);r=i,o=e.args[1]}else if(e.op==="*"){if(n&&!e.implicit)throw Error("Expected implicit multiplication");if(e.args.length!==2)throw Error("Expected two arguments to *");const i=Ie.isParenthesis(e.args[0])?e.args[0].content:e.args[0];if(!Ie.isConstantOrConstantFraction(i))throw Error("Expected coefficient to be constant or fraction of constants term, got "+i);s=i;const c=new Pe(e.args[1],t,n);if(c.hasCoeff())throw Error("Cannot have two coefficients "+i+" and "+c.getCoeffNode());r=c.getBaseNode(),o=c.getExponentNode()}else if(e.op==="/"){const i=e.args[1];if(!Ie.isConstant(i))throw Error("denominator must be constant node, instead of "+i);const c=new Pe(e.args[0],t,n);if(c.hasFractionCoeff())throw Error("Terms with coefficients cannot have nested fractions");o=c.getExponentNode(),r=c.getBaseNode();const u=c.getCoeffNode(!0);s=it.operator("/",[u,i])}else throw Error("Unsupported operatation for term with coefficent: "+e.op);else if(Ie.isUnaryMinus(e)){var a=e.args[0];Ie.isParenthesis(a)&&(a=a.content);const i=new Pe(a,t,n);o=i.getExponentNode(),r=i.getBaseNode(),i.hasCoeff()?s=xs(i.getCoeffNode()):s=it.constant(-1)}else if(t(e))r=e;else{if(Ie.isParenthesis(e))return Pe.parseNode(e.content,t,n);throw Error("Unsupported node type: "+e.type)}return{base:r,exponent:o,coeff:s}};function xs(e){if(Ie.isConstant(e))e=it.constant(0-parseFloat(e.value));else{const t=0-parseFloat(e.args[0].value);e.args[0]=it.constant(t)}return e}var wn=Pe;const Bs=fe,Br=wn;let jt=class Gr extends Br{constructor(t,n=!1){super(t,Gr.baseNodeFunc,n)}getSymbolNode(){return this.base}getSymbolName(){return this.base.name}};jt.baseNodeFunc=function(e){return Bs.isSymbol(e)};jt.isPolynomialTerm=function(e,t=!1){return Br.isTerm(e,jt.baseNodeFunc,t)};var Yr=jt;const yt=Mt,tt=fe,It=Yr,Ce={};Ce.isNegative=function(e){if(tt.isUnaryMinus(e))return!Ce.isNegative(e.args[0]);if(tt.isConstant(e))return parseFloat(e.value)<0;if(tt.isConstantFraction(e)){const t=parseFloat(e.args[0].value),n=parseFloat(e.args[1].value);if(t<0||n<0)return!(t<0&&n<0)}else if(It.isPolynomialTerm(e)){const t=new It(e);return Ce.isNegative(t.getCoeffNode(!0))}return!1};Ce.negate=function(e,t=!1){if(tt.isConstantFraction(e))return e.args[0]=Ce.negate(e.args[0],t),e;if(It.isPolynomialTerm(e))return Ce.negatePolynomialTerm(e,t);if(!t){if(tt.isUnaryMinus(e))return e.args[0];if(tt.isConstant(e))return yt.constant(0-parseFloat(e.value))}return yt.unaryMinus(e)};Ce.negatePolynomialTerm=function(e,t=!1){if(!It.isPolynomialTerm(e))throw Error("node is not a polynomial term");const n=new It(e);let r;if(!n.hasCoeff())r=yt.constant(-1);else{const o=n.getCoeffNode();if(o.value==="-1")r=null;else if(n.hasFractionCoeff()){let s=o.args[0];s=Ce.negate(s,t);const a=o.args[1];r=yt.operator("/",[s,a])}else r=Ce.negate(o,t),r.value==="1"&&(r=null)}return yt.polynomialTerm(n.getSymbolNode(),n.getExponentNode(),r)};var J=Ce;const Gs=J,Ys=Mt,Xe=fe,le={};le.isType=function(e,t,n=!0,r=!0){return t(e)?!0:n&&Xe.isUnaryMinus(e)?le.isType(e.args[0],t,n,r):r&&Xe.isParenthesis(e)?le.isType(e.content,t,n,r):!1};le.getType=function(e,t,n=!0,r=!0,o=void 0){if(n===!0&&o===void 0)throw Error("Error in `getType`: moveUnaryMinus is undefined");if(t(e))return e;if(n&&Xe.isUnaryMinus(e))return o(le.getType(e.args[0],t,n,r,o));if(r&&Xe.isParenthesis(e))return le.getType(e.content,t,n,r,o);throw Error("`getType` called on a node that does not belong to specified type")};le.isFraction=function(e,t=!0,n=!0){return le.isType(e,r=>Xe.isOperator(r,"/"),t,n)};le.getFraction=function(e,t=!0,n=!0){const r=function(o){if(!Xe.isOperator(o,"/"))throw Error("Expected a fraction");const s=o.args[0],a=o.args[1],i=Gs.negate(s);return Ys.operator("/",[i,a])};return le.getType(e,o=>Xe.isOperator(o,"/"),n,t,r)};var Vs=le;const Hs=J,ne=fe;function Ft(e){if(!ne.isOperator(e,"/")||e.args.length!==2)return!1;const t=e.args[0],n=e.args[1];if(!(ne.isOperator(t,"*")&&t.implicit))return!1;const r=ne.isUnaryMinus(t.args[0])?Hs.negate(t.args[0].args[0]):t.args[0],o=ne.isParenthesis(t.args[1])?t.args[1].content:t.args[1];if(!(ne.isConstant(r)&&ne.isConstant(o)))return!1;const s=ne.isParenthesis(n)?n.content:n;return!!ne.isConstant(s)}function ks(e){if(!Ft(e))throw Error("Expected a mixed number");return ne.isUnaryMinus(e.args[0].args[0])}function Xs(e){if(!Ft(e))throw Error("Expected a mixed number");const t=ne.isUnaryMinus(e.args[0].args[0])?e.args[0].args[0].args[0]:e.args[0].args[0];return parseInt(t.value)}function Zs(e){if(!Ft(e))throw Error("Expected a mixed number");const t=ne.isParenthesis(e.args[0].args[1])?e.args[0].args[1].content:e.args[0].args[1];return parseInt(t.value)}function js(e){if(!Ft(e))throw Error("Expected a mixed number");const t=ne.isParenthesis(e.args[1])?e.args[1].content:e.args[1];return parseInt(t.value)}var qs={isMixedNumber:Ft,isNegativeMixedNumber:ks,getWholeNumberValue:Xs,getNumeratorValue:Zs,getDenominatorValue:js};const Ks=fe,Vr=wn;let qt=class Hr extends Vr{constructor(t,n=!1){super(t,Hr.baseNodeFunc,n)}};qt.baseNodeFunc=function(e){return Ks.isFunction(e,"nthRoot")};qt.isNthRootTerm=function(e,t=!1){return Vr.isTerm(e,qt.baseNodeFunc,t)};var Qs=qt;const kr=O,bt=fe;let ve=class{constructor(t,n,r,o=[]){if(!r)throw Error("node is not defined");if(t===void 0||typeof t!="string")throw Error("changetype isn't valid");this.changeType=t,this.oldNode=n,this.newNode=r,this.substeps=o}hasChanged(){return this.changeType!==kr.NO_CHANGE}};ve.resetChangeGroups=function(e){return e=e.cloneDeep(),e.filter(t=>t.changeGroup).forEach(t=>{delete t.changeGroup}),e};ve.noChange=function(e){return new ve(kr.NO_CHANGE,null,e)};ve.nodeChanged=function(e,t,n,r=!0,o=[]){return r&&(t.changeGroup=1,n.changeGroup=1),new ve(e,t,n,o)};ve.childChanged=function(e,t,n=null){const r=e.cloneDeep(),o=e.cloneDeep();let s=t.substeps;if(!t.oldNode)throw Error("Expected old node for changeType: "+t.changeType);function a(i,c){return i.map(u=>{u=c(u),u.substeps=a(u.substeps,c)}),i}if(bt.isParenthesis(e))r.content=t.oldNode,o.content=t.newNode,s=a(s,i=>{const c=e.cloneDeep(),u=e.cloneDeep();return c.content=i.oldNode,u.content=i.newNode,i.oldNode=c,i.newNode=u,i});else if(bt.isOperator(e)||bt.isFunction(e)&&n!==null)r.args[n]=t.oldNode,o.args[n]=t.newNode,s=a(s,i=>{const c=e.cloneDeep(),u=e.cloneDeep();return c.args[n]=i.oldNode,u.args[n]=i.newNode,i.oldNode=c,i.newNode=u,i});else if(bt.isUnaryMinus(e))r.args[0]=t.oldNode,o.args[0]=t.newNode,s=a(s,i=>{const c=e.cloneDeep(),u=e.cloneDeep();return c.args[0]=i.oldNode,u.args[0]=i.newNode,i.oldNode=c,i.newNode=u,i});else throw Error("Unexpected node type: "+e.type);return new ve(t.changeType,r,o,s)};var Xr=ve;const Ws=Mt,zs=Vs,Js=qs,ea=Qs,ta=Yr,na=Xr,ra=wn,oa=fe;var m={Creator:Ws,CustomType:zs,MixedNumber:Js,NthRootTerm:ea,PolynomialTerm:ta,Status:na,Term:ra,Type:oa};const Kt=m;function vn(e,t){if(!Kt.Type.isOperator(e,"+"))return!1;const n=e.args;if(!n.every(c=>Kt.Term.isTerm(c,t.baseNodeFunc))||n.length===1)return!1;const r=n.map(c=>new t(c)),o=r[0],s=o.getBaseNode(),a=o.getExponentNode(!0);return r.slice(1).every(c=>{const u=s.equals(c.getBaseNode()),T=c.getExponentNode(!0).equals(a);return u&&T})}function sa(e){return vn(e,Kt.NthRootTerm)}function aa(e){return vn(e,Kt.PolynomialTerm)}var Zr={canAddLikeTermNodes:vn,canAddLikeTermNthRootNodes:sa,canAddLikeTermPolynomialNodes:aa};const Ke=m;function Ht(e){if(Ke.Type.isOperator(e)||Ke.Type.isFunction(e))return e.args.every(t=>Ht(t));if(Ke.Type.isParenthesis(e))return Ht(e.content);if(Ke.Type.isConstant(e,!0))return!0;if(Ke.Type.isSymbol(e))return!1;if(Ke.Type.isUnaryMinus(e))return Ht(e.args[0]);throw Error("Unsupported node type: "+e.type)}var bn=Ht;const ft=m,jn=bn;function ia(e){const t=e.leftNode,n=e.rightNode,r=ft.Type.isConstant(n)&&parseFloat(n.value)===0,o=ft.Type.isOperator(t,"*")||ft.Type.isOperator(t,"^");if(!(r&&o))return!1;if(ft.Type.isOperator(t,"*"))return t.args.filter(a=>!jn(a)).length>=1;if(ft.Type.isOperator(t,"^"))return!jn(t)}var ca=ia;const ua=Mt,kt=fe;function la(e){return e.args?e.args[0]:e}function pa(e){return kt.isConstant(e)?ua.constant(1):e.args[1]}function ga(e){return kt.isOperator(e,"^")&&kt.isConstant(e.args[0])||kt.isConstant(e)}var jr={getBaseNode:la,getExponentNode:pa,isConstantOrConstantPower:ga};const qn=jr,Kn=m;function fa(e){if(!Kn.Type.isOperator(e)||e.op!=="*")return!1;const t=e.args;if(!t.every(s=>qn.isConstantOrConstantPower(s))||t.every(s=>!Kn.Type.isOperator(s,"^")))return!1;const n=t.map(s=>qn.getBaseNode(s)),r=n[0];return n.slice(1).every(s=>r.value===s.value)}var ha=fa;const mn=m;function Ta(e){if(!mn.Type.isOperator(e)||e.op!=="*")return!1;const t=e.args;if(!t.every(s=>mn.PolynomialTerm.isPolynomialTerm(s))||t.length===1)return!1;const n=e.args.map(s=>new mn.PolynomialTerm(s));if(!n.every(s=>!s.hasCoeff()))return!1;const r=n[0];return n.slice(1).every(s=>r.getSymbolName()===s.getSymbolName())}var qr=Ta;const Ot={};Ot.getPrimeFactors=function(e){let t=[];if(e<0)return t=[-1],t=t.concat(Ot.getPrimeFactors(-1*e)),t;const n=Math.sqrt(e);let r=2;if(e%2)for(r=3;e%r&&r<=n;)r=r+2;return r>n?t.push(e):(t.push(r),t=t.concat(Ot.getPrimeFactors(e/r))),t};Ot.getFactorPairs=function(e){const t=[],n=Math.floor(Math.sqrt(Math.abs(e)));for(var r=-n;r<=n;r++)if(r!==0&&e%r===0){const o=e/r;t.push([r,o])}return t};var Kr=Ot;const Na=Fe,Qr=J,x=m;function k(e){if(x.MixedNumber.isMixedNumber(e))return e;if(x.Type.isConstant(e,!0)){const t=x.Creator.constant(Na(e));return e.changeGroup&&(t.changeGroup=e.changeGroup),t}else if(x.Type.isOperator(e)){if("+-/*".includes(e.op)){let t;return e.op==="/"?t="*":e.op==="-"?t="+":t=e.op,Ca(e,t)}else e.args.forEach((t,n)=>{e.args[n]=k(t)});return e}else{if(x.Type.isParenthesis(e))return e.content=k(e.content),e;if(x.Type.isUnaryMinus(e)){const t=k(e.args[0]),n=Qr.negate(t,!0);return e.changeGroup&&(n.changeGroup=e.changeGroup),n}else if(x.Type.isFunction(e)&&e.fn.args){const t=k(e.fn),n=k(e.args[0]);return x.Creator.operator("*",[t,x.Creator.parenthesis(n)])}else return x.Type.isFunction(e,"abs")?(e.args[0]=k(e.args[0]),e):(x.Type.isFunction(e,"nthRoot")&&(e.args[0]=k(e.args[0]),e.args[1]&&(e.args[1]=k(e.args[1]))),e)}}function Ca(e,t){const n=nt(e,t);return n.length===1?e=n[0]:(e.op==="/"&&(n.length>2||Wr(e))?e=x.Creator.operator("*",n):e.op==="-"?e=x.Creator.operator("+",n):e.args=n,e.op==="*"&&(e.implicit=!1)),e}function nt(e,t){if(!x.Type.isOperator(e))return[k(e)];switch(e.op){case"*":case"/":if(t!=="*")return[k(e)];break;case"+":case"-":if(t!=="+")return[k(e)];break;default:return[k(e)]}if(x.PolynomialTerm.isPolynomialTerm(e,!0))return e.args.forEach((n,r)=>{e.args[r]=k(e.args[r])}),[e];if(t==="*"&&ma(e))return Ea(e);if(t==="*"&&e.op==="/")return Sa(e);if(e.op==="-"){const n=e.args[1],r=Qr.negate(n,!0),o=[nt(e.args[0],t),nt(r,t)];return[].concat.apply([],o)}else{const n=[];return e.args.forEach(r=>{n.push(nt(r,t))}),[].concat.apply([],n)}}function ma(e){if(e.op!=="*"||e.args.length!==2)return!1;const t=e.args[1];return x.PolynomialTerm.isPolynomialTerm(t)?!new x.PolynomialTerm(t).hasCoeff():!1}function Ea(e){const t=nt(e.args[0],"*"),n=t.pop(),r=k(e.args[1]);return x.Type.isConstantOrConstantFraction(n)?t.push(x.Creator.operator("*",[n,r],!1)):(t.push(n),t.push(r)),t}function Sa(e){let t=nt(e.args[0],"*");if(t.length===1)e.args[0]=t.pop(),e.args[1]=k(e.args[1]),t=[e];else{const n=t.pop(),r=k(e.args[1]),o=x.Creator.operator("/",[n,r]);t.push(o)}return t}function Wr(e){return x.Type.isOperator(e)?e.op==="*"?!0:e.op!=="/"?!1:e.args.some(Wr):!1}var Lt=k;function ya(e){const t=e.cloneDeep(),n=[],r=[];e.traverse(o=>n.push(o)),t.traverse(o=>r.push(o));for(let o=0;o<n.length;o++){const s=n[o],a=r[o];Object.prototype.hasOwnProperty.call(s,"changeGroup")&&(a.changeGroup=s.changeGroup)}return t}var Oa=ya;const _a=Oa;function Ia(e){const t=_a(e);return t.transform(function(n,r,o){return n.type==="OperatorNode"&&n.op==="*"&&((n.args[1].type==="ParenthesisNode"||n.args[1].type==="SymbolNode"||n.args[1].type==="OperatorNode"&&n.args[1].op==="^"&&n.args[1].args[0].type==="SymbolNode")&&(n.implicit=!0),n.args[1].isOperatorNode&&n.args[1].op==="^"&&n.args[1].args[0].isSymbolNode&&(n.args[1].implicit=!0)),n}),t}var zr=Ia;const{Creator:Qn,PolynomialTerm:Wn}=m,Qe=fe;function da(e){return!!(Wn.isPolynomialTerm(e)&&new Wn(e).getCoeffValue()<0)}function Ra(e){const t=e.cloneDeep();return t.transform(function(n,r,o){if(n.type==="OperatorNode"&&n.op==="*"){if(Qe.isUnaryMinus(n.args[1])||Qe.isConstant(n.args[1])&&n.args[1].value<0||da(n.args[1])||Qe.isOperator(n.args[1])&&(n.args[1].op==="+"||n.args[1].op==="-")){const s=Qn.parenthesis(n.args[1]);n.args[1]=s}}else if(n.type==="OperatorNode"&&n.op==="^"&&(Qe.isUnaryMinus(n.args[0])||Qe.isConstantOrConstantFraction(n.args[0])&&n.args[0].value<0||Qe.isOperator(n.args[0]))){const s=Qn.parenthesis(n.args[0]);n.args[0]=s}return n}),t}var Ma=Ra;const Jr=Lt,ee=m,zn=ge,eo=zr,to=Ma;function Fa(e,t=!1,n=!1,r=!0,o=!1){r?e=Jr(e.cloneDeep()):e=e.cloneDeep(),n&&e.transform(function(a,i,c){return a.isOperatorNode&&a.op==="*"&&(a.implicit=!1),a}),o&&(e=to(e));let s=_e(e);return t||(s=s.replace(/\s*?\+\s*?\-\s*?/g," - ")),n?zn.parse(s).toString({notation:"fixed"}):eo(zn.parse(s)).toString({notation:"fixed"})}function _e(e,t){if(ee.PolynomialTerm.isPolynomialTerm(e)){const n=new ee.PolynomialTerm(e);if(n.hasFractionCoeff()&&e.op!=="/"){const r=n.getCoeffNode(),o=_e(r),s=ee.Creator.polynomialTerm(n.getSymbolNode(),n.exponent,null),a=_e(s);return`${o} ${a}`}}if(ee.Type.isIntegerFraction(e))return`${e.args[0]}/${e.args[1]}`;if(ee.Type.isOperator(e)){if(e.op==="/"&&ee.Type.isOperator(e.args[1]))return`${_e(e.args[0])} / (${_e(e.args[1])})`;let n="";switch(e.op){case"+":case"-":n=` ${e.op} `;break;case"*":if(e.implicit){n=" ";break}n=` ${e.op} `;break;case"/":ee.Type.isConstantFraction(e,!0)?n=`${e.op}`:n=` ${e.op} `;break;case"^":n=`${e.op}`;break}let r=e.args.map(o=>_e(o,e)).join(n);return t&&ee.Type.isOperator(t)&&e.op&&t.op&&"*/^".indexOf(t.op)>=0&&"+-".indexOf(e.op)>=0&&(r=`(${r})`),r}else return ee.Type.isParenthesis(e)?`(${_e(e.content)})`:ee.Type.isUnaryMinus(e)?ee.Type.isOperator(e.args[0])&&"*/^".indexOf(e.args[0].op)===-1&&!ee.PolynomialTerm.isPolynomialTerm(e)?`-(${_e(e.args[0])})`:`-${_e(e.args[0])}`:e.toString()}function La(e,t=!1,n=!1,r=!0,o=!1,s){r?e=Jr(e.cloneDeep()):e=e.cloneDeep(),o&&(e=to(e)),n?e.transform(function(i,c,u){return i.isOperatorNode&&i.op==="*"&&(i.implicit=!1),i}):e=eo(e),s&&Array.isArray(s)&&s.forEach(i=>{e=i(e)});let a=e.toTex({implicit:"hide",parenthesis:"keep"});return t||(a=a.replace(/\s*?\+\s*?\-\s*?/g," - ").replaceAll("\\frac","\\dfrac").replaceAll("\\cdot","\\times ")),a=a.replace(/~/g," ").replace(/ {2,}/g," "),a}var ct={ascii:Fa,latex:La};const Xt=ge,q=O,no=Kr,Qt=J,g=m,Mn=ct;function ro(e){if(!g.Type.isFunction(e,"nthRoot"))return g.Status.noChange(e);const t=be(e);if(g.Type.isOperator(t)){if(t.op==="^")return oo(e);if(t.op==="*")return so(e)}else if(g.Type.isConstant(t))return ba(e);return g.Status.noChange(e)}function oo(e){let t=e.cloneDeep();const n=be(e),r=Ze(e),o=n.args[0],s=g.Type.isParenthesis(n.args[1])?n.args[1].content:n.args[1];if(r.equals(s))return t=o,g.Status.nodeChanged(q.CANCEL_EXPONENT_AND_ROOT,e,t);if(g.Type.isConstant(r)&&g.Type.isConstant(s)){const a=parseFloat(r.value),i=parseFloat(s.value);if(a%i===0){const c=a/i,u=g.Creator.constant(c);return t=g.Creator.nthRoot(o,u),g.Status.nodeChanged(q.CANCEL_EXPONENT,e,t)}else if(i%a===0){const c=i/a,u=g.Creator.constant(c);return t=g.Creator.operator("^",[o,u]),g.Status.nodeChanged(q.CANCEL_ROOT,e,t)}}return g.Status.noChange(e)}function so(e){let t=e.cloneDeep();const n=Ze(e),r=[];let o;return g.Type.isConstant(n)&&!Qt.isNegative(n)&&(o=Aa(t),o.hasChanged()&&(r.push(o),t=g.Status.resetChangeGroups(o.newNode)),o=Da(t),o.hasChanged()&&(r.push(o),t=g.Status.resetChangeGroups(o.newNode)),o=Pa(t),o.hasChanged()&&(r.push(o),t=g.Status.resetChangeGroups(o.newNode),t.args[0].op==="^"))?(o=oo(t),r.push(o),g.Status.nodeChanged(q.NTH_ROOT_VALUE,e,o.newNode,!0,r)):(o=$a(t),r.push(o),t=g.Status.resetChangeGroups(o.newNode),o=wa(t),o.hasChanged()?(r.push(o),t=g.Status.resetChangeGroups(o.newNode),o=va(t),o.hasChanged()&&(r.push(o),t=g.Status.resetChangeGroups(o.newNode)),g.Status.nodeChanged(q.NTH_ROOT_VALUE,e,t,!0,r)):g.Status.noChange(e))}function Aa(e){const t=e.cloneDeep(),n=be(e);let r=[],o=!1;return n.args.forEach(s=>{if(g.PolynomialTerm.isPolynomialTerm(s)){const a=new g.PolynomialTerm(s),i=a.getCoeffNode(),c=g.Creator.polynomialTerm(a.getSymbolNode(),a.getExponentNode(),null);if(i){const u=Jn(i);u.length>1&&(o=!0),r=r.concat(u)}r.push(c)}else{const a=Jn(s);a.length>1&&(o=!0),r=r.concat(a)}}),o?(t.args[0]=g.Creator.operator("*",r),g.Status.nodeChanged(q.FACTOR_INTO_PRIMES,e,t)):g.Status.noChange(e)}function Jn(e){if(g.Type.isConstant(e)&&!Qt.isNegative(e)){const t=parseFloat(e.value);return no.getPrimeFactors(t).map(g.Creator.constant)}return[e]}function Da(e){let t=e.cloneDeep();const n=be(e),r=Ze(e),o=parseFloat(r.value);n.args.sort(Ua);const s=n.args.map(T=>Mn.ascii(T));if([...new Set(s)].length===s.length)return g.Status.noChange(e);const a={};n.args.forEach(T=>{const E=Mn.ascii(T);a[E]?a[E]++:a[E]=1});const u=Object.keys(a).map(T=>{let E=a[T];const y=Xt.parse(T),H=o,K=[];for(;E-H>0;)E-=H,K.push(g.Creator.parenthesis(g.Creator.operator("*",Array(H).fill(y))));const b=E===1?y:g.Creator.parenthesis(g.Creator.operator("*",Array(E).fill(y)));return K.push(b),K}).reduce((T,E)=>T.concat(E),[]),N=g.Creator.operator("*",u);return t=g.Creator.nthRoot(N,r),g.Status.nodeChanged(q.GROUP_TERMS_BY_ROOT,e,t)}function Pa(e){const t=e.cloneDeep(),n=be(e);if(g.Type.isParenthesis(n)){const r=n.content;if(er(r)){const o=r.args[0],s=g.Creator.constant(r.args.length);return t.args[0]=g.Creator.operator("^",[o,s]),g.Status.nodeChanged(q.CONVERT_MULTIPLICATION_TO_EXPONENT,e,t)}}else if(g.Type.isOperator(n,"*")){const r=[];return n.args.forEach(o=>{if(g.Type.isParenthesis(o)){const s=o.content;if(er(s)){const a=s.args[0],i=g.Creator.constant(s.args.length);r.push(g.Creator.operator("^",[a,i]));return}}r.push(o)}),t.args[0]=g.Creator.operator("*",r),g.Status.nodeChanged(q.CONVERT_MULTIPLICATION_TO_EXPONENT,e,t)}return g.Status.noChange(e)}function $a(e){let t=e.cloneDeep();const n=be(e),r=Ze(e),o=[];for(let s=0;s<n.args.length;s++){const a=n.args[s];o.push(g.Creator.nthRoot(a,r))}return t=g.Creator.operator("*",o),g.Status.nodeChanged(q.DISTRIBUTE_NTH_ROOT,e,t)}function wa(e){const t=e.cloneDeep(),n=[];for(let r=0;r<t.args.length;r++){const o=t.args[r],s=ro(o);s.hasChanged()&&(t.args[r]=s.newNode,n.push(g.Status.childChanged(t,s,r)))}return n.length===0?g.Status.noChange(e):n.length===1?n[0]:g.Status.nodeChanged(q.EVALUATE_DISTRIBUTED_NTH_ROOT,e,t,!0,n)}function va(e){let t=e.cloneDeep(),n;const r=[],o=[];for(let s=0;s<t.args.length;s++){const a=t.args[s];g.Type.isFunction(a,"nthRoot")?(o.push(a.args[0]),n=Ze(a)):r.push(a)}if(r.length>0){if(o.length>0){const s=o.length===1?o[0]:g.Creator.operator("*",o);r.push(g.Creator.nthRoot(s,n))}if(t=g.Creator.operator("*",r),!t.equals(e))return g.Status.nodeChanged(q.COMBINE_UNDER_ROOT,e,t)}return g.Status.noChange(e)}function ba(e){let t=e.cloneDeep();const n=be(e),r=Ze(e);if(Qt.isNegative(n))return g.Status.noChange(e);if(!g.Type.isConstant(r)||Qt.isNegative(r))return g.Status.noChange(e);const o=parseFloat(n.value),s=parseFloat(r.value),a=Xt.nthRoot(o,s),i=Xt.round(a);if(Xt.pow(i,s)===o)return t=g.Creator.constant(i),g.Status.nodeChanged(q.NTH_ROOT_VALUE,e,t);{const c=no.getPrimeFactors(o);if(c.length>1){let u=[];const N=c.map(g.Creator.constant);t.args[0]=g.Creator.operator("*",N),u.push(g.Status.nodeChanged(q.FACTOR_INTO_PRIMES,e,t));const T=so(t);if(T.hasChanged())return u=u.concat(T.substeps),t=T.newNode,g.Status.nodeChanged(q.NTH_ROOT_VALUE,e,t,!0,u)}}return g.Status.noChange(e)}function Ze(e){if(!g.Type.isFunction(e,"nthRoot"))throw Error("Expected nthRoot");return e.args.length===2?e.args[1]:g.Creator.constant(2)}function be(e){if(!g.Type.isFunction(e,"nthRoot"))throw Error("Expected nthRoot");return e.args[0]}function Ua(e,t){return g.Type.isConstant(e)&&g.Type.isConstant(t)?parseFloat(e.value)-parseFloat(t.value):g.Type.isConstant(e)?-1:g.Type.isConstant(t)?1:0}function er(e){if(!g.Type.isOperator(e)||e.op!=="*")return!1;const t=e.args.map(Mn.ascii);return[...new Set(t)].length===1}var an={getRadicandNode:be,getRootNode:Ze,nthRoot:ro};const tr=m,nr=an;function xa(e){if(!tr.Type.isOperator(e,"*")||!e.args.every(r=>tr.Type.isFunction(r,"nthRoot")))return!1;const t=e.args[0],n=nr.getRootNode(t);return e.args.every(r=>nr.getRootNode(r).equals(n))}var Ba=xa;const ht=m;function Ga(e){if(e.op!=="*"||e.implicit||e.args.length!==2||!ht.PolynomialTerm.isPolynomialTerm(e.args[0]))return!1;const t=new ht.PolynomialTerm(e.args[0]);return ht.Type.isParenthesis(e.args[1])&&ht.Type.isConstantOrConstantFraction(e.args[1].content,!0)||ht.Type.isConstantOrConstantFraction(e.args[1],!0)?!t.hasCoeff():!1}var ao=Ga;const Ya=Zr,Va=qr,Ha=ao;function ka(e){return Ya.canAddLikeTermPolynomialNodes(e)||Va(e)||Ha(e)}var Xa=ka;const xe=m,Za=bn;function ze(e){return xe.Type.isParenthesis(e)?ze(e.content):xe.Type.isUnaryMinus(e)?ze(e.args[0]):xe.Type.isOperator(e)?e.args.some(ze):xe.Type.isSymbol(e)||xe.Type.isConstant(e)?!1:xe.Type.isFunction(e,"abs")?e.args.length!==1||e.args.some(ze)?!0:!Za(e.args[0]):xe.Type.isFunction(e,"nthRoot")?e.args.some(ze)||e.args.length<1:!0}var ja=ze;const oe=m,z={};z.getSymbolsInEquation=function(e){const t=z.getSymbolsInExpression(e.leftNode),n=z.getSymbolsInExpression(e.rightNode);return new Set([...t,...n])};z.getSymbolsInExpression=function(e){const n=e.filter(o=>o.isSymbolNode).map(o=>o.name);return new Set(n)};z.getLastSymbolTerm=function(e,t){if(Fn(e,t))return e;if(oe.Type.isOperator(e,"+")||oe.Type.isOperator(e,"*"))for(let n=e.args.length-1;n>=0;n--){const r=e.args[n];if(oe.Type.isOperator(r,"+"))return z.getLastSymbolTerm(r,t);if(Fn(r,t))return r}else if(oe.Type.isParenthesis(e))return z.getLastSymbolTerm(e.content,t);return null};z.getLastNonSymbolTerm=function(e,t){if(io(e,t))return new oe.PolynomialTerm(e).getCoeffNode();if(Wt(e,t))return null;if(oe.Type.isOperator(e))for(let n=e.args.length-1;n>=0;n--){const r=e.args[n];if(oe.Type.isOperator(r,"+"))return z.getLastNonSymbolTerm(r,t);if(!Fn(r,t))return r}return null};z.getLastDenominatorWithSymbolTerm=function(e,t){if(Wt(e,t))return e.args[1];if(oe.Type.isOperator(e,"+"))for(let n=e.args.length-1;n>=0;n--){const r=e.args[n];if(oe.Type.isOperator(r,"+"))return z.getLastDenominatorWithSymbolTerm(r,t);if(Wt(r,t))return r.args[1]}return null};function Fn(e,t){return io(e,t)||Wt(e,t)}function io(e,t){return!!(oe.PolynomialTerm.isPolynomialTerm(e)&&new oe.PolynomialTerm(e).getSymbolName()===t)}function Wt(e,t){return oe.Type.isOperator(e)&&e.op==="/"?z.getSymbolsInExpression(e.args[1]).has(t):!1}var Un=z;const zt=m,qa=Un;function Ka(e){if(!zt.Type.isOperator(e,"+")||e.args.length>3||qa.getSymbolsInExpression(e).size!==1)return!1;const n=e.args.filter(rr(2)),r=e.args.filter(rr(1)),o=e.args.filter(zt.Type.isConstant);return!(n.length!==1||r.length>1||o.length>1||n.length+r.length+o.length!==e.args.length)}function rr(e){return function(t){if(zt.PolynomialTerm.isPolynomialTerm(t)){const r=new zt.PolynomialTerm(t).getExponentNode(!0);return r&&parseFloat(r.value)===e}return!1}}var Qa=Ka;const or=ge,Ut=ct,sr=zr;let Ln=class co{constructor(t,n,r){this.leftNode=sr(t),this.rightNode=sr(n),this.comparator=r}ascii(t=!1,n=!1){const r=Ut.ascii(this.leftNode,t,n),o=Ut.ascii(this.rightNode,t,n),s=this.comparator;return`${r} ${s} ${o}`}latex(t=!1){const n=Ut.latex(this.leftNode,t),r=Ut.latex(this.rightNode,t),o=this.comparator;return`${n} ${o?.replaceAll(">=","\\geqslant").replaceAll("<=","\\leqslant")} ${r}`}clone(){const t=this.leftNode.cloneDeep(),n=this.rightNode.cloneDeep();return new co(t,n,this.comparator)}};Ln.createEquationFromString=function(e,t){const n=e.split(t);if(n.length!==2)throw Error("Expected two sides of an equation using comparator: "+t);const r=or.parse(n[0]),o=or.parse(n[1]);return new Ln(r,o,t)};var cn=Ln;const he=m;function Wa(e){if(e.comparator!=="=")return!1;const t=e.leftNode,n=e.rightNode;return he.Type.isOperator(t,"/")&&he.Type.isOperator(n,"/")?!!(he.Type.isConstantOrConstantFraction(t.args[0])&&he.PolynomialTerm.isPolynomialTerm(t.args[1])&&he.Type.isConstantOrConstantFraction(n.args[0])&&he.Type.isConstantOrConstantFraction(n.args[1])||he.Type.isConstantOrConstantFraction(t.args[0])&&he.Type.isConstantOrConstantFraction(t.args[1])&&he.Type.isConstantOrConstantFraction(n.args[0])&&he.PolynomialTerm.isPolynomialTerm(n.args[1])):!1}var za=Wa;const Ja=Zr,ei=ca,ti=ha,ni=qr,ri=Ba,oi=ao,si=Xa,ai=ja,ii=Qa,ci=bn,ui=za;var Ee={canFindRoots:ei,canAddLikeTerms:Ja,canMultiplyLikeTermConstantNodes:ti,canMultiplyLikeTermPolynomialNodes:ni,canMultiplyLikeTermsNthRoots:ri,canRearrangeCoefficient:oi,canSimplifyPolynomialTerms:si,hasUnsupportedNodes:ai,isQuadratic:ii,resolvesToConstant:ci,canCrossMultiplication:ui};const rt=ge,li=Kr,Te=O,pi=Fe,de=J,p=m,ar=[fi,hi,Ti,Ni];function gi(e){let t,n=0,r=0,o=0;for(const a of e.args)if(p.Type.isConstant(a))o=pi(a);else if(p.PolynomialTerm.isPolynomialTerm(a)){const i=new p.PolynomialTerm(a),c=i.getExponentNode(!0);if(c.value==="2"||c.value===2)t=i.getSymbolNode(),n=i.getCoeffValue();else if(c.value==="1"||c.value===1)r=i.getCoeffValue();else return p.Status.noChange(e)}else return p.Status.noChange(e);if(!t||!n)return p.Status.noChange(e);let s=!1;n<0&&(s=!0,n=-n,r=-r,o=-o);for(let a=0;a<ar.length;a++){const i=ar[a](e,t,n,r,o,s);if(i.hasChanged())return i}return p.Status.noChange(e)}function fi(e,t,n,r,o,s){if(!r||o)return p.Status.noChange(e);const a=rt.gcd(n,r),i=p.Creator.constant(a),c=p.Creator.constant(n/a),u=p.Creator.constant(r/a),N=p.Creator.polynomialTerm(t,null,i),T=p.Creator.polynomialTerm(t,null,c),E=p.Creator.parenthesis(p.Creator.operator("+",[T,u]));let y=p.Creator.operator("*",[N,E],!0);return s&&(y=de.negate(y)),p.Status.nodeChanged(Te.FACTOR_SYMBOL,e,y)}function hi(e,t,n,r,o,s){if(r||!o)return p.Status.noChange(e);const a=rt.gcd(n,o);n=n/a,o=o/a;const i=Math.sqrt(Math.abs(n)),c=Math.sqrt(Math.abs(o));if(Number.isInteger(i)&&Number.isInteger(c)&&o<0){const u=p.Creator.constant(i),N=p.Creator.constant(c),T=p.Creator.polynomialTerm(t,null,u),E=p.Creator.parenthesis(p.Creator.operator("+",[T,N])),y=p.Creator.parenthesis(p.Creator.operator("-",[T,N]));let H=p.Creator.operator("*",[E,y],!0);if(a!==1){const K=p.Creator.constant(a);H=p.Creator.operator("*",[K,H],!0)}return s&&(H=de.negate(H)),p.Status.nodeChanged(Te.FACTOR_DIFFERENCE_OF_SQUARES,e,H)}return p.Status.noChange(e)}function Ti(e,t,n,r,o,s){if(!r||!o)return p.Status.noChange(e);const a=rt.gcd(n,r,o);n=n/a,o=o/a;const i=Math.sqrt(Math.abs(n));let c=Math.sqrt(Math.abs(o));r<0&&(c=c*-1);const u=2*i*c;if(Number.isInteger(i)&&Number.isInteger(c)&&r/a===u){const N=p.Creator.constant(i),T=p.Creator.constant(c),E=p.Creator.polynomialTerm(t,null,N),y=p.Creator.parenthesis(p.Creator.operator("+",[E,T])),H=p.Creator.constant(2);let K=p.Creator.operator("^",[y,H]);if(a!==1){const b=p.Creator.constant(a);K=p.Creator.operator("*",[b,K],!0)}return s&&(K=de.negate(K)),p.Status.nodeChanged(Te.FACTOR_PERFECT_SQUARE,e,K)}return p.Status.noChange(e)}function Ni(e,t,n,r,o,s){let a;if(r&&o){const i=rt.gcd(n,r,o),c=p.Creator.constant(i);n=n/i,r=r/i,o=o/i;const u=n*o,N=li.getFactorPairs(u,!0);for(const T of N)if(T[0]+T[1]===r){const E=[];let y;const H=p.Creator.constant(n),K=p.Creator.constant(r),b=p.Creator.constant(o),ye=p.Creator.polynomialTerm(t,p.Creator.constant(2),H),fn=p.Creator.polynomialTerm(t,null,K);s&&(a=p.Creator.operator("+",[ye,fn,b],!0),a=de.negate(a),y=p.Status.nodeChanged(Te.REARRANGE_COEFF,e,a),E.push(y),a=p.Status.resetChangeGroups(y.newNode));const lt=T[0],pt=T[1],hn=p.Creator.constant(lt),Tn=p.Creator.constant(pt),Pt=p.Creator.polynomialTerm(t,null,hn),$t=p.Creator.polynomialTerm(t,null,Tn);a=p.Creator.operator("+",[ye,Pt,$t,b],!0),s&&(a=de.negate(a)),y=p.Status.nodeChanged(Te.BREAK_UP_TERM,e,a),E.push(y),a=p.Status.resetChangeGroups(y.newNode);const Nn=p.Creator.parenthesis(p.Creator.operator("+",[ye,Pt])),wt=p.Creator.parenthesis(p.Creator.operator("+",[$t,b]));a=p.Creator.operator("+",[Nn,wt],!0),s&&(a=de.negate(a)),y=p.Status.nodeChanged(Te.COLLECT_LIKE_TERMS,e,a),E.push(y),a=p.Status.resetChangeGroups(y.newNode);const Ue=p.Creator.constant(rt.gcd(n,lt)),qe=p.Creator.constant(n/Ue),gt=p.Creator.constant(lt/Ue),Hn=p.Creator.polynomialTerm(t,null,Ue),zo=p.Creator.polynomialTerm(t,null,qe),vt=p.Creator.parenthesis(p.Creator.operator("+",[zo,gt])),kn=p.Creator.operator("*",[Hn,vt],!0);a=p.Creator.operator("+",[kn,wt],!0),s&&(a=de.negate(a)),y=p.Status.nodeChanged(Te.FACTOR_SYMBOL,e,a),E.push(y),a=p.Status.resetChangeGroups(y.newNode);let Cn=rt.gcd(o,pt);pt<0&&(Cn=Cn*-1);const Xn=p.Creator.constant(Cn),Zn=p.Creator.parenthesis(p.Creator.operator("+",[Hn,Xn])),Jo=p.Creator.operator("*",[Xn,vt],!0);return a=p.Creator.operator("+",[kn,Jo],!0),s&&(a=de.negate(a)),y=p.Status.nodeChanged(Te.FACTOR_SYMBOL,e,a),E.push(y),a=p.Status.resetChangeGroups(y.newNode),i===1?a=p.Creator.operator("*",[vt,Zn],!0):a=p.Creator.operator("*",[c,vt,Zn],!0),s&&(a=de.negate(a)),y=p.Status.nodeChanged(Te.FACTOR_SUM_PRODUCT_RULE,e,a),E.push(y),a=p.Status.resetChangeGroups(y.newNode),p.Status.nodeChanged(Te.FACTOR_SUM_PRODUCT_RULE,e,a,!0,E)}}return p.Status.noChange(e)}var Ci=gi;const uo={};uo.appendToArrayInObject=function(e,t,n){return e[t]?e[t].push(n):e[t]=[n],e};var mi=uo;const ir=ct,Ei=O,R=m,Si=an,Q=mi,se="constant",$e="constantFraction",yi="nthRoot",ot="other",Jt={};Jt.canCollectLikeTerms=function(e){if(!(R.Type.isOperator(e,"+")||R.Type.isOperator(e,"*")))return!1;let t;if(e.op==="+")t=lo(e);else if(e.op==="*")t=po(e);else throw Error("Operation not supported: "+e.op);const n=Object.keys(t),r=n.filter(o=>o!==ot);return n.length>1&&r.some(o=>t[o].length>1)};Jt.collectLikeTerms=function(e){if(!Jt.canCollectLikeTerms(e))return R.Status.noChange(e);const t=e.op;let n=[];if(t==="+")n=lo(e);else if(t==="*")n=po(e);else throw Error("Operation not supported: "+t);const r=Object.keys(n).filter(i=>i!==se&&i!==$e&&i!==ot).sort(Ii);n[se]&&(t==="+"&&r.push(se),t==="*"&&r.unshift(se)),n[$e]&&r.push($e);let o=[],s=1;r.forEach(i=>{const c=n[i];if(c.length===1){const u=c[0].cloneDeep();u.changeGroup=s,o.push(u)}else{const u=R.Creator.parenthesis(R.Creator.operator(t,c)).cloneDeep();u.changeGroup=s,o.push(u)}c.forEach(u=>{u.changeGroup=s}),s++}),n[ot]&&(o=o.concat(n[ot]));const a=e.cloneDeep();return a.args=o,R.Status.nodeChanged(Ei.COLLECT_LIKE_TERMS,e,a,!1)};function en(e,t,n){const r=new t(e);let o=ir.ascii(r.getBaseNode());if(n==="+"){const s=ir.ascii(r.getExponentNode(!0));o+="^"+s}return o}function lo(e){let t={};for(let n=0;n<e.args.length;n++){const r=e.args[n];if(R.PolynomialTerm.isPolynomialTerm(r)){const o=en(r,R.PolynomialTerm,"+");t=Q.appendToArrayInObject(t,o,r)}else if(R.NthRootTerm.isNthRootTerm(r)){const o=en(r,R.NthRootTerm,"+");t=Q.appendToArrayInObject(t,o,r)}else if(R.Type.isIntegerFraction(r))t=Q.appendToArrayInObject(t,$e,r);else if(R.Type.isConstant(r))t=Q.appendToArrayInObject(t,se,r);else if(R.Type.isOperator(e)||R.Type.isFunction(e)||R.Type.isParenthesis(e)||R.Type.isUnaryMinus(e))t=Q.appendToArrayInObject(t,ot,r);else throw Error("Unsupported node type: "+r.type)}if(t[se]&&t[se].length===1&&t[$e]&&t[$e].length===1){const n=t[$e][0];t=Q.appendToArrayInObject(t,se,n),delete t[$e]}return t}function po(e){let t={};for(let n=0;n<e.args.length;n++){let r=e.args[n];if(R.Type.isUnaryMinus(r)&&(t=Q.appendToArrayInObject(t,se,R.Creator.constant(-1)),r=r.args[0]),R.PolynomialTerm.isPolynomialTerm(r))t=_i(t,r);else if(R.Type.isFunction(r,"nthRoot"))t=Oi(t,r);else if(R.Type.isIntegerFraction(r))t=Q.appendToArrayInObject(t,se,r);else if(R.Type.isConstant(r))t=Q.appendToArrayInObject(t,se,r);else if(R.Type.isOperator(e)||R.Type.isFunction(e)||R.Type.isParenthesis(e)||R.Type.isUnaryMinus(e))t=Q.appendToArrayInObject(t,ot,r);else throw Error("Unsupported node type: "+r.type)}return t}function Oi(e,t){const r=Si.getRootNode(t).value;return e=Q.appendToArrayInObject(e,yi+r,t),e}function _i(e,t){const n=new R.PolynomialTerm(t);let r;if(!n.hasCoeff())r=en(t,R.PolynomialTerm,"*"),e=Q.appendToArrayInObject(e,r,t);else{const o=n.getCoeffNode();let s=n.getSymbolNode();n.getExponentNode()&&(s=R.Creator.operator("^",[s,n.getExponentNode()])),e=Q.appendToArrayInObject(e,se,o),r=en(s,R.PolynomialTerm,"*"),e=Q.appendToArrayInObject(e,r,s)}return e}function Ii(e,t){if(e===t)return 0;if(e.indexOf("^")===-1)return e<t?-1:1;{const n=e.split("^")[0],r=e.split("^")[1],o=t.split("^")[0],s=t.split("^")[1];return n!==o?n<o?-1:1:r>s?-1:1}}var go=Jt;const cr=Ee,di=go,U=m;function Ri(e,t=!1){if(t)for(;U.Type.isParenthesis(e);)e=e.content;return ue(e)}function ue(e){if(U.Type.isOperator(e))return Mi(e);if(U.Type.isFunction(e))return Fi(e);if(U.Type.isParenthesis(e))return Li(e);if(U.Type.isConstant(e,!0)||U.Type.isSymbol(e))return e;if(U.Type.isUnaryMinus(e)){const t=e.args[0];return e.args[0]=ue(t),e}else throw Error("Unsupported node type: "+e.type)}function Mi(e){if(e.op==="^"&&U.Type.isParenthesis(e.args[0])){const t=e.args[0];if(U.Type.isOperator(t.content))return t.content=ue(t.content),e.args[1]=ue(e.args[1]),e}if(e.args.forEach((t,n)=>{e.args[n]=ue(t)}),"+-".includes(e.op)&&e.args.length===2){const[t,n]=e.args;if(U.Type.isParenthesis(n)&&U.Type.isOperator(n.content)&&"*/".includes(n.content.op))return e.args[1]=n.content,e}return e.op==="+"?e.args.forEach((t,n)=>{U.Type.isParenthesis(t)&&!ur(t.content)&&(e.args[n]=t.content)}):e.op==="-"&&U.Type.isParenthesis(e.args[0])&&!ur(e.args[0].content)&&(e.args[0]=e.args[0].content),e}function Fi(e){return e.args.forEach((t,n)=>{U.Type.isParenthesis(t)&&(t=t.content),e.args[n]=ue(t)}),e}function Li(e){if(U.PolynomialTerm.isPolynomialTerm(e.content))e.content.args&&e.content.args.forEach((t,n)=>{e.content.args[n]=ue(t)}),e=e.content;else if(U.Type.isConstant(e.content,!0)||U.Type.isIntegerFraction(e.content)||U.Type.isSymbol(e.content))e=e.content;else if(U.Type.isFunction(e.content))e=e.content,e=ue(e);else if(U.Type.isOperator(e.content))e.content=ue(e.content),e.content.op==="^"&&(e=e.content);else if(U.Type.isParenthesis(e.content))e=ue(e.content);else if(U.Type.isUnaryMinus(e.content))e.content=ue(e.content);else throw Error("Unsupported node type: "+e.content.type);return e}function ur(e){return di.canCollectLikeTerms(e)||cr.resolvesToConstant(e)||cr.canSimplifyPolynomialTerms(e)}var un=Ri;const lr=Ee,Ai=Ci,Di=Lt,Pi=un;function $i(e,t=!1){if(t&&console.log(`

Factoring: `+print.ascii(e,!1,!0)),lr.hasUnsupportedNodes(e))return[];let n;const r=[];return e=Di(e),e=Pi(e,!0),lr.isQuadratic(e)&&(n=Ai(e),n.hasChanged()&&r.push(n)),r}var fo=$i;const wi=ge,vi=fo;function bi(e,t=!1){let n;try{n=wi.parse(e)}catch{return[]}return n?vi(n,t):[]}var Ui=bi;const ie=m,xn={};xn.preOrder=function(e){return function(t){return _t(e,t,!0)}};xn.postOrder=function(e){return function(t){return _t(e,t,!1)}};function _t(e,t,n){let r;if(n&&(r=e(t),r.hasChanged()))return r;if(ie.Type.isConstant(t)||ie.Type.isSymbol(t))return ie.Status.noChange(t);if(ie.Type.isUnaryMinus(t)){if(r=_t(e,t.args[0],n),r.hasChanged())return ie.Status.childChanged(t,r)}else if(ie.Type.isOperator(t)||ie.Type.isFunction(t))for(let o=0;o<t.args.length;o++){const s=t.args[o],a=_t(e,s,n);if(a.hasChanged())return ie.Status.childChanged(t,a,o)}else if(ie.Type.isParenthesis(t)){if(r=_t(e,t.content,n),r.hasChanged())return ie.Status.childChanged(t,r)}else throw Error("Unsupported node type: "+t);return n?ie.Status.noChange(t):e(t)}var Se=xn;const pr=O,ho=Fe,ce=m,xi=Se,Bi=xi.postOrder(Gi);function Gi(e){if(!ce.Type.isOperator(e)||!e.args.every(t=>ce.Type.isConstant(t,!0)))return ce.Status.noChange(e);if(e.args.forEach((t,n)=>{e.args[n]=ce.Creator.constant(ho(t))}),ce.Type.isIntegerFraction(e)){const t=parseInt(e.args[0]),n=parseInt(e.args[1]);if(t%n===0){const r=ce.Creator.constant(t/n);return ce.Status.nodeChanged(pr.SIMPLIFY_ARITHMETIC,e,r)}else return ce.Status.noChange(e)}else{const t=Yi(e),n=ce.Creator.constant(t);return ce.Status.nodeChanged(pr.SIMPLIFY_ARITHMETIC,e,n)}}function Yi(e){let t=ho(e);return Math.abs(t)<1?t=parseFloat(t.toPrecision(4)):t=parseFloat(t.toFixed(4)),t}var At=Bi;const ln=O,I=m;function Vi(e){if(!I.MixedNumber.isMixedNumber(e))return I.Status.noChange(e);const t=[];let n=e.cloneDeep();const r=I.MixedNumber.getWholeNumberValue(e),o=I.MixedNumber.getNumeratorValue(e),s=I.MixedNumber.getDenominatorValue(e),a=I.MixedNumber.isNegativeMixedNumber(e);let i=Hi(n,r,o,s,a);return t.push(i),n=I.Status.resetChangeGroups(i.newNode),i=ki(n,r,o,s,a),t.push(i),n=I.Status.resetChangeGroups(i.newNode),i=Xi(n,r,o,s,a),t.push(i),n=I.Status.resetChangeGroups(i.newNode),I.Status.nodeChanged(ln.CONVERT_MIXED_NUMBER_TO_IMPROPER_FRACTION,e,n,!0,t)}function Hi(e,t,n,r,o){const s=I.Creator.parenthesis(I.Creator.operator("*",[I.Creator.constant(t),I.Creator.constant(r)])),a=I.Creator.operator("+",[s,I.Creator.constant(n)]);e.args[0].args[0].changeGroup=1,a.changeGroup=1;const i=I.Creator.constant(r);let c=I.Creator.operator("/",[a,i]);return o&&(c=I.Creator.unaryMinus(c)),I.Status.nodeChanged(ln.IMPROPER_FRACTION_NUMERATOR,e,c,!1)}function ki(e,t,n,r,o){const s=I.Creator.operator("+",[I.Creator.constant(t*r),I.Creator.constant(n)]);e.args[0].changeGroup=1,s.changeGroup=1;const a=I.Creator.constant(r);let i=I.Creator.operator("/",[s,a]);return o&&(i=I.Creator.unaryMinus(i)),I.Status.nodeChanged(ln.SIMPLIFY_ARITHMETIC,e,i,!1)}function Xi(e,t,n,r,o){const s=I.Creator.constant(t*r+n);e.args[0].changeGroup=1,s.changeGroup=1;const a=I.Creator.constant(r);let i=I.Creator.operator("/",[s,a]);return o&&(i=I.Creator.unaryMinus(i)),I.Status.nodeChanged(ln.SIMPLIFY_ARITHMETIC,e,i,!1)}var To=Vi;const Zi=Ee,ji=O,Tt=m;function qi(e){if(!Zi.canRearrangeCoefficient(e))return Tt.Status.noChange(e);let t=e.cloneDeep();const n=new Tt.PolynomialTerm(t.args[0]),r=Tt.Type.isParenthesis(t.args[1])?t.args[1].content:t.args[1],o=n.getExponentNode();return t=Tt.Creator.polynomialTerm(n.getSymbolNode(),o,r),Tt.Status.nodeChanged(ji.REARRANGE_COEFF,e,t)}var Bn=qi;const Ki=O,Nt=m;function Qi(e){if(e.op!=="^")return Nt.Status.noChange(e);const t=e.args[1];if(Nt.Type.isConstant(t)&&t.value===0){const n=Nt.Creator.constant(1);return Nt.Status.nodeChanged(Ki.REDUCE_EXPONENT_BY_ZERO,e,n)}else return Nt.Status.noChange(e)}var No=Qi;const Wi=O,Be=m;function zi(e){if(e.op!=="*")return Be.Status.noChange(e);if(e.args.findIndex(n=>Be.Type.isConstant(n)&&n.value===0?!0:Be.PolynomialTerm.isPolynomialTerm(n)?new Be.PolynomialTerm(n).getCoeffValue()===0:!1)>=0){const n=Be.Creator.constant(0);return Be.Status.nodeChanged(Wi.MULTIPLY_BY_ZERO,e,n)}else return Be.Status.noChange(e)}var Co=zi;const Ji=O,xt=m;function ec(e){if(e.op!=="/")return xt.Status.noChange(e);if(e.args[0].value===0){const t=xt.Creator.constant(0);return xt.Status.nodeChanged(Ji.REDUCE_ZERO_NUMERATOR,e,t)}else return xt.Status.noChange(e)}var mo=ec;const tc=O,Bt=m;function nc(e){if(e.op!=="+")return Bt.Status.noChange(e);const t=e.args.findIndex(r=>Bt.Type.isConstant(r)&&r.value===0);let n=e.cloneDeep();return t>=0?(n.args.splice(t,1),n.args.length===1&&(n=n.args[0]),Bt.Status.nodeChanged(tc.REMOVE_ADDING_ZERO,e,n)):Bt.Status.noChange(e)}var Eo=nc;const En=O,gr=J,Le=m;function rc(e){if(e.op!=="/")return Le.Status.noChange(e);const t=e.args[1];if(!Le.Type.isConstant(t))return Le.Status.noChange(e);let n=e.args[0].cloneDeep();if(parseFloat(t.value)===-1){Le.Type.isOperator(n)&&(n=Le.Creator.parenthesis(n));const r=gr.isNegative(n)?En.RESOLVE_DOUBLE_MINUS:En.DIVISION_BY_NEGATIVE_ONE;return n=gr.negate(n),Le.Status.nodeChanged(r,e,n)}else return parseFloat(t.value)===1?Le.Status.nodeChanged(En.DIVISION_BY_ONE,e,n):Le.Status.noChange(e)}var So=rc;const oc=Ee,sc=O,Sn=m;function ac(e){if(e.op==="^"&&oc.resolvesToConstant(e.args[1])&&Sn.Type.isConstant(e.args[0])&&e.args[0].value===1){const t=e.args[0].cloneDeep();return Sn.Status.nodeChanged(sc.REMOVE_EXPONENT_BASE_ONE,e,t)}return Sn.Status.noChange(e)}var yo=ac;const ic=O,yn=m;function cc(e){if(e.op==="^"&&yn.Type.isConstant(e.args[1])&&e.args[1].value===1){const t=e.args[0].cloneDeep();return yn.Status.nodeChanged(ic.REMOVE_EXPONENT_BY_ONE,e,t)}return yn.Status.noChange(e)}var Oo=cc;const uc=O,lc=J,Ae=m;function pc(e){if(e.op!=="*")return Ae.Status.noChange(e);const t=e.args.findIndex(i=>Ae.Type.isConstant(i)&&i.value===-1),n=e.args.findIndex(i=>Ae.Type.isUnaryMinus(i)&&Ae.Type.isConstant(i.args[0])&&i.args[0].value===1);if(t<0&&n<0)return Ae.Status.noChange(e);const r=t>=0?t:n;let o;r+1===e.args.length?o=r-1:o=r+1;let s=e.args[o];if(Ae.Type.isConstant(s))return Ae.Status.noChange(e);let a=e.cloneDeep();return s=lc.negate(s.cloneDeep()),a.args[o]=s,a.args.splice(r,1),a.args.length===1&&(a=a.args[0]),Ae.Status.nodeChanged(uc.REMOVE_MULTIPLYING_BY_NEGATIVE_ONE,e,a)}var _o=pc;const gc=O,Gt=m;function fc(e){if(e.op!=="*")return Gt.Status.noChange(e);const t=e.args.findIndex(n=>Gt.Type.isConstant(n)&&n.value===1);if(t>=0){let n=e.cloneDeep();return n.args.splice(t,1),n.args.length===1&&(n=n.args[0]),Gt.Status.nodeChanged(gc.REMOVE_MULTIPLYING_BY_ONE,e,n)}return Gt.Status.noChange(e)}var Io=fc;const Ge=O,P=m;function hc(e){if(P.Type.isOperator(e)&&e.op==="*"&&P.Type.isUnaryMinus(e.args[0])&&P.Type.isConstant(e.args[0].args[0])){const n=e.cloneDeep();return n.args[0]=P.Creator.constant(e.args[0].args[0].value*-1),P.Status.nodeChanged(Ge.RESOLVE_DOUBLE_MINUS,e,n)}if(!P.Type.isUnaryMinus(e))return P.Status.noChange(e);const t=e.args[0];if(P.Type.isUnaryMinus(t)){const n=t.args[0].cloneDeep();return P.Status.nodeChanged(Ge.RESOLVE_DOUBLE_MINUS,e,n)}else if(P.Type.isConstant(t)){const n=t.cloneDeep();return n.value=-1*n.value,P.Status.nodeChanged(Ge.RESOLVE_DOUBLE_MINUS,e,n)}else if(P.Type.isParenthesis(t)){const r=t.content;if(P.Type.isUnaryMinus(r)&&P.Type.isParenthesis(r.args[0])){const o=P.Creator.parenthesis(r.args[0].content);return P.Status.nodeChanged(Ge.RESOLVE_DOUBLE_MINUS,e,o)}else if(P.Type.isUnaryMinus(r)){const o=P.Creator.parenthesis(r.args[0]);return P.Status.nodeChanged(Ge.RESOLVE_DOUBLE_MINUS,e,o)}else if(P.Type.isConstant(r)){const o=P.Creator.constant(r.value*-1);return P.Status.nodeChanged(Ge.RESOLVE_DOUBLE_MINUS,e,o)}else if(P.Type.isSymbol(r)){const o=P.Creator.symbol(r.name);return P.Status.nodeChanged(Ge.RESOLVE_DOUBLE_MINUS,e,o)}}return P.Status.noChange(e)}var Ro=hc;const Tc=m,Nc=Se,Cc=To,mc=Bn,Ec=No,Sc=Co,yc=mo,Oc=Eo,_c=So,Ic=yo,dc=Oo,Rc=_o,Mc=Io,Fc=Ro,fr=[Cc,Sc,yc,Ec,dc,Ic,Fc,Oc,Mc,Rc,_c,mc],Lc=Nc.preOrder(Ac);function Ac(e){for(let t=0;t<fr.length;t++){const n=fr[t](e);if(n.hasChanged())return n;e=n.newNode}return Tc.Status.noChange(e)}var Dc=Lc;const Pc=O,Oe=m,$c=Se,wc=$c.postOrder(vc);function vc(e){if(!Oe.Type.isOperator(e)||e.op!=="/")return Oe.Status.noChange(e);let t=e.args[0];if(Oe.Type.isParenthesis(t)&&(t=t.content),!Oe.Type.isOperator(t)||t.op!=="+")return Oe.Status.noChange(e);const n=[],r=e.args[1];t.args.forEach(s=>{const a=Oe.Creator.operator("/",[s,r]);a.changeGroup=1,n.push(a)});let o=Oe.Creator.operator("+",n);return o=Oe.Creator.parenthesis(o),e.changeGroup=1,Oe.Status.nodeChanged(Pc.BREAK_UP_FRACTION,e,o,!1)}var bc=wc;const Uc=ge,Gn=O,hr=Fe,B=m;function xc(e){if(!B.Type.isOperator(e)||e.op!=="/"||!B.Type.isIntegerFraction(e,!0))return B.Status.noChange(e);const t=[];let n=e.cloneDeep();const r=parseInt(hr(e.args[0])),o=parseInt(hr(e.args[1]));let s=Uc.gcd(r,o);if(o<0&&(s*=-1),s===1)return B.Status.noChange(e);let a=Bc(n,s,r,o);return t.push(a),n=B.Status.resetChangeGroups(a.newNode),a=Gc(n,s,r,o),t.push(a),n=B.Status.resetChangeGroups(a.newNode),B.Status.nodeChanged(Gn.SIMPLIFY_FRACTION,e,n,!0,t)}function Bc(e,t,n,r){let o=e.cloneDeep();const s=B.Creator.constant(t);s.changeGroup=1;const a=B.Creator.parenthesis(B.Creator.operator("*",[B.Creator.constant(n/t),s])),i=B.Creator.parenthesis(B.Creator.operator("*",[B.Creator.constant(r/t),s]));return o=B.Creator.operator("/",[a,i]),B.Status.nodeChanged(Gn.FIND_GCD,e,o,!1)}function Gc(e,t,n,r){let o;const s=B.Creator.constant(n/t),a=B.Creator.constant(r/t);return parseFloat(a.value)===1?o=s:o=B.Creator.operator("/",[s,a]),B.Status.nodeChanged(Gn.CANCEL_GCD,e,o,!1)}var pn=xc;const Yc=pn,Vc=ge,je=O,gn=Fe,_=m;function Hc(e){let t=e.cloneDeep();if(!_.Type.isOperator(e)||e.op!=="+"||!e.args.every(s=>_.Type.isIntegerFraction(s,!0)))return _.Status.noChange(e);const n=e.args.map(s=>parseFloat(gn(s.args[1]))),r=[];let o;return n.every(s=>s===n[0])||(o=jc(t),r.push(o),t=_.Status.resetChangeGroups(o.newNode),o=qc(t),r.push(o),t=_.Status.resetChangeGroups(o.newNode),o=Kc(t),r.push(o),t=_.Status.resetChangeGroups(o.newNode)),o=kc(t),r.push(o),t=_.Status.resetChangeGroups(o.newNode),o=Xc(t),r.push(o),t=_.Status.resetChangeGroups(o.newNode),o=Zc(t),o.hasChanged()&&(r.push(o),t=_.Status.resetChangeGroups(o.newNode)),o=Yc(t),o.hasChanged()&&(r.push(o),t=_.Status.resetChangeGroups(o.newNode)),_.Status.nodeChanged(je.ADD_FRACTIONS,e,t,!0,r)}function kc(e){let t=e.cloneDeep();const n=t.args[0].args[1],r=[];t.args.forEach(s=>{r.push(s.args[0])});const o=_.Creator.parenthesis(_.Creator.operator("+",r));return t=_.Creator.operator("/",[o,n]),_.Status.nodeChanged(je.COMBINE_NUMERATORS,e,t)}function Xc(e){const t=e.cloneDeep();return t.args[0]=_.Creator.constant(gn(t.args[0])),_.Status.nodeChanged(je.ADD_NUMERATORS,e,t)}function Zc(e){let t=e.cloneDeep();return t.args[0].value==="0"?(t=_.Creator.constant(0),_.Status.nodeChanged(je.REDUCE_ZERO_NUMERATOR,e,t)):_.Status.noChange(e)}function jc(e){const t=e.cloneDeep(),n=t.args.map(o=>parseFloat(o.args[1].value)),r=Vc.lcm(...n);return t.args.forEach((o,s)=>{const a=r/n[s];if(a!==1){const i=_.Creator.constant(a),c=_.Creator.parenthesis(_.Creator.operator("*",[o.args[0],i])),u=_.Creator.parenthesis(_.Creator.operator("*",[o.args[1],i]));t.args[s]=_.Creator.operator("/",[c,u])}}),_.Status.nodeChanged(je.COMMON_DENOMINATOR,e,t)}function qc(e){const t=e.cloneDeep();return t.args.map(n=>{n.args[1]=_.Creator.constant(gn(n.args[1]))}),_.Status.nodeChanged(je.MULTIPLY_DENOMINATORS,e,t)}function Kc(e){const t=e.cloneDeep();return t.args.map(n=>{n.args[0]=_.Creator.constant(gn(n.args[0]))}),_.Status.nodeChanged(je.MULTIPLY_NUMERATORS,e,t)}var Yn=Hc;const Qc=Yn,Ct=O,Tr=Fe,V=m;function Wc(e){if(!V.Type.isOperator(e)||e.op!=="+"||e.args.length!==2)return V.Status.noChange(e);const t=e.args[0],n=e.args[1];let r,o;if(V.Type.isConstant(t))if(V.Type.isIntegerFraction(n))r=t,o=n;else return V.Status.noChange(e);else if(V.Type.isConstant(n))if(V.Type.isIntegerFraction(t))r=n,o=t;else return V.Status.noChange(e);else return V.Status.noChange(e);let s=e.cloneDeep(),a=[],i,c,u;if(Number.isInteger(parseFloat(r.value))){const T=o.args[1],E=parseInt(T),y=parseInt(r.value),H=V.Creator.constant(y*E);i=V.Creator.operator("/",[H,T]),c=o,u=Ct.CONVERT_INTEGER_TO_FRACTION}else{let T=Tr(o);T<1?T=parseFloat(T.toPrecision(4)):T=parseFloat(T.toFixed(4)),c=V.Creator.constant(T),i=r,u=Ct.DIVIDE_FRACTION_FOR_ADDITION}if(V.Type.isConstant(t)?(s.args[0]=i,s.args[1]=c):(s.args[0]=c,s.args[1]=i),a.push(V.Status.nodeChanged(u,e,s)),s=V.Status.resetChangeGroups(s),u===Ct.CONVERT_INTEGER_TO_FRACTION){const T=Qc(s);a=a.concat(T.substeps)}else{const T=V.Creator.constant(Tr(s));a.push(V.Status.nodeChanged(Ct.SIMPLIFY_ARITHMETIC,s,T))}const N=a[a.length-1];return s=V.Status.resetChangeGroups(N.newNode),V.Status.nodeChanged(Ct.SIMPLIFY_ARITHMETIC,e,s,!0,a)}var Mo=Wc;const zc=Mo,Nr=Yn,Cr=At,Fo=O,v=m;function Lo(e){if(v.Type.isParenthesis(e)&&(e=e.content),!v.Type.isOperator(e)||e.op!=="+"||e.args.some(i=>!v.Type.isConstantOrConstantFraction(i)))return v.Status.noChange(e);const t=[Cr,Nr,zc];for(let i=0;i<t.length;i++){const c=t[i](e);if(c.hasChanged()&&v.Type.isConstantOrConstantFraction(c.newNode))return c}let n=e.cloneDeep();const r=[];let o;o=Jc(n),r.push(o),n=v.Status.resetChangeGroups(o.newNode);const s=n.args[0],a=n.args[1];if(v.Type.isParenthesis(s)){const i=s.content,c=Cr(i);o=v.Status.childChanged(n,c,0),r.push(o),n=v.Status.resetChangeGroups(o.newNode)}if(v.Type.isParenthesis(a)){const i=a.content,c=Nr(i);o=v.Status.childChanged(n,c,1),r.push(o),n=v.Status.resetChangeGroups(o.newNode)}return o=Lo(n),r.push(o),n=v.Status.resetChangeGroups(o.newNode),v.Status.nodeChanged(Fo.SIMPLIFY_ARITHMETIC,e,n,!0,r)}function Jc(e){let t=e.args.filter(v.Type.isIntegerFraction),n=e.args.filter(v.Type.isConstant);if(t.length===0||n.length===0)throw Error("expected both integer fractions and constants, got "+e);if(t.length+n.length!==e.args.length)throw Error("can only evaluate integer fractions and constants");n=n.map(o=>(o.changeGroup=1,o.cloneDeep())),n.length>1?n=v.Creator.parenthesis(v.Creator.operator("+",n)):n=n[0],t=t.map(o=>(o.changeGroup=2,o.cloneDeep())),t.length>1?t=v.Creator.parenthesis(v.Creator.operator("+",t)):t=t[0];const r=v.Creator.operator("+",[n,t]);return v.Status.nodeChanged(Fo.COLLECT_LIKE_TERMS,e,r)}var eu=Lo;const Ao=Ee,Do=eu,Dt=O,w=m;function tu(e,t=!1){if(!w.Type.isOperator(e))return w.Status.noChange(e);let n;return!t&&(n=Do(e),n.hasChanged())||(n=nu(e),n.hasChanged())||(n=ru(e),n.hasChanged())?n:w.Status.noChange(e)}function nu(e){return Ao.canAddLikeTerms.canAddLikeTermPolynomialNodes(e)?Po(e,w.PolynomialTerm,Dt.ADD_POLYNOMIAL_TERMS):w.Status.noChange(e)}function ru(e){return Ao.canAddLikeTerms.canAddLikeTermNthRootNodes(e)?Po(e,w.NthRootTerm,Dt.ADD_NTH_ROOTS):w.Status.noChange(e)}function Po(e,t,n){const r=[];let o=e.cloneDeep(),s=ou(o,t);return s.hasChanged()&&(r.push(s),o=w.Status.resetChangeGroups(s.newNode)),s=su(o,t),s.hasChanged()&&(r.push(s),o=w.Status.resetChangeGroups(s.newNode)),s=au(o,t),r.push(s),o=w.Status.resetChangeGroups(s.newNode),s=iu(o),r.push(s),o=w.Status.resetChangeGroups(s.newNode),w.Status.nodeChanged(n,e,o,!0,r)}function ou(e,t){const n=e.cloneDeep();let r=!1,o=1;return n.args.forEach((s,a)=>{const i=new t(s);i.getCoeffValue()===1&&(n.args[a]=w.Creator.term(i.getBaseNode(),i.getExponentNode(),w.Creator.constant(1),!0),n.args[a].changeGroup=o,e.args[a].changeGroup=o,r=!0,o++)}),r?w.Status.nodeChanged(Dt.ADD_COEFFICIENT_OF_ONE,e,n,!1):w.Status.noChange(e)}function su(e,t){const n=e.cloneDeep();let r=!1,o=1;return n.args.forEach((s,a)=>{const i=new t(s);i.getCoeffValue()===-1&&(n.args[a]=w.Creator.term(i.getBaseNode(),i.getExponentNode(),i.getCoeffNode(),!0),e.args[a].changeGroup=o,n.args[a].changeGroup=o,r=!0,o++)}),r?w.Status.nodeChanged(Dt.UNARY_MINUS_TO_NEGATIVE_ONE,e,n,!1):w.Status.noChange(e)}function au(e,t){let n=e.cloneDeep();const r=n.args.map(u=>new t(u)),o=r.map(u=>u.getCoeffNode(!0)),s=w.Creator.parenthesis(w.Creator.operator("+",o));s.changeGroup=1;const a=r[0],i=a.getExponentNode(),c=a.getBaseNode();return n=w.Creator.term(c,i,s),w.Status.nodeChanged(Dt.GROUP_COEFFICIENTS,e,n,!1)}function iu(e){const t=e.cloneDeep().args[0],n=Do(t);return w.Status.childChanged(e,n,0)}var cu=tu;const uu=O,Z=m,lu=Se,pu=lu.postOrder(gu);function gu(e){if(!Z.Type.isOperator(e)||e.op!=="*")return Z.Status.noChange(e);const t=e.args.some(u=>Z.CustomType.isFraction(u)),n=e.args.some(Z.PolynomialTerm.isPolynomialTerm),r=e.args.some(fu);if(!t||n&&!r)return Z.Status.noChange(e);const o=[],s=[];e.args.forEach(u=>{if(Z.CustomType.isFraction(u)){const N=Z.CustomType.getFraction(u);o.push(N.args[0]),s.push(N.args[1])}else o.push(u)});const a=Z.Creator.parenthesis(Z.Creator.operator("*",o)),i=s.length===1?s[0]:Z.Creator.parenthesis(Z.Creator.operator("*",s)),c=Z.Creator.operator("/",[a,i]);return Z.Status.nodeChanged(uu.MULTIPLY_FRACTIONS,e,c)}function fu(e){if(!Z.CustomType.isFraction(e))return!1;const n=Z.CustomType.getFraction(e).args[1];return Z.PolynomialTerm.isPolynomialTerm(n)}var $o=pu;const wo=At,st=Ee,An=jr,hu=$o,we=O,M=m,mr=an;function Tu(e,t=!1){if(!M.Type.isOperator(e))return M.Status.noChange(e);let n;return!t&&!st.canMultiplyLikeTermConstantNodes(e)&&(n=wo(e),n.hasChanged()||(n=hu(e),n.hasChanged()))||(n=Cu(e),n.hasChanged())?(n.changeType=we.MULTIPLY_COEFFICIENTS,n):(n=Nu(e),n.hasChanged()?n:M.Status.noChange(e))}function Nu(e){if(!st.canMultiplyLikeTermsNthRoots(e))return M.Status.noChange(e);let t=e.cloneDeep();const n=e.args.map(a=>mr.getRadicandNode(a)),r=M.Creator.operator("*",n),o=e.args[0],s=mr.getRootNode(o);return t=M.Creator.nthRoot(r,s),M.Status.nodeChanged(we.MULTIPLY_NTH_ROOTS,e,t,!1)}function Cu(e){if(!st.canMultiplyLikeTermPolynomialNodes(e)&&!st.canMultiplyLikeTermConstantNodes(e))return M.Status.noChange(e);const t=[];let n=e.cloneDeep(),r=mu(n);r.hasChanged()&&(t.push(r),n=M.Status.resetChangeGroups(r.newNode)),st.canMultiplyLikeTermConstantNodes(e)?r=Eu(n):r=Su(n),t.push(r),n=M.Status.resetChangeGroups(r.newNode);const o=n.args[1].content,s=wo(o);return s.hasChanged()&&(r=M.Status.childChanged(n,s,1),t.push(r),n=M.Status.resetChangeGroups(r.newNode)),t.length===1?t[0]:M.Status.nodeChanged(we.MULTIPLY_POLYNOMIAL_TERMS,e,n,!0,t)}function mu(e){const t=e.cloneDeep();let n=!1,r=1;return st.canMultiplyLikeTermConstantNodes(e)?t.args.forEach((o,s)=>{if(M.Type.isConstant(o)){const a=An.getBaseNode(o),i=M.Creator.constant(1);t.args[s]=M.Creator.operator("^",[a,i]),t.args[s].changeGroup=r,e.args[s].changeGroup=r,n=!0,r++}}):t.args.forEach((o,s)=>{const a=new M.PolynomialTerm(o);a.getExponentNode()||(t.args[s]=M.Creator.polynomialTerm(a.getSymbolNode(),M.Creator.constant(1),a.getCoeffNode()),t.args[s].changeGroup=r,e.args[s].changeGroup=r,n=!0,r++)}),n?M.Status.nodeChanged(we.ADD_EXPONENT_OF_ONE,e,t,!1):M.Status.noChange(e)}function Eu(e){const t=An.getBaseNode(e.args[0]),n=e.args.map(An.getExponentNode),r=M.Creator.parenthesis(M.Creator.operator("+",n)),o=M.Creator.operator("^",[t,r]);return M.Status.nodeChanged(we.COLLECT_CONSTANT_EXPONENTS,e,o)}function Su(e){const t=e.args.map(a=>new M.PolynomialTerm(a)),n=t[0].getSymbolNode(),r=t.map(a=>a.getExponentNode(!0)),o=M.Creator.parenthesis(M.Creator.operator("+",r)),s=M.Creator.polynomialTerm(n,o,null);return M.Status.nodeChanged(we.COLLECT_POLYNOMIAL_EXPONENTS,e,s)}var yu=Tu;const vo=cu,Ou=Ee,Dn=yu,_u=O,Iu=go,ke=m,du=Se,Ru={"+":vo,"*":Dn},Mu=du.postOrder(Fu);function Fu(e){if(e.op==="+"){const t=Er(e);return t.hasChanged()?t:vo(e,!0)}else if(e.op==="*"){if(Ou.canMultiplyLikeTermConstantNodes(e))return Dn(e,!0);const t=Er(e);return t.hasChanged()?(t.newNode.implicit=!0,t):Dn(e,!0)}else return ke.Status.noChange(e)}function Er(e){let t=[];const n=Iu.collectLikeTerms(e.cloneDeep());if(!n.hasChanged())return n;t.push(n);let r=ke.Status.resetChangeGroups(n.newNode);const o=Lu(r);if(o.length>0){t=t.concat(o);const s=o[o.length-1];r=ke.Status.resetChangeGroups(s.newNode)}return ke.Status.nodeChanged(_u.COLLECT_AND_COMBINE_LIKE_TERMS,e,r,!0,t)}function Lu(e){const t=[];let n=e.cloneDeep();for(let r=0;r<e.args.length;r++){let o=e.args[r];if(!ke.Type.isParenthesis(o))continue;o=o.content;const s=Ru[n.op](o);if(s.hasChanged()){const a=ke.Status.childChanged(n,s,r);t.push(a),n=ke.Status.resetChangeGroups(a.newNode)}}return t}var bo=Mu;const Au=At,Du=bo,Pu=Bn,Ne=O,Sr=J,h=m,$u=Se,wu=$u.postOrder(vu);function vu(e){return h.Type.isUnaryMinus(e)?bu(e):h.Type.isOperator(e,"*")?xo(e):h.Type.isOperator(e,"^")?Uo(e):h.Status.noChange(e)}function Uo(e){if(!h.Type.isOperator(e,"^"))return h.Status.noChange(e);const t=h.Type.isParenthesis(e.args[0])?e.args[0].content:e.args[0],n=h.Type.isParenthesis(e.args[1])?e.args[1].content:e.args[1],r=parseFloat(n.value);if(!(Number.isInteger(r)&&r>1)||!h.Type.isFunction(t,"nthRoot")&&!(h.Type.isOperator(t,"+")||h.Type.isOperator(t,"*")||h.Type.isOperator(t,"/")))return h.Status.noChange(e);const o=h.Type.isFunction(t,"nthRoot")?t:e.args[0];let s;const a=[];let i;if(h.Type.isFunction(t,"nthRoot"))return s=h.Creator.operator("*",Array(parseFloat(n.value)).fill(o)),h.Status.nodeChanged(Ne.EXPAND_EXPONENT,e,s,!1);if(h.Type.isOperator(t,"+")){acarre=h.Creator.operator("^",[t.args[0],n]),bcarre=h.Creator.operator("^",[t.args[1],n]),doubleproduit=h.Creator.operator("*",[h.Creator.constant(2),h.Creator.operator("*",t.args)]),s=h.Creator.operator("+",[acarre,doubleproduit,bcarre]),i=h.Status.nodeChanged(Ne.EXPAND_EXPONENT,e,s,!1),a.push(i),newNode=h.Status.resetChangeGroups(i.newNode);const c=Go(newNode);return c.hasChanged()&&(i=h.Status.childChanged(newNode,c),a.push(i),newNode=h.Status.resetChangeGroups(i.newNode)),a.length===1?a[0]:h.Status.nodeChanged(Ne.DISTRIBUTE,e,newNode,!1,a)}else if(h.Type.isOperator(t,"*")){for(let c=0;c<t.args.length;c++)t.args[c]=h.Creator.operator("^",[t.args[c],n]);return h.Status.nodeChanged(Ne.EXPAND_EXPONENT,e,t,!1)}else if(h.Type.isOperator(t,"/")){for(let c=0;c<2;c++)t.args[c]=h.Creator.operator("^",[t.args[c],n]);return h.Status.nodeChanged(Ne.EXPAND_EXPONENT,e,t,!1)}}function bu(e){if(!h.Type.isUnaryMinus(e))return h.Status.noChange(e);const t=e.args[0];if(!h.Type.isParenthesis(t))return h.Status.noChange(e);const n=t.content;if(!h.Type.isOperator(n))return h.Status.noChange(e);const r=n.cloneDeep();if(e.changeGroup=1,n.op==="*"||n.op==="/"){r.args[0]=Sr.negate(r.args[0]),r.args[0].changeGroup=1;const o=h.Creator.parenthesis(r);return h.Status.nodeChanged(Ne.DISTRIBUTE_NEGATIVE_ONE,e,o,!1)}else if(n.op==="+"){const o=r.args.map(a=>{const i=Sr.negate(a);return i.changeGroup=1,i});r.args=o;const s=h.Creator.parenthesis(r);return h.Status.nodeChanged(Ne.DISTRIBUTE_NEGATIVE_ONE,e,s,!1)}else return h.Status.noChange(e)}function xo(e){if(!h.Type.isOperator(e)||e.op!=="*")return h.Status.noChange(e);for(let t=0;t+1<e.args.length;t++){if(!tn(e.args[t])&&!tn(e.args[t+1]))continue;let n=e.cloneDeep();const r=[];let o;const s=Uu(n.args[t],n.args[t+1]);if(e.args[t].changeGroup=1,e.args[t+1].changeGroup=1,s.changeGroup=1,n.args.length>2?(n.args.splice(t,2,s),n.args[t].changeGroup=1):(n=s,n.changeGroup=1),o=h.Status.nodeChanged(Ne.DISTRIBUTE,e,n,!1),r.push(o),n=h.Status.resetChangeGroups(o.newNode),h.Type.isOperator(n,"*")){const a=Or(n.args[t]);a.hasChanged()&&(o=h.Status.childChanged(n,a,t),r.push(o),n=h.Status.resetChangeGroups(o.newNode))}else if(h.Type.isParenthesis(n))o=Or(n),o.hasChanged()&&(r.push(o),n=h.Status.resetChangeGroups(o.newNode));else throw Error("Unsupported node type for distribution: "+e);return r.length===1?r[0]:h.Status.nodeChanged(Ne.DISTRIBUTE,e,n,!1,r)}return h.Status.noChange(e)}function Uu(e,t){let n,r;tn(e)?n=e.content.args:n=[e],tn(t)?r=t.content.args:r=[t];const o=[];if([n,r].filter(yr).length===1){const s=yr(n),a=s?n:r,i=s?t:e;a.forEach(c=>{let u;if(Bo(c)){let N=h.Creator.operator("*",[c.args[0],i]);N=h.Creator.parenthesis(N),u=h.Creator.operator("/",[N,c.args[1]])}else u=h.Creator.operator("*",[c,i]);u.changeGroup=1,o.push(u)})}else n.length>1&&r.length>1?n.forEach(s=>{const a=h.Creator.operator("*",[s,t]);a.changeGroup=1,o.push(a)}):n.forEach(s=>{r.forEach(a=>{const i=h.Creator.operator("*",[s,a]);i.changeGroup=1,o.push(i)})});return h.Creator.parenthesis(h.Creator.operator("+",o))}function yr(e){return e.filter(Bo).length>0}function Bo(e){return h.Type.isOperator(e,"/")}function Or(e){if(!h.Type.isParenthesis(e))throw Error("expected "+e+" to be a parenthesis node");const t=Go(e.content);return t.hasChanged()?h.Status.childChanged(e,t):h.Status.noChange(e)}function Go(e){const t=[],n=[Au,Pu,Du,xo,Uo];let r=e.cloneDeep();for(let o=0;o<r.args.length;o++)for(let s=0;s<n.length;s++){const a=n[s](r.args[o]);if(a.hasChanged()){const i=h.Status.childChanged(r,a,o);t.push(i),r=h.Status.resetChangeGroups(i.newNode)}}return t.length===0?h.Status.noChange(e):h.Status.nodeChanged(Ne.SIMPLIFY_TERMS,e,r,!1,t)}function tn(e){if(!h.Type.isParenthesis(e))return!1;const t=e.content;return h.Type.isOperator(t,"+")}var xu=wu;const Yo=O,W=m,Bu=Se,Gu=Bu.preOrder(Yu);function Yu(e){if(!W.Type.isOperator(e)||e.op!=="/")return W.Status.noChange(e);let t=Vu(e);return t.hasChanged()||(t=Hu(e),t.hasChanged())?t:W.Status.noChange(e)}function Vu(e){let t=e.args[1];if(W.Type.isParenthesis(t)&&(t=t.content),!W.Type.isOperator(t)||t.op!=="/")return W.Status.noChange(e);const n=t.args[1],r=t.args[0],o=W.Creator.operator("/",[n,r]),s=W.Creator.operator("*",[e.args[0],o]);return W.Status.nodeChanged(Yo.MULTIPLY_BY_INVERSE,e,s)}function Hu(e){const t=ku(e);if(t.length>2){const n=t.shift(),r=W.Creator.parenthesis(W.Creator.operator("*",t)),o=W.Creator.operator("/",[n,r]);return W.Status.nodeChanged(Yo.SIMPLIFY_DIVISION,e,o)}return W.Status.noChange(e)}function ku(e){let t=e;const n=[];for(;t.op==="/";)n.unshift(t.args[1]),t=t.args[0];return n.unshift(t),n}var Xu=Gu;const Pn=pn,We=ct,Yt=O,On=J,C=m;class X{constructor(t,n,r=!1){this.numerator=t,this.denominator=n,this.hasChanged=r}}function Zu(e){if(!C.Type.isOperator(e)||e.op!=="/")return C.Status.noChange(e);let t=e.cloneDeep();const n=t.args[0],r=t.args[1];if(!Ye(n)&&!Ye(r)){const o=Re(n,r);return o.hasChanged?(t.args[0]=o.numerator||C.Creator.constant(1),o.denominator?t.args[1]=o.denominator:t=t.args[0],C.Status.nodeChanged(Yt.CANCEL_TERMS,e,t)):C.Status.noChange(e)}else if(Ye(n)&&!Ye(r)){const o=C.Type.isParenthesis(n)?n.content.args:n.args;for(let s=0;s<o.length;s++){const a=Re(o[s],r);if(a.hasChanged)return a.numerator?o[s]=a.numerator:(o.splice(s,1),o.length===1&&(t.args[0]=o[0])),a.denominator?t.args[1]=a.denominator:t=t.args[0],C.Status.nodeChanged(Yt.CANCEL_TERMS,e,t)}return C.Status.noChange(e)}else if(Ye(r)&&!Ye(n)){const o=C.Type.isParenthesis(r)?r.content.args:r.args;for(let s=0;s<o.length;s++){const a=Re(n,o[s]);if(a.hasChanged)return t.args[0]=a.numerator||C.Creator.constant(1),a.denominator?o[s]=a.denominator:(o.splice(s,1),o.length===1&&(t.args[1]=o[0])),C.Status.nodeChanged(Yt.CANCEL_TERMS,e,t)}return C.Status.noChange(e)}else{const o=C.Type.isParenthesis(n)?n.content.args:n.args,s=C.Type.isParenthesis(r)?r.content.args:r.args;for(let a=0;a<o.length;a++)for(let i=0;i<s.length;i++){const c=Re(o[a],s[i]);if(c.hasChanged)return c.numerator?o[a]=c.numerator:(o.splice(a,1),o.length===1&&(t.args[0]=o[0])),c.denominator?s[i]=c.denominator:(s.splice(i,1),s.length===1&&(t.args[1]=s[0])),C.Status.nodeChanged(Yt.CANCEL_TERMS,e,t)}return C.Status.noChange(e)}}function Re(e,t){if(C.Type.isUnaryMinus(e)){const n=Re(e.args[0],t);return n.numerator?On.isNegative(n.numerator)?e=On.negate(n.numerator):e.args[0]=n.numerator:e=C.Creator.constant(-1),t=Re.denominator,new X(e,t,n.hasChanged)}if(C.Type.isUnaryMinus(t)){const n=Re(e,t.args[0]);return e=n.numerator,n.denominator?t.args[0]=n.denominator:(t=n.denominator,e?e=On.negate(e):e=C.Creator.constant(-1)),new X(e,t,n.hasChanged)}if(C.Type.isParenthesis(e)){const n=Re(e.content,t);return n.numerator?e.content=n.numerator:e=n.numerator,t=n.denominator,new X(e,t,n.hasChanged)}if(C.Type.isParenthesis(t)){const n=Re(e,t.content);return n.denominator?t.content=n.denominator:t=n.denominator,e=n.numerator,new X(e,t,n.hasChanged)}if(We.ascii(e)===We.ascii(t))return new X(null,null,!0);if(C.Type.isOperator(e,"^")&&C.Type.isOperator(t,"^")&&We.ascii(e.args[0])===We.ascii(t.args[0])){const n=e.args[1];let r=t.args[1];r=C.Creator.parenthesis(r);const o=C.Creator.parenthesis(C.Creator.operator("-",[n,r]));return e.args[1]=o,new X(e,null,!0)}if(C.PolynomialTerm.isPolynomialTerm(e)&&C.PolynomialTerm.isPolynomialTerm(t)){const n=new C.PolynomialTerm(e),r=new C.PolynomialTerm(t);if(n.getSymbolName()!==r.getSymbolName())return C.Type.isOperator(e,"*")&&C.Type.isOperator(t,"*")?ju(e,t):new X(e,t);const o=n.getExponentNode(!0);let s=r.getExponentNode(!0);if(We.ascii(o)===We.ascii(s))e=n.getCoeffNode();else{s=C.Creator.parenthesis(s);const a=C.Creator.parenthesis(C.Creator.operator("-",[o,s]));e=C.Creator.polynomialTerm(n.getSymbolNode(),a,n.getCoeffNode())}return t=r.getCoeffNode(),new X(e,t,!0)}if(C.Type.isConstant(e)&&C.Type.isOperator(t,"*")&&C.PolynomialTerm.isPolynomialTerm(t)){const n=new C.PolynomialTerm(t),r=n.getCoeffNode(),o=n.getSymbolNode(),s=n.getExponentNode(),a=C.Creator.operator("/",[e,r]);let i=r.cloneDeep();const c=Pn(a);return c.hasChanged()?(C.Type.isConstant(c.newNode)?(e=c.newNode,i=null):[e,i]=c.newNode.args,t=C.Creator.polynomialTerm(o,s,i),new X(e,t,!0)):new X(e,t,!1)}if(C.Type.isConstant(e)&&C.Type.isConstant(t)){const n=C.Creator.operator("/",[e,t]),r=Pn(n);return r.hasChanged()?C.Type.isConstant(r.newNode)?new X(r.newNode,null,!0):(C.Type.isConstant(r.newNode)?(e=r.newNode,t=null):[e,t]=r.newNode.args,new X(e,t,!0)):new X(e,t,!1)}return new X(e,t)}function Ye(e){return C.Type.isParenthesis(e)?Ye(e.content):C.Type.isOperator(e,"*")&&!C.PolynomialTerm.isPolynomialTerm(e)}function ju(e,t){const n=new C.PolynomialTerm(t),r=new C.PolynomialTerm(e),o=n.getCoeffNode(),s=n.getSymbolNode(),a=n.getExponentNode(),i=r.getCoeffNode(),c=r.getSymbolNode(),u=r.getExponentNode(),N=C.Creator.operator("/",[i,o]),T=Pn(N);if(!T.hasChanged())return new X(e,t,!1);let E=null,y=null;C.Type.isConstant(T.newNode)?(y=C.Creator.polynomialTerm(c,u,T.newNode),E=null):(y=C.Creator.polynomialTerm(c,u,T.newNode.args[0]),E=T.newNode.args[1]);const H=C.Creator.polynomialTerm(s,a,E);return new X(y,H,!0)}var qu=Zu;const _r=O,Vt=J,mt=m;function Ku(e){if(!mt.Type.isOperator(e)||e.op!=="/")return mt.Status.noChange(e);const t=e.cloneDeep();let n=e.args[0],r=e.args[1];if(Vt.isNegative(r)){r=Vt.negate(r);const o=Vt.isNegative(n)?_r.CANCEL_MINUSES:_r.SIMPLIFY_SIGNS;n=Vt.negate(n);const s=mt.Creator.operator("/",[n,r]);return mt.Status.nodeChanged(o,t,s)}else return mt.Status.noChange(e)}var Vo=Ku;const Qu=At,Wu=pn,De=m;function zu(e){if(!De.PolynomialTerm.isPolynomialTerm(e))return De.Status.noChange(e);const t=new De.PolynomialTerm(e.cloneDeep());if(!t.hasFractionCoeff())return De.Status.noChange(e);const n=[Wu,Qu];for(let r=0;r<n.length;r++){const o=t.getCoeffNode(),s=n[r](o);if(s.hasChanged()){let a=De.Status.resetChangeGroups(s.newNode);a.value==="1"&&(a=null);const i=t.getExponentNode(),c=De.Creator.polynomialTerm(t.getSymbolNode(),i,a);return De.Status.nodeChanged(s.changeType,e,c)}}return De.Status.noChange(e)}var Ju=zu;const el=Mo,tl=Yn,nl=qu,rl=pn,ol=Vo,sl=Ju,al=m,il=Se,Ir=[tl,el,ol,rl,sl,nl],cl=il.preOrder(ul);function ul(e){for(let t=0;t<Ir.length;t++){const n=Ir[t](e);if(n.hasChanged())return n;e=n.newNode}return al.Status.noChange(e)}var ll=cl;const _n=ge,dr=O,In=Fe,te=m;function pl(e){if(!te.Type.isFunction(e,"abs")||e.args.length>1)return te.Status.noChange(e);let t=e.cloneDeep();const n=t.args[0];if(te.Type.isConstant(n,!0))return t=te.Creator.constant(_n.abs(In(n))),te.Status.nodeChanged(dr.ABSOLUTE_VALUE,e,t);if(te.Type.isConstantFraction(n,!0)){const r=te.Creator.constant(_n.abs(In(n.args[0]))),o=te.Creator.constant(_n.abs(In(n.args[1])));return t=te.Creator.operator("/",[r,o]),te.Status.nodeChanged(dr.ABSOLUTE_VALUE,e,t)}else return te.Status.noChange(e)}var gl=pl;const fl=gl,dn=m,hl=an,Tl=Se,Rr=[hl.nthRoot,fl],Nl=Tl.postOrder(Cl);function Cl(e){if(!dn.Type.isFunction(e))return dn.Status.noChange(e);for(let t=0;t<Rr.length;t++){const n=Rr[t](e);if(n.hasChanged())return n}return dn.Status.noChange(e)}var ml=Nl;const El=Ee,Sl=m,yl=Xr,Ol=At,_l=Dc,Il=bc,dl=bo,Rl=xu,Ml=Xu,Fl=ll,Ll=ml,Al=$o,Rn=Lt,$n=ct,nn=un;function Dl(e,t=!1){if(t&&console.log(`

Simplifying: `+$n.ascii(e,!1,!0)),El.hasUnsupportedNodes(e))return[];let n;const r=[],o=$n.ascii(e),s=20;let a=0;for(n=Mr(e);n.hasChanged();)if(t&&Pl(n),r.push(Ho(n)),e=yl.resetChangeGroups(n.newNode),n=Mr(e),a++===s)return console.error("Math error: Potential infinite loop for expression: "+o+", returning no steps"),[];return r}function Mr(e){let t;e=Rn(e),e=nn(e,!0);const n=[_l,Ml,Fl,dl,Ol,Il,Al,Rl,Ll];for(let r=0;r<n.length;r++){if(t=n[r](e),e=nn(t.newNode,!0),t.hasChanged())return e=Rn(e),t.newNode=e.cloneDeep(),t;e=Rn(e)}return Sl.Status.noChange(e)}function Ho(e){return e.substeps.length>0&&e.substeps.map(Ho),e.oldNode=nn(e.oldNode,!0),e.newNode=nn(e.newNode,!0),e}function Pl(e){console.log(e.changeType),console.log($n.ascii(e.newNode)+`
`),e.substeps.length>0&&(console.log(`
substeps: `),e.substeps.forEach(t=>t))}var ko=Dl;const $l=ge,wl=ko;function vl(e,t=!1){let n;try{n=$l.parse(e)}catch{return[]}return n?wl(n,t):[]}var bl=vl;const Xo=O,Ul=cn,Fr=m;class me{constructor(t,n,r,o=[]){if(!r)throw Error("new equation isn't defined");if(t===void 0||typeof t!="string")throw Error("changetype isn't valid");this.changeType=t,this.oldEquation=n,this.newEquation=r,this.substeps=o}hasChanged(){return this.changeType!==Xo.NO_CHANGE}}me.noChange=function(e){return new me(Xo.NO_CHANGE,null,e)};me.addLeftStep=function(e,t){const n=[];t.substeps.forEach(s=>{n.push(me.addLeftStep(e,s))});let r=null;t.oldNode&&(r=e.clone(),r.leftNode=t.oldNode);const o=e.clone();return o.leftNode=t.newNode,new me(t.changeType,r,o,n)};me.addRightStep=function(e,t){const n=[];t.substeps.forEach(s=>{n.push(me.addRightStep(e,s))});let r=null;t.oldNode&&(r=e.clone(),r.rightNode=t.oldNode);const o=e.clone();return o.rightNode=t.newNode,new me(t.changeType,r,o,n)};me.resetChangeGroups=function(e){const t=Fr.Status.resetChangeGroups(e.leftNode),n=Fr.Status.resetChangeGroups(e.rightNode);return new Ul(t,n,e.comparator)};var Zo=me;const j=O,{canCrossMultiplication:xl}=Ee,rn=cn,pe=Zo,Ve=J,L=m,dt=Un,jo={">":"<",">=":"<=","<":">","<=":">=","=":"="},ut={};ut.ensureSymbolInLeftNode=function(e,t){const n=dt.getLastSymbolTerm(e.leftNode,t),r=dt.getLastSymbolTerm(e.rightNode,t);if(!n)if(r){const o=jo[e.comparator],s=e,a=new rn(e.rightNode,e.leftNode,o);return new pe(j.SWAP_SIDES,s,a)}else throw Error("No term with symbol: "+t);return pe.noChange(e)};ut.crossMultiply=function(e,t){if(!xl(e))return pe.noChange(e);const r=e.leftNode.cloneDeep(),o=e.rightNode.cloneDeep(),s=e;if(L.Type.isConstantOrConstantFraction(r.args[0])&&L.PolynomialTerm.isPolynomialTerm(r.args[1])&&L.Type.isConstantOrConstantFraction(o.args[0])&&L.Type.isConstantOrConstantFraction(o.args[1])){const a=L.Creator.operator("*",[o.args[0],r.args[1]]);r.args[1].changeGroup=1;const i=L.Creator.operator("*",[o.args[1],r.args[0]]),c=new rn(a,i,e.comparator);return new pe(j.CROSS_PRODUCT_EQUALITY,s,c)}else if(L.Type.isConstantOrConstantFraction(r.args[0])&&L.Type.isConstantOrConstantFraction(r.args[1])&&L.Type.isConstantOrConstantFraction(o.args[0])&&L.PolynomialTerm.isPolynomialTerm(o.args[1])){const a=L.Creator.operator("*",[r.args[1],o.args[0]]);o.args[0].changeGroup=1;const i=L.Creator.operator("*",[r.args[0],o.args[1]]),c=new rn(a,i,e.comparator);return new pe(j.CROSS_PRODUCT_EQUALITY,s,c)}else throw Error("No CROSS_PRODUCT_EQUALITY: "+s.ascii())};ut.removeSymbolFromDenominator=function(e,t){if(e.comparator!=="=")return pe.noChange(e);const n=e.leftNode,r=dt.getLastDenominatorWithSymbolTerm(n,t);return r?Vn(e,"*",r,j.MULTIPLY_TO_BOTH_SIDES):pe.noChange(e)};ut.removeSymbolFromRightSide=function(e,t){const n=e.rightNode;let r=dt.getLastSymbolTerm(n,t),o,s,a;if(!r)return pe.noChange(e);if(r=r.cloneDeep(),L.PolynomialTerm.isPolynomialTerm(n))Ve.isNegative(r)?(o="+",a=j.ADD_TO_BOTH_SIDES,s=Ve.negate(r)):(o="-",a=j.SUBTRACT_FROM_BOTH_SIDES,s=r);else if(L.Type.isOperator(n))if(n.op==="+")Ve.isNegative(r)?(o="+",a=j.ADD_TO_BOTH_SIDES,s=Ve.negate(r)):(o="-",a=j.SUBTRACT_FROM_BOTH_SIDES,s=r);else throw Error("Unsupported operation: "+r.op);else if(L.Type.isUnaryMinus(n))o="+",a=j.ADD_TO_BOTH_SIDES,s=r.args[0];else throw Error("Unsupported node type: "+n.type);return Vn(e,o,s,a)};ut.isolateSymbolOnLeftSide=function(e,t){let n=e.leftNode;L.Type.isParenthesis(n)&&(n=n.content);let r=dt.getLastNonSymbolTerm(n,t),o,s,a;if(!r)return pe.noChange(e);if(r=r.cloneDeep(),L.Type.isOperator(n))if(n.op==="+")Ve.isNegative(r)?(o="+",a=j.ADD_TO_BOTH_SIDES,s=Ve.negate(r)):(o="-",a=j.SUBTRACT_FROM_BOTH_SIDES,s=r);else if(n.op==="*")L.Type.isConstantFraction(r)?(o="*",a=j.MULTIPLY_BOTH_SIDES_BY_INVERSE_FRACTION,s=L.Creator.operator("/",[r.args[1],r.args[0]])):(o="/",a=j.DIVIDE_FROM_BOTH_SIDES,s=r);else if(n.op==="/")["1","-1"].indexOf(r.args[0].value)!==-1?(o="*",a=j.MULTIPLY_TO_BOTH_SIDES,s=r.args[1]):(o="*",a=j.MULTIPLY_BOTH_SIDES_BY_INVERSE_FRACTION,s=L.Creator.operator("/",[r.args[1],r.args[0]]));else{if(n.op==="^")return pe.noChange(e);throw Error("Unsupported operation: "+n.op)}else if(L.Type.isUnaryMinus(n))o="*",a=j.MULTIPLY_BOTH_SIDES_BY_NEGATIVE_ONE,s=L.Creator.constant(-1);else throw Error("Unsupported node type: "+n.type);return Vn(e,o,s,a)};function Vn(e,t,n,r){const o=e.clone(),s=n.cloneDeep(),a=n.cloneDeep(),i=Lr(e.leftNode,t,s),c=Lr(e.rightNode,t,a);let u=e.comparator;Ve.isNegative(n)&&(t==="*"||t==="/")&&(u=jo[u]);const N=new rn(i,c,u);return new pe(r,o,N)}function Lr(e,t,n){let r=L.Type.isOperator(e)?L.Creator.parenthesis(e):e;return L.Type.isOperator(e)&&e.op==="*"&&t==="/"&&(r=e),n.changeGroup=1,n=L.Type.isOperator(n)?L.Creator.parenthesis(n):n,L.Creator.operator(t,[r,n])}var Bl=ut;const Rt=O,et=Ee,on=cn,Et=Bl,re=Zo,Ar=Fe,Gl=fo,Dr=Lt,Me=m,sn=un,Pr=ko,$r=Un,Yl={"=":function(e,t){return e===t},">":function(e,t){return e>t},">=":function(e,t){return e>=t},"<":function(e,t){return e<t},"<=":function(e,t){return e<=t}};function qo(e,t,n,r=!1){let o=new on(e,t,n);if(r&&console.log(`

Solving: `+o.ascii(!1,!0)),et.hasUnsupportedNodes(o.leftNode)||et.hasUnsupportedNodes(o.rightNode))return[];const s=$r.getSymbolsInEquation(o);if(s.size===0)return vr(o,r);const a=s.values().next().value;let i,c=[];const u=o.ascii(),N=20;let T=0;if(o.leftNode=sn(o.leftNode),o.rightNode=sn(o.rightNode),et.canFindRoots(o))return c.push(wr(o)),c;do{if(c=Ko(c,o,r),c.length>0){const E=c[c.length-1];o=on.createEquationFromString(E.newEquation.ascii(!1,!0),o.comparator)}if(o.leftNode=Dr(o.leftNode),o.rightNode=Dr(o.rightNode),$r.getSymbolsInEquation(o).size===0)return vr(o,r,c);if(et.canFindRoots(o))return c.push(wr(o)),c;try{i=Hl(o,a)}catch(E){if(E.message.startsWith("No term with symbol: "))return console.error("Math error: "+E.message+", returning no steps"),[];throw E}if(i.hasChanged()){if(i.newEquation.ascii().length>300)throw Error("Math error: Potential infinite loop for equation "+u+". It reached over 300 characters  long, so returning no steps");r&&He(i),c.push(i)}if(o=re.resetChangeGroups(i.newEquation),T++===N)return console.error("Math error: Potential infinite loop for equation: "+u+", returning no steps"),[]}while(i.hasChanged());return c}function wr(e){const[t,n]=Vl(e);let r;if(t.length>1){const s=[];t.forEach(a=>a.items?s.push(...a.items):s.push(a)),r=Me.Creator.list(s)}else t.length===1?r=t[0]:r=Me.Creator.list([]);const o=new on(n,r,"=");return new re(Rt.FIND_ROOTS,e,o)}function Vl(e){const t=e.leftNode,n=[];let r,o,s;Me.Type.isOperator(t,"^")&&!et.resolvesToConstant(t)?s=[t]:s=e.leftNode.args.filter(i=>!et.resolvesToConstant(i));for(var a in s){let i=s[a],c=1;Me.Type.isOperator(i,"^")&&(c=parseFloat(i.args[1].value),i=i.args[0]);const u=Me.Type.isParenthesis(i)?i.content:i;if(o=qo(u,e.rightNode,"="),o.length===0&&Me.Type.isSymbol(u))r=u,n.push(...Array(c).fill(e.rightNode));else if(o.length!==0){const N=o.slice(-1)[0];Me.Type.isSymbol(N.newEquation.leftNode)&&(r=N.newEquation.leftNode,n.push(...Array(c).fill(N.newEquation.rightNode)))}}return[n,r]}function vr(e,t,n=[]){const r=Yl[e.comparator];if(!r)throw Error("Unexpected comparator");if(n=Ko(n,e,!0),n.length>0){const c=n[n.length-1];e=on.createEquationFromString(c.newEquation.ascii(),e.comparator)}if(e.leftNode=sn(e.leftNode),e.rightNode=sn(e.rightNode),!Me.Type.isConstantOrConstantFraction(e.leftNode,!0)||!Me.Type.isConstantOrConstantFraction(e.rightNode,!0))throw Error("Expected both nodes to be constants, instead got: "+e.ascii());const o=Ar(e.leftNode),s=Ar(e.rightNode);let a;r(o,s)?a=Rt.STATEMENT_IS_TRUE:a=Rt.STATEMENT_IS_FALSE;const i=new re(a,null,e);return t&&He(i),n.push(i),n}function Hl(e,t){const n=[Et.ensureSymbolInLeftNode,Et.crossMultiply,Et.removeSymbolFromDenominator,Et.removeSymbolFromRightSide,Et.isolateSymbolOnLeftSide];for(let r=0;r<n.length;r++){const o=n[r](e,t);if(o.hasChanged())return o}return re.noChange(e)}function Ko(e,t,n=!1){let r=t.clone();const o=Pr(t.leftNode,!1),s=o.length!==0?o.slice(-1)[0].newNode:t.leftNode,a=Gl(s,!1),i=[];for(let N=0;N<o.length;N++){const T=o[N];i.push(re.addLeftStep(t,T))}for(let N=0;N<a.length;N++){const T=a[N];i.push(re.addLeftStep(t,T))}if(i.length===1){const N=i[0];n&&He(N),e.push(N)}else if(i.length>1){const N=i[i.length-1],T=re.resetChangeGroups(N.newEquation),E=new re(Rt.SIMPLIFY_LEFT_SIDE,r,T,i);n&&He(E),e.push(E)}e.length>0&&(t=re.resetChangeGroups(e[e.length-1].newEquation)),r=t.clone();const c=Pr(t.rightNode,!1),u=[];for(let N=0;N<c.length;N++){const T=c[N];u.push(re.addRightStep(t,T))}if(u.length===1){const N=u[0];n&&He(N),e.push(N)}else if(u.length>1){const N=u[u.length-1],T=re.resetChangeGroups(N.newEquation),E=new re(Rt.SIMPLIFY_RIGHT_SIDE,r,T,u);n&&He(E),e.push(E)}return e}function He(e){console.log(`
`+e.changeType),console.log(e.newEquation.ascii()),e.substeps.length>0&&(console.log(`
 substeps: `),e.substeps.forEach(He))}var kl=qo;const br=ge,Xl=kl;function Zl(e,t=!1){const n=["<=",">=","=","<",">"];for(let r=0;r<n.length;r++){const o=n[r],s=e.split(o);if(s.length!==2)continue;let a,i;const c=s[0].trim(),u=s[1].trim();if(!c||!u)return[];try{a=br.parse(c),i=br.parse(u)}catch{return[]}if(a&&i)return Xl(a,i,o,t)}return[]}var jl=Zl;const St=O,d=J,Y=m;function ql(e){if(!Y.Type.isOperator(e))return Y.Status.noChange(e);if(e.op==="/"){const t=e.cloneDeep();let n=e.args[0],r=e.args[1];if(d.isNegative(r)&&d.isNegative(n)){r=d.negate(r),n=d.negate(n);const o=St.CANCEL_MINUSES,s=Y.Creator.operator("/",[n,r]);return Y.Status.nodeChanged(o,t,s)}else if(d.isNegative(r)&&!d.isNegative(n)){r=d.negate(r);const o=St.SIMPLIFY_SIGNS_BEFORE,s=Y.Creator.operator("/",[n,r]),a=Y.Creator.unaryMinus(s);return Y.Status.nodeChanged(o,t,a)}else if(!d.isNegative(r)&&d.isNegative(n)){n=d.negate(n);const o=St.SIMPLIFY_SIGNS_BEFORE,s=Y.Creator.operator("/",[n,r]),a=Y.Creator.unaryMinus(s);return Y.Status.nodeChanged(o,t,a)}else return Y.Status.noChange(e)}else if(e.op==="-"&&e.args.length===2&&Y.Type.isOperator(e.args[1])&&e.args[1].op==="/"){const t=e.args[1];let n=t.args[0],r=t.args[1],o="-";d.isNegative(n)&&d.isNegative(r)?(n=d.negate(n),r=d.negate(r),o="-"):d.isNegative(r)&&!d.isNegative(n)?(r=d.negate(r),o="+"):!d.isNegative(r)&&d.isNegative(n)&&(n=d.negate(n),o="+");const s=St.SIMPLIFY_SIGNS_BEFORE,a=Y.Creator.operator(o,[e.args[0],Y.Creator.operator("/",[n,r])]);return Y.Status.nodeChanged(s,e,a)}else if(e.op==="+"&&e.args.length===2&&Y.Type.isOperator(e.args[1])&&e.args[1].op==="/"){const t=e.args[1];let n=t.args[0],r=t.args[1],o="+";d.isNegative(n)&&d.isNegative(r)?(n=d.negate(n),r=d.negate(r),o="+"):d.isNegative(r)&&!d.isNegative(n)?(r=d.negate(r),o="-"):!d.isNegative(r)&&d.isNegative(n)&&(n=d.negate(n),o="-");const s=St.SIMPLIFY_SIGNS_BEFORE,a=Y.Creator.operator(o,[e.args[0],Y.Creator.operator("/",[n,r])]);return Y.Status.nodeChanged(s,e,a)}else return Y.Status.noChange(e)}var Kl=ql;const Ql=Se,Wl=un,zl=Vo,Jl=Kl,ep=To,tp=Bn,np=No,rp=Co,op=mo,sp=Eo,ap=So,ip=yo,cp=Oo,up=_o,lp=Io,pp=Ro,gp={convertMixedNumberToImproperFraction:ep,reduceMultiplicationByZero:rp,reduceZeroDividedByAnything:op,reduceExponentByZero:np,removeExponentByOne:cp,removeExponentBaseOne:ip,simplifyDoubleUnaryMinus:pp,removeAdditionOfZero:sp,removeMultiplicationByOne:lp,removeMultiplicationByNegativeOne:up,removeDivisionByOne:ap,rearrangeCoefficient:tp,removeUnnecessaryParens:Wl,simplifyFractionSigns:zl,simplifyFractionSignsBefore:Jl};var fp={SIMPLIFICATION_FUNCTIONS:gp,TreeSearch:Ql};const hp=O,Tp=Ui,Np=bl,Cp=jl,mp=ct,Ep=m,Sp=J,yp=Lt,{SIMPLIFICATION_FUNCTIONS:Op,TreeSearch:_p}=fp,Ip=cn;var f={factor:Tp,simplifyExpression:Np,solveEquation:Cp,Node:Ep,Negative:Sp,printMS:mp,flatten:yp,ChangeTypes:hp,SIMPLIFICATION_FUNCTIONS:Op,TreeSearch:_p,Equation:Ip};const D={};D.isOperator=function(e,t=null){return e.type==="OperatorNode"&&e.fn!=="unaryMinus"&&"*+-/^".includes(e.op)&&(t?e.op===t:!0)};D.isParenthesis=function(e){return e.type==="ParenthesisNode"};D.isUnaryMinus=function(e){return e.type==="OperatorNode"&&e.fn==="unaryMinus"};D.isFunction=function(e,t=null){return!(e.type!=="FunctionNode"||t&&e.fn.name!==t)};D.isSymbol=function(e,t=!1){return e.type==="SymbolNode"?!0:t&&D.isUnaryMinus(e)?D.isSymbol(e.args[0],!1):!1};D.isConstant=function(e,t=!1){return e.type==="ConstantNode"?!0:t&&D.isUnaryMinus(e)&&D.isConstant(e.args[0],!1)?parseFloat(e.args[0].value)>=0:!1};D.isConstantFraction=function(e,t=!1){return D.isOperator(e,"/")?e.args.every(n=>D.isConstant(n,t)):!1};D.isConstantOrConstantFraction=function(e,t=!1){return!!(D.isConstant(e,t)||D.isConstantFraction(e,t))};D.isIntegerFraction=function(e,t=!1){if(!D.isConstantFraction(e,t))return!1;let n=e.args[0],r=e.args[1];return t&&(D.isUnaryMinus(n)&&(n=n.args[0]),D.isUnaryMinus(r)&&(r=r.args[0])),Number.isInteger(parseFloat(n.value))&&Number.isInteger(parseFloat(r.value))};const l={changeFormatFunctionMap:{}},dp={"+":"Combine","-":"Combine","*":"Multiply","/":"Divide"},Qo={"=":"equal to",">":"greater than",">=":"greater than or equal to","<":"less than","<=":"less than or equal to"};l.formatChange=function(e){if(!(e.changeType in l.changeFormatFunctionMap))return console.error(e.changeType+" does not have a change function!"),e.changeType;const t=l.changeFormatFunctionMap[e.changeType],n=t(e);return n||`\\text{${l.ChangeText[e.changeType]}}`};function at(e){return e.filter(t=>t.changeGroup)}function A(e){if(e.oldNode)return at(e.oldNode);if(e.oldEquation){const t=at(e.oldEquation.leftNode),n=at(e.oldEquation.rightNode);return[...t,...n]}return null}function F(e){if(e.newNode)return at(e.newNode);if(e.newEquation){const t=at(e.newEquation.leftNode),n=at(e.newEquation.rightNode);return[...t,...n]}return null}function S(e,t=!1){e.forEach(r=>{r.changeGroup=void 0});let n=e.map(r=>r.toTex());return t||(n=[...new Set(n)]),n.length===0?"":n.length===1?n[0]:`${n.slice(0,-1).join(", ")} \\text{ and } ${n.slice(-1)}`}l.changeFormatFunctionMap[f.ChangeTypes.ABSOLUTE_VALUE]=function(e){const t=A(e);if(t.length!==1)return null;const n=t[0];return D.isFunction(n,"abs")?`\\text{Take the absolute value of } ${n.args[0].toTex()}`:null};l.changeFormatFunctionMap[f.ChangeTypes.ADD_COEFFICIENT_OF_ONE]=function(e){const t=A(e),n=F(e);if(t.length===0||n.length!==t.length)return null;const r=S(t),o=S(n);return`\\text{Rewrite } ${r} \\text{ as } ${o}`};l.changeFormatFunctionMap[f.ChangeTypes.ADD_EXPONENT_OF_ONE]=function(e){const t=A(e),n=F(e);if(t.length===0||n.length!==t.length)return null;const r=S(t),o=S(n);return`\\text{Rewrite } ${r} \\text{ as } ${o}`};l.changeFormatFunctionMap[f.ChangeTypes.ADD_FRACTIONS]=function(e){const t=A(e),n=F(e);if(t.length!==1||n.length!==1)return null;const r=t[0];if(!D.isOperator(r)||r.op!=="+"||r.args.length>3)return null;const o=S(r.args,!0),s=n[0].toTex();return`\\text{Add } ${o} \\text{ to get } ${s}`};l.changeFormatFunctionMap[f.ChangeTypes.ADD_NUMERATORS]=function(e){return`\\text{${l.ChangeText[e.changeType]}}`};l.changeFormatFunctionMap[f.ChangeTypes.ADD_POLYNOMIAL_TERMS]=function(e){const t=A(e),n=F(e);if(t.length!==1||n.length!==1)return null;const r=t[0];if(!D.isOperator(r)||r.op!=="+")return null;const o=S(r.args,!0),s=n[0].toTex();return`\\text{Add } ${o} \\text{ to get } ${s}`};l.changeFormatFunctionMap[f.ChangeTypes.ADD_TO_BOTH_SIDES]=function(e){const t=F(e);return t.length!==2?null:`\\text{Add } ${t[0].toTex()} \\text{ to both sides}`};l.changeFormatFunctionMap[f.ChangeTypes.BREAK_UP_FRACTION]=function(e){const t=A(e);return t.length!==1?null:`\\text{Break up the fraction } ${S(t)}`};l.changeFormatFunctionMap[f.ChangeTypes.CANCEL_EXPONENT]=function(e){return`\\text{${l.ChangeText[e.changeType]}}`};l.changeFormatFunctionMap[f.ChangeTypes.CANCEL_EXPONENT_AND_ROOT]=function(e){return`\\text{${l.ChangeText[e.changeType]}}`};l.changeFormatFunctionMap[f.ChangeTypes.CANCEL_MINUSES]=function(e){return`\\text{${l.ChangeText[e.changeType]}}`};l.changeFormatFunctionMap[f.ChangeTypes.CANCEL_ROOT]=function(e){return`\\text{${l.ChangeText[e.changeType]}}`};l.changeFormatFunctionMap[f.ChangeTypes.CANCEL_TERMS]=function(e){const t=A(e);return t.length!==1?null:`\\text{Cancel } ${S(t)} \\text{ from the numerator and denominator}`};l.changeFormatFunctionMap[f.ChangeTypes.COLLECT_AND_COMBINE_LIKE_TERMS]=function(e){return`\\text{${l.ChangeText[e.changeType]}}`};l.changeFormatFunctionMap[f.ChangeTypes.COLLECT_EXPONENTS]=function(e){return`\\text{${l.ChangeText[e.changeType]}}`};l.changeFormatFunctionMap[f.ChangeTypes.COLLECT_LIKE_TERMS]=function(e){return`\\text{${l.ChangeText[e.changeType]}}`};l.changeFormatFunctionMap[f.ChangeTypes.COMBINE_NUMERATORS]=function(e){return`\\text{${l.ChangeText[e.changeType]}}`};l.changeFormatFunctionMap[f.ChangeTypes.COMBINE_UNDER_ROOT]=function(e){return`\\text{${l.ChangeText[e.changeType]}}`};l.changeFormatFunctionMap[f.ChangeTypes.COMMON_DENOMINATOR]=function(e){return`\\text{${l.ChangeText[e.changeType]}}`};l.changeFormatFunctionMap[f.ChangeTypes.CONVERT_INTEGER_TO_FRACTION]=function(e){const t=A(e),n=F(e);if(t.length!==1||n.length!==1)return null;const r=S(t),o=S(n);return`\\text{Change } ${r} \\text{ to } ${o} \\text{ so that it has a shared denominator}`};l.changeFormatFunctionMap[f.ChangeTypes.CONVERT_MULTIPLICATION_TO_EXPONENT]=function(e){const t=A(e),n=F(e);if(t.length!==1||n.length!==1)return null;const r=S(t),o=S(n);return`\\text{Rewrite } ${r} \\text{ as } ${o}`};l.changeFormatFunctionMap[f.ChangeTypes.DISTRIBUTE]=function(e){return`\\text{${l.ChangeText[e.changeType]}}`};l.changeFormatFunctionMap[f.ChangeTypes.DISTRIBUTE_NEGATIVE_ONE]=function(e){return`\\text{${l.ChangeText[e.changeType]}}`};l.changeFormatFunctionMap[f.ChangeTypes.DISTRIBUTE_NTH_ROOT]=function(e){return`\\text{${l.ChangeText[e.changeType]}}`};l.changeFormatFunctionMap[f.ChangeTypes.DIVIDE_FRACTION_FOR_ADDITION]=function(e){const t=A(e),n=F(e);if(t.length!==1||n.length!==1)return null;const r=S(t),o=S(n);return`\\text{Divide } ${r} \\text{ so it's in the decimal form } ${o}`};l.changeFormatFunctionMap[f.ChangeTypes.DIVIDE_FROM_BOTH_SIDES]=function(e){const t=F(e);return t.length!==2?null:`\\text{Divide both sides by } ${t[0].toTex()}`};l.changeFormatFunctionMap[f.ChangeTypes.DIVISION_BY_NEGATIVE_ONE]=function(e){const t=A(e),n=F(e);if(t.length!==1||n.length!==1)return null;const r=S(t),o=S(n);return`${r} \\text{ divided by -1 is } ${o}`};l.changeFormatFunctionMap[f.ChangeTypes.DIVISION_BY_ONE]=function(e){const t=A(e),n=F(e);if(t.length!==1||n.length!==1)return null;const r=S(t),o=S(n);return`${r} \\text{ divided by 1 is } ${o}`};l.changeFormatFunctionMap[f.ChangeTypes.EVALUATE_DISTRIBUTED_NTH_ROOT]=function(e){return`\\text{${l.ChangeText[e.changeType]}}`};l.changeFormatFunctionMap[f.ChangeTypes.FACTOR_INTO_PRIMES]=function(e){const t=A(e),n=F(e);if(t.length!==1||n.length<t.length||n.length>5)return null;const r=S(t),o=S(n);return`\\text{Factor } ${r} \\text{ into its prime factors: } ${o}`};l.changeFormatFunctionMap[f.ChangeTypes.GROUP_COEFFICIENTS]=function(e){return`\\text{${l.ChangeText[e.changeType]}}`};l.changeFormatFunctionMap[f.ChangeTypes.GROUP_TERMS_BY_ROOT]=function(e){return`\\text{${l.ChangeText[e.changeType]}}`};l.changeFormatFunctionMap[f.ChangeTypes.MULTIPLY_BOTH_SIDES_BY_INVERSE_FRACTION]=function(e){const t=F(e);return t.length!==2?null:`\\text{Multiply both sides by the inverse } ${t[0].toTex()}`};l.changeFormatFunctionMap[f.ChangeTypes.MULTIPLY_BOTH_SIDES_BY_NEGATIVE_ONE]=function(e){return`\\text{${l.ChangeText[e.changeType]}}`};l.changeFormatFunctionMap[f.ChangeTypes.MULTIPLY_BY_INVERSE]=function(e){const t=A(e),n=F(e);if(t.length!==1||n.length!==1)return null;const r=S(t,!0),o=S(n);return`\\text{Rewrite } ${r} \\text{ as } ${o}`};l.changeFormatFunctionMap[f.ChangeTypes.MULTIPLY_BY_ZERO]=function(e){const t=A(e),n=F(e);if(t.length!==1||n.length!==1)return null;const r=S(t),o=S(n);return`\\text{Rewrite } ${r} \\text{ as } ${o}`};l.changeFormatFunctionMap[f.ChangeTypes.MULTIPLY_COEFFICIENTS]=function(e){const t=A(e),n=F(e);if(t.length!==1||n.length!==1)return null;const r=t[0];if(!D.isOperator(r)||r.op!=="*")return null;const o=S(t,!0),s=n[0].toTex();return`\\text{Multiply the coefficients } ${o} \\text{ to get } ${s}`};l.changeFormatFunctionMap[f.ChangeTypes.MULTIPLY_DENOMINATORS]=function(e){return`\\text{${l.ChangeText[e.changeType]}}`};l.changeFormatFunctionMap[f.ChangeTypes.MULTIPLY_FRACTIONS]=function(e){const t=A(e),n=F(e);if(t.length!==1||n.length!==1)return null;const r=t[0];if(!D.isOperator(r)||r.op!=="*")return null;const o=S(r.args,!0),s=n[0].toTex();return`\\text{Multiply } ${o} \\text{ to get } ${s}`};l.changeFormatFunctionMap[f.ChangeTypes.MULTIPLY_NUMERATORS]=function(e){return`\\text{${l.ChangeText[e.changeType]}}`};l.changeFormatFunctionMap[f.ChangeTypes.MULTIPLY_POLYNOMIAL_TERMS]=function(e){const t=A(e),n=F(e);if(t.length!==1||n.length!==1)return null;const r=t[0];if(!D.isOperator(r)||r.op!=="*")return null;const o=S(r.args,!0),s=n[0].toTex();return`\\text{Multiply } ${o} \\text{ to get } ${s}`};l.changeFormatFunctionMap[f.ChangeTypes.MULTIPLY_TO_BOTH_SIDES]=function(e){const t=F(e);return t.length!==2?null:`\\text{Multiply both sides by } ${t[0].toTex()}`};l.changeFormatFunctionMap[f.ChangeTypes.NO_CHANGE]=function(){return null};l.changeFormatFunctionMap[f.ChangeTypes.NTH_ROOT_VALUE]=function(e){const t=A(e);return t.length!==1?null:`\\text{Take the root of } ${S(t)}`};l.changeFormatFunctionMap[f.ChangeTypes.REARRANGE_COEFF]=function(e){return`\\text{${l.ChangeText[e.changeType]}}`};l.changeFormatFunctionMap[f.ChangeTypes.REDUCE_EXPONENT_BY_ZERO]=function(e){const t=A(e),n=F(e);if(t.length!==1||n.length!==1)return null;const r=S(t),o=S(n);return`\\text{Rewrite } ${r} \\text{ as } ${o}`};l.changeFormatFunctionMap[f.ChangeTypes.REDUCE_ZERO_NUMERATOR]=function(e){const t=A(e),n=F(e);if(t.length!==1||n.length!==1)return null;const r=S(t),o=S(n);return`\\text{Rewrite } ${r} \\text{ as } ${o}`};l.changeFormatFunctionMap[f.ChangeTypes.REMOVE_ADDING_ZERO]=function(e){return`\\text{${l.ChangeText[e.changeType]}}`};l.changeFormatFunctionMap[f.ChangeTypes.REMOVE_EXPONENT_BY_ONE]=function(e){const t=A(e),n=F(e);if(t.length!==1||n.length!==1)return null;const r=S(t),o=S(n);return`\\text{Rewrite } ${r} \\text{ as } ${o}`};l.changeFormatFunctionMap[f.ChangeTypes.REMOVE_MULTIPLYING_BY_NEGATIVE_ONE]=function(e){const t=A(e),n=F(e);if(t.length!==1||n.length!==1)return null;const r=S(t),o=S(n);return`\\text{Rewrite } ${r} \\text{ as } ${o}`};l.changeFormatFunctionMap[f.ChangeTypes.REMOVE_MULTIPLYING_BY_ONE]=function(e){const t=A(e),n=F(e);if(t.length!==1||n.length!==1)return null;const r=S(t),o=S(n);return`\\text{Rewrite } ${r} \\text{ as } ${o}`};l.changeFormatFunctionMap[f.ChangeTypes.RESOLVE_DOUBLE_MINUS]=function(e){return`\\text{${l.ChangeText[e.changeType]}}`};l.changeFormatFunctionMap[f.ChangeTypes.SIMPLIFY_ARITHMETIC]=function(e){const t=A(e),n=F(e);if(t.length!==1||n.length!==1)return null;const r=t[0];if(!D.isOperator(r)||"+-*/^".indexOf(r.op)===-1)return null;const o=S(r.args,!0),s=n[0].toTex();return`\\text{${dp[r.op]} } ${o} \\text{ to get } ${s}`};l.changeFormatFunctionMap[f.ChangeTypes.SIMPLIFY_DIVISION]=function(e){const t=A(e),n=F(e);if(t.length!==1||n.length!==1)return null;const r=S(t),o=S(n);return`\\text{Rewrite } ${r} \\text{ as } ${o}`};l.changeFormatFunctionMap[f.ChangeTypes.SIMPLIFY_FRACTION]=function(e){const t=A(e),n=F(e);if(t.length!==1||n.length!==1)return null;const r=S(t),o=S(n);return`\\text{Simplify } ${r} \\text{ to } ${o}`};l.changeFormatFunctionMap[f.ChangeTypes.SIMPLIFY_LEFT_SIDE]=function(e){return`\\text{${l.ChangeText[e.changeType]}}`};l.changeFormatFunctionMap[f.ChangeTypes.SIMPLIFY_RIGHT_SIDE]=function(e){return`\\text{${l.ChangeText[e.changeType]}}`};l.changeFormatFunctionMap[f.ChangeTypes.SIMPLIFY_SIGNS]=function(e){return`\\text{${l.ChangeText[e.changeType]}}`};l.changeFormatFunctionMap[f.ChangeTypes.SIMPLIFY_TERMS]=function(e){return`\\text{${l.ChangeText[e.changeType]}}`};l.changeFormatFunctionMap[f.ChangeTypes.STATEMENT_IS_FALSE]=function(e){const t=e.newEquation.comparator;return`\\text{The left side is not ${Qo[t]} the right side}`};l.changeFormatFunctionMap[f.ChangeTypes.STATEMENT_IS_TRUE]=function(e){const t=e.newEquation.comparator;return`\\text{The left side is ${Qo[t]} the right side}`};l.changeFormatFunctionMap[f.ChangeTypes.SUBTRACT_FROM_BOTH_SIDES]=function(e){const t=F(e);return t.length!==2?null:`\\text{Subtract } ${t[0].toTex()} \\text{ from both sides}`};l.changeFormatFunctionMap[f.ChangeTypes.SWAP_SIDES]=function(e){return`\\text{${l.ChangeText[e.changeType]}}`};l.changeFormatFunctionMap[f.ChangeTypes.UNARY_MINUS_TO_NEGATIVE_ONE]=function(e){const t=A(e),n=F(e);if(t.length===0||n.length!==t.length)return null;const r=S(t),o=S(n);return`\\text{Rewrite } ${r} \\text{ as } ${o}`};l.ChangeText={ABSOLUTE_VALUE:"Take the absolute value",ADD_COEFFICIENT_OF_ONE:"Rewrite term to have a coefficient of 1",ADD_EXPONENT_OF_ONE:"Rewrite term to have an exponent of 1",ADD_FRACTIONS:"Add the fractions together",ADD_NUMERATORS:"Add the terms in the numerator",ADD_POLYNOMIAL_TERMS:"Add the polynomial terms together",ADD_TO_BOTH_SIDES:"Add the term to both sides",BREAK_UP_FRACTION:"Break up the fraction",CANCEL_EXPONENT:"Cancel the exponent",CANCEL_EXPONENT_AND_ROOT:"Cancel the exponent and the root",CANCEL_MINUSES:"Cancel the negatives in the numerator and denominator",CANCEL_ROOT:"Cancel the root",CANCEL_TERMS:"Cancel like terms in the numerator and denominator",COLLECT_AND_COMBINE_LIKE_TERMS:"Collect and combine like terms",COLLECT_EXPONENTS:"Collect the exponents",COLLECT_LIKE_TERMS:"Identify the like terms and group them together",COMBINE_NUMERATORS:"Combine the numerators with a shared denominator",COMMON_DENOMINATOR:"Multiply the terms so they share a common denominator",COMBINE_UNDER_ROOT:"Combine terms with the same root",CONVERT_INTEGER_TO_FRACTION:"Change the number to a fraction with the same denominator",CONVERT_MULTIPLICATION_TO_EXPONENT:"Change repeatedly multiplying a term to an exponent",DISTRIBUTE:"Distribute into the parentheses",DISTRIBUTE_NEGATIVE_ONE:"Distribute -1 into the parentheses",DISTRIBUTE_NTH_ROOT:"Distribute the root into each term",DIVIDE_FRACTION_FOR_ADDITION:"Divide any fractions to convert it to decimal form",DIVIDE_FROM_BOTH_SIDES:"Divide the term from both sides",DIVISION_BY_NEGATIVE_ONE:"Rewrite any term divided by -1 as the negative of the term",DIVISION_BY_ONE:"Rewrite any term divided by 1 as just the term",EVALUATE_DISTRIBUTED_NTH_ROOT:"Take the root of all the terms",FACTOR_INTO_PRIMES:"Factor the number into its prime factors",GROUP_COEFFICIENTS:"Group the coefficients together",GROUP_TERMS_BY_ROOT:"Group repeating factors",MULTIPLY_BOTH_SIDES_BY_INVERSE_FRACTION:"Multiply both sides by the inverse of the fraction",MULTIPLY_BOTH_SIDES_BY_NEGATIVE_ONE:"Multiply both sides by -1",MULTIPLY_BY_INVERSE:"Rewrite division as multiplication by the inverse",MULTIPLY_BY_ZERO:"Rewrite any term multiplied by 0 as 0",MULTIPLY_COEFFICIENTS:"Multiply the coefficients together",MULTIPLY_DENOMINATORS:"Multiply the terms in the denominators",MULTIPLY_FRACTIONS:"Multiply the fractions together",MULTIPLY_NUMERATORS:"Multiply the terms in the numerators",MULTIPLY_POLYNOMIAL_TERMS:"Multiply the polynomial terms together",MULTIPLY_TO_BOTH_SIDES:"Multiply the term to both sides",NTH_ROOT_VALUE:"Take the root of the number",NO_CHANGE:"No change",REARRANGE_COEFF:"Move the coefficient to the front of the term",REDUCE_ZERO_NUMERATOR:"Rewrite zero divided by anything as zero",REMOVE_EXPONENT_BY_ONE:"Rewrite any term to the power of 1 as itself",REDUCE_EXPONENT_BY_ZERO:"Rewrite any term to the power of 0 as 1",REMOVE_ADDING_ZERO:"Remove zero when adding",REMOVE_MULTIPLYING_BY_NEGATIVE_ONE:"Rewrite any term multiplied by -1 as the negative of the term",REMOVE_MULTIPLYING_BY_ONE:"Rewrite any term multiplied 1 as just the term",RESOLVE_DOUBLE_MINUS:"Change subtracting a negative to addition",SIMPLIFY_ARITHMETIC:"Evaluate the arithmetic",SIMPLIFY_DIVISION:"Rewrite the chain of division",SIMPLIFY_FRACTION:"Simplify by dividing the top and bottom by the greatest common denominator",SIMPLIFY_LEFT_SIDE:"Simplify the left hand side",SIMPLIFY_RIGHT_SIDE:"Simplify the right hand side",SIMPLIFY_SIGNS:"Move the negative sign to the numerator",SIMPLIFY_TERMS:"Simplify after distributing",STATEMENT_IS_FALSE:"The statement is False",STATEMENT_IS_TRUE:"The statement is True",SUBTRACT_FROM_BOTH_SIDES:"Subtract the term from both sides",SWAP_SIDES:"Swap sides",UNARY_MINUS_TO_NEGATIVE_ONE:"Rewrite minus as a coefficient of -1"};const Rp={},$=ns({fractionDependencies:ms,lcmDependencies:Cs,gcdDependencies:Ns,nthRootDependencies:Ts,NodeDependencies:hs,formatDependencies:fs,parseDependencies:gs,evaluateDependencies:ps,simplifyDependencies:ls,randomDependencies:us,pickRandomDependencies:cs,smallerDependencies:is,largerDependencies:as,smallerEqDependencies:ss,largerEqDependencies:os,randomIntDependencies:rs},Rp);function Wo(e,t){let n=$.parse(e);return n=n.transform(r=>{if(r.type==="SymbolNode"){const o=r.name,s=t[o];if(s!==void 0)return new $.ConstantNode(Number(s))}return r}),n?.toString({parenthesis:"keep"})}function Je(e,t={suppr1:!0,suppr0:!0,supprPlusMoins:!0,variables:void 0,removeImplicit:!0,rearrangeCoefficient:!0,removeMultiplicationByNegativeOne:!0}){t=Object.assign({suppr1:!0,suppr0:!0,supprPlusMoins:!0},t);let n,r=[];const o=["=","<",">","<=",">="];if(typeof e=="string"){for(let b=0;b<o.length;b++)r=e.split(o[b]),r.length>1&&(n=o[b]);if(n!==void 0&&(r=e.split(n),r.length>1)){const b=[];for(let ye=0;ye<r.length;ye++)b.push(Je(r[ye],t));return b.join(n?.replaceAll(">=","\\geqslant").replaceAll("<=","\\leqslant"))}}let s;typeof e=="string"?s=$.parse(e):s=e.cloneDeep(),t.variables&&(s=$.parse(Wo(f.printMS.ascii(s,!1,!0),t.variables)));function a(b){const ye=f.SIMPLIFICATION_FUNCTIONS.removeAdditionOfZero,fn=f.SIMPLIFICATION_FUNCTIONS.removeMultiplicationByOne,lt=f.SIMPLIFICATION_FUNCTIONS.reduceMultiplicationByZero,pt=f.SIMPLIFICATION_FUNCTIONS.removeDivisionByOne,hn=f.SIMPLIFICATION_FUNCTIONS.rearrangeCoefficient,Tn=f.SIMPLIFICATION_FUNCTIONS.reduceZeroDividedByAnything,Pt=f.SIMPLIFICATION_FUNCTIONS.removeExponentByOne,$t=f.SIMPLIFICATION_FUNCTIONS.removeExponentBaseOne,Nn=f.SIMPLIFICATION_FUNCTIONS.reduceExponentByZero,wt=f.SIMPLIFICATION_FUNCTIONS.removeMultiplicationByNegativeOne,Ue=[ye,fn,pt,t.rearrangeCoefficient?hn:null,Tn,Pt,$t,Nn,t.removeMultiplicationByNegativeOne?wt:null,lt];for(let qe=0;qe<Ue.length;qe++){if(Ue[qe]===null)continue;const gt=Ue[qe](b);if(gt.hasChanged())return gt;b=gt.newNode}return f.Node.Status.noChange(b)}const i=f.TreeSearch.preOrder(a);let c,u=0;const N=20;do{c=s.cloneDeep();const b=i(s);if(b.changeType!=="NO_CHANGE"&&(s=b.newNode),s=f.SIMPLIFICATION_FUNCTIONS.removeUnnecessaryParens(s,!0),u++,u++===N){console.error("Math error: Potential infinite loop for toTex: "+e.toString()+", returning no steps");break}}while(s.toString()!==c.toString());const T=!1,E=t.removeImplicit===!1||!1;return f.printMS.latex(s,T,E,!0,!0,[]).replaceAll("\\mathrm","").replaceAll("\\times \\dfrac",`${E?"\\times \\dfrac":"\\dfrac"}`).replace("undefined","")}function Mp(e="(a*x+b)*(c*x-d)",t={a:1,b:2,c:3,d:-6}){const n=Object.assign({},Fp(t));for(const[r,o]of Object.entries(n))typeof o!="number"&&(n[r]=o.valueOf());return Wo(e,n)}function Fp(e={a:!0,b:!0,c:!0,d:!0},t={valueOf:!0,format:!1,type:"number"}){$.config({randomSeed:Es.graine});const n={};let r=0,o=!0;do{r++;for(const s of Object.keys(e))switch(typeof e[s]){case"object":break;case"boolean":const a=e[s]?1:0,i=Ss([-1,1]),c=ys(1,10),u=(a===0?1:i)*c;n[s]=$.fraction(u);break;case"number":t.type==="decimal"?n[s]=$.bignumber(String(e[s])):n[s]=$.fraction(Number(e[s]));break;case"string":try{t.type==="decimal"?($.config({number:"BigNumber"}),n[s]=$.evaluate(String(e[s]),n),$.config({number:"number"})):t.type==="fraction"?($.config({number:"Fraction"}),n[s]=$.evaluate(String(e[s]),n),$.config({number:"number"})):n[s]=$.evaluate(String(e[s]),n)}catch{try{t.type==="decimal"?n[s]=$.bignumber($.evaluate(String(e[s]),n)):n[s]=$.fraction($.evaluate(String(e[s]),n))}catch{const N=Object.assign({},n);for(const T of Object.keys(N))N[T]=N[T]?.valueOf();t.type==="decimal"?($.config({number:"BigNumber"}),n[s]=$.evaluate(String(e[s]),N),$.config({number:"number"})):n[s]=$.evaluate(String(e[s]),N)}}break}e.test!==void 0&&(o=$.evaluate(String(e.test),n))}while(!o&&r<1e3);if(r===1e3&&window.notify(`Attention ! 1000 essais dépassés.
 Trop de contraintes.
 Le résultat ne vérifiera pas le test.`,{test:e.test}),t.valueOf)for(const s of Object.keys(n))typeof n[s]!="number"&&(n[s]instanceof es||(n[s]=n[s]?.valueOf()));if(t.format)for(const s of Object.keys(n))n[s]=Os(Number(n[s]));return n}function Zt(e,t=[],n=[]){return e.forEach(function(r){t.length===0?r.substeps.length===0?n.push(r):Zt(r.substeps,t,n):t.some(o=>r.substeps.some(s=>s.changeType===o))||t.some(o=>r.changeType===o)&&r.substeps.length>0?Zt(r.substeps,t,n):n.push(r)}),n}function Up(e,t){t=Object.assign({comment:!1,comments:{},substeps:!1,mixed:!1,name:void 0,suppr1:!0,removeImplicit:!0},t),t.variables!==void 0&&(e=Mp(e,t.variables));const n=Je(e,t),r=t.substeps?Zt(f.simplifyExpression(e)):f.simplifyExpression(e),o=[],s=[];if(r.forEach(function(c,u){const N=c.oldNode!==null?Je(c.oldNode,t):"",T=Je(c.newNode,t);if(T===N&&o.pop(),t.comment){const E=Lp(c,t.comments);s.push(E),o.length===0||u===r.length-1?t.name===void 0?o.push(`${n}&=${T}&&${E}`):o.length===0?(o.push(`${t.name}&=${n}&&${E}`),o.push(`&=${T}&&${E}`)):o.push(`${t.name}&=${T}&&${E}`):o.push(`&=${T}&&${E}`)}else o.length===0||u===r.length-1?t.name===void 0?o.push(`${n}&=${T}`):o.length===0?(o.push(`${t.name}&=${n}`),o.push(`&=${T}`)):o.push(`${t.name}&=${T}`):o.push(`&=${T}`)}),t.mixed===!0&&r[r.length-1].newNode.type==="OperatorNode"&&r[r.length-1].newNode.op==="/"&&r[r.length-1].newNode.args[0].type==="ConstantNode"&&r[r.length-1].newNode.args[1].type==="ConstantNode"&&(Math.abs(r[r.length-1].newNode.args[0].value)>r[r.length-1].newNode.args[1].value||r[r.length-1].newNode.args[0].value<0)){const c=r[r.length-1].newNode.args[0].value<0?"-":"+";o.push("&="+Je($.parse($.fraction(r[r.length-1].newNode.args[0].value,r[r.length-1].newNode.args[1].value).toFraction(!0).replace(" ",c)),t))}const a=`Calculer $${n}$.`,i=`$\\begin{aligned}
${o.join(`\\\\
`)}
\\end{aligned}$`;return{result:r.length>0?r[r.length-1].newNode.toString():n,printResult:r.length>0?Je(r[r.length-1].newNode,t.totex):n,netapes:o.length,texteDebug:a+i,texte:a,texteCorr:i,stepsLatex:o,steps:r,commentaires:s,printExpression:n,name:t.name}}function Lp(e,t){const n=e.changeType,r=e.stepChange,o={CROSS_PRODUCT_EQUALITY:`Egalité des produits en croix si $${r} \\neq 0$.`,MULTIPLY_BOTH_SIDES_BY_NEGATIVE_ONE:"Multiplier les deux membres par $-1$.",SUBTRACT_FROM_BOTH_SIDES:`Soustraire $${r}$ à chaque membre.`,ADD_TO_BOTH_SIDES:`Ajouter $${r}$ à chaque membre`,MULTIPLY_TO_BOTH_SIDES:`Multiplier chaque membre par $${r}$.`,DIVIDE_FROM_BOTH_SIDES:`Diviser chaque membre par $${r}$.`,MULTIPLY_BOTH_SIDES_BY_INVERSE_FRACTION:`Multiplier chaque membre par $${r}$.`,SWAP_SIDES:"Echanger les deux membres.",STATEMENT_IS_FALSE:"L'égalité est fausse.",STATEMENT_IS_TRUE:"L'égalité est vraie.",DISTRIBUTE:"Distribution.",SIMPLIFY_RIGHT_SIDE:"Simplifier le membre de droite.",SIMPLIFY_LEFT_SIDE:"Simplifier le membre de gauche.",COLLECT_AND_COMBINE_LIKE_TERMS:"Regrouper et réduire les termes de même nature.",SIMPLIFY_ARITHMETIC:"Calcul arithmétique.",SIMPLIFY_FRACTION:"Simplifier une fraction.",REMOVE_MULTIPLYING_BY_NEGATIVE_ONE:"Calculer la multiplication par $-1$.",REMOVE_ADDING_ZERO:"Enlever des zéros.",CANCEL_MINUSES:"Annuler les signes moins.",FIND_ROOTS:"Trouver la (ou les) solution(s).",SIMPLIFY_SIGNS:"Simplifier le signe.",MULTIPLY_BY_ZERO:"Multiplication par zéro.",ADD_FRACTIONS:"Additionner des fractions.",BREAK_UP_FRACTION:"Séparer une fraction.",CANCEL_TERMS:"Annuler les termes.",REMOVE_MULTIPLYING_BY_ONE:"Retirer la multiplication par $1$.",COLLECT_LIKE_TERMS:"Regrouper les termes.",MULTIPLY_DENOMINATORS:"Calculer les dénominateurs.",ADD_EXPONENT_OF_ONE:"Ajouter l'exposant 1.",COLLECT_POLYNOMIAL_EXPONENTS:"Ajouter l'exposant 1.",COMMON_DENOMINATOR:"Obtenir le même dénominateur.",MULTIPLY_NUMERATORS:"Calculer.",COMBINE_NUMERATORS:"Combiner les numérateurs.",ADD_NUMERATORS:"Additionner les numérateurs.",ADD_COEFFICIENT_OF_ONE:"Ajouter le coefficient $1$",GROUP_COEFFICIENTS:"Regrouper les coefficients.",FIND_GCD:"Trouver le plus grand diviseur commun.",CANCEL_GCD:"Simplifier par le PGCD.",MULTIPLY_FRACTIONS:"Multiplier deux fractions."};return t=Object.assign(o,t),t[n]!==void 0?`\\text{${t[n].replaceAll("{stepChange}",`$${r}$`)}}`:""}export{Wo as a,Fp as b,Up as c,Je as t};
