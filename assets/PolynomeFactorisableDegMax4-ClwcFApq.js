import{E as y}from"./EquationSecondDegre-Dejvrn5a.js";import{as as v,F as t,r as f,v as b,f as E}from"./embellissements-BYV7mIDn.js";import{M as m}from"./MonomePlusieursVariables-DHq3iA-O.js";import{P as x}from"./PolynomePlusieursVariables-DEsXl1Ev.js";class g{racinesRationnelles;facteurSansRacineRationnelle;coeffDominant;polynome;coefficients;polynomeEquivEntier;ppcm;constructor(o,n,r=new x([new m(new t(1,1),{variables:["x"],exposants:[0]})])){this.racinesRationnelles=o,this.coeffDominant=n,this.facteurSansRacineRationnelle=r,this.polynome=g.creerPolynome(o,n).produit(r).reduire(),this.coefficients=this.polynome.reduire().termes(),this.ppcm=v(this.coefficients.map(a=>a.simplifie().den)),this.polynomeEquivEntier=g.creerPolynome(o,n.multiplieEntier(this.ppcm)).produit(r).reduire()}static creerPolynome(o,n){return x.createPolynomeFromRoots(o,n)}static creerPolynomeAleatoire(o,n,r,a,c,s=1){if(o<3||o>4)throw new Error("Le degré doit être entre 1 et 4.");let e=0,u=0,l=0,w=new x([new m(new t(1,1),{variables:["x"],exposants:[0]})]);(!a||n==="reelles")&&(e+=2);const p=[];let R=new t(1,1);for(;e<o;){let i;if(i=new t(0,1),(n==="rationnelles"||n==="reelles")&&u<1){u++;let h,d;do h=f(-5,5,[-4,4,0]),d=f(1,5,[4,0]),i=new t(h,d).simplifie();while(i.simplifie().den===1)}else i=new t(f(-7,7,[0]),1);p.filter(h=>h.simplifie().isEqual(i.simplifie())).length<c&&(p.push(i.simplifie()),l<s&&(p.push(i.simplifie()),l++,e++),e++)}if(r==="entier"){const i=p.map(h=>h.den);let S=v(i);S===1&&(S=f(-3,3,[0])),R=new t(S,1)}else R=new t(f(1,5,[0]),f(1,5,[0])).simplifie();if(!a){const i=f(-1,1);w=new x([new m(new t(1,1),{variables:["x"],exposants:[2]}),new m(new t(i,1),{variables:["x"],exposants:[1]}),new m(new t(f(0+Math.abs(i),2-Math.abs(i),[0]),1),{variables:["x"],exposants:[0]})])}if(n==="reelles"&&a){const i=f(-2,-1);w=new x([new m(new t(1,1),{variables:["x"],exposants:[2]}),new m(-f(2,2,[0]),{variables:["x"],exposants:[1]}),new m(new t(i,1),{variables:["x"],exposants:[0]})])}return new g(p,R,w)}toLatex(o=!1){if(!o)return this.polynome.toString();const n=new Map;for(const s of this.racinesRationnelles){const e=s instanceof t?s.toLatex():s.toString();n.has(e)?n.get(e).count++:n.set(e,{root:s,count:1})}const r=b(this.coeffDominant),a=[];for(const{root:s,count:e}of n.values()){const l=`\\left(x${E(s instanceof t?s.oppose():-s)}\\right)`;e===1?a.push(l):a.push(`${l}^{${e}}`)}let c=r+a.join("");return!o&&this.facteurSansRacineRationnelle.toString()!=="1"?c+=c+this.facteurSansRacineRationnelle.toString():o&&this.facteurSansRacineRationnelle.toString()!=="1"&&(c+=y.aPartirDuPolynome(this.facteurSansRacineRationnelle).printToLatexFormeFactorisee()),c||"0"}toLatexFactoriseSubstitue(o){const n=o instanceof t?o:new t(o,1),r=new Map;for(const e of this.racinesRationnelles){const u=e instanceof t?e:new t(e,1),l=u.toLatex();r.has(l)?r.get(l).count++:r.set(l,{root:u,count:1})}const a=b(this.coeffDominant),c=[];for(const{root:e,count:u}of r.values()){const l=n.texFractionSimplifiee,w=E(e.oppose()),p=`\\left(${l}${w}\\right)`;u===1?c.push(p):c.push(`${p}^{${u}}`)}let s=a+c.join("");if(this.facteurSansRacineRationnelle.toString()!=="1"){const e=this.facteurSansRacineRationnelle.evaluer({x:n});s+=`\\left(${e.texFractionSimplifiee}\\right)`}return s||"0"}}export{g as P};
