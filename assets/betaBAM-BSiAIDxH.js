import{p as v,cS as y,G as D,k as w,A as J,I as K,T as W,j as q,e as x,o as X,D as Y,r as P,t as Z}from"./embellissements-BYV7mIDn.js";import{E as S}from"./Exercice-DtXhjCyI.js";import"mathjs";import"decimal.js";import"katex";import"earcut";import"roughjs";import"./exerciseMethods-CtbYPwln.js";import"./index-BUDQz6-w.js";import"crypto-js";import"seedrandom";class l{serie;constructor(t){if(t.length===0)throw new Error("La série ne peut pas être vide");if(typeof t[0]=="number")this.serie=t;else if(Array.isArray(t[0])&&t[0].length===2){this.serie=[];for(const[e,o]of t)for(let s=0;s<o;s++)this.serie.push(e)}else throw new Error("Le format de la série est invalide")}moyenne(){return l.moyenne(this.serie)}variance(){const t=this.moyenne();return this.serie.reduce((o,s)=>o+Math.pow(s-t,2),0)/this.serie.length}ecartType(){return Math.sqrt(this.variance())}mediane(){const t=[...this.serie].sort((o,s)=>o-s),e=Math.floor(t.length/2);return t.length%2===0?(t[e-1]+t[e])/2:t[e]}mode(){const t={};for(const o of this.serie)t[o]=(t[o]||0)+1;const e=Math.max(...Object.values(t));return Object.keys(t).filter(o=>t[Number(o)]===e).map(Number)}min(){return Math.min(...this.serie)}max(){return Math.max(...this.serie)}etendue(){return this.max()-this.min()}coefVariation(){return this.ecartType()/this.moyenne()}quartiles(){return l.quartiles(this.serie)}serieTriee(){return l.serieTriee(this.serie)}boiteAMoustache(){return l.boiteAMoustache(this.serie)}traceBoiteAMoustache({size:t=10,height:e=4,legendeOn:o=!0,valeursOn:s=!0,echelle:c=1}){return l.traceBoiteAMoustache(this.serie,{size:t,height:e,echelle:c,legendeOn:o,valeursOn:s})}static boiteAMoustache(t){if(!t||t.length===0)throw new Error("La série ne peut pas être vide");const e=[...t].sort((n,d)=>n-d),o=e.length,s=Math.floor(o/2),c=(o%2===0,e.slice(0,s)),u=o%2===0?e.slice(s):e.slice(s+1),a=c.length?l.mediane(c):e[0],i=l.mediane(e),M=u.length?l.mediane(u):e[e.length-1],b=M-a,h=a-1.5*b,p=M+1.5*b,m=e.find(n=>n>=h)??e[0],f=[...e].reverse().find(n=>n<=p)??e[e.length-1],r=e.filter(n=>n<m||n>f);return{q1:a,q2:i,q3:M,iqr:b,borneInferieure:h,borneSuperieure:p,moustacheInferieure:m,moustacheSuperieure:f,valeursAberrantes:r,min:e[0],max:e[e.length-1],valeurs:e}}static moyenne(t){return t.reduce((o,s)=>o+s,0)/t.length}static variance(t){const e=l.moyenne(t);return t.reduce((s,c)=>s+Math.pow(c-e,2),0)/t.length}static ecartType(t){return Math.sqrt(l.variance(t))}static mediane(t){const e=[...t].sort((s,c)=>s-c),o=Math.floor(e.length/2);return e.length%2===0?(e[o-1]+e[o])/2:e[o]}static mode(t){const e={};for(const s of t)e[s]=(e[s]||0)+1;const o=Math.max(...Object.values(e));return Object.keys(e).filter(s=>e[Number(s)]===o).map(Number)}static min(t){return Math.min(...t)}static max(t){return Math.max(...t)}static etendue(t){return l.max(t)-l.min(t)}static coefVariation(t){return l.ecartType(t)/l.moyenne(t)}static quartiles(t){if(!t||t.length===0)throw new Error("La série ne peut pas être vide");const e=[...t].sort((b,h)=>b-h),o=e.length,s=Math.floor(o/2),c=(o%2===0,e.slice(0,s)),u=o%2===0?e.slice(s):e.slice(s+1),a=c.length?l.mediane(c):e[0],i=l.mediane(e),M=u.length?l.mediane(u):e[e.length-1];return{q1:a,q2:i,q3:M}}static serieTriee(t){return[...t].sort((e,o)=>e-o)}static traceBoiteAMoustache(t,{size:e=10,height:o=3,echelle:s=1,legendeOn:c=!0,valeursOn:u=!0}){const a=l.boiteAMoustache(t),i=a.max-a.min,M=v(-1,0),b=v(e+1,0),h=v(0,0),p=v(e,0),m=v(e*(a.q1-a.min)/i,0),f=v(e*(a.q2-a.min)/i,0),r=v(e*(a.q3-a.min)/i,0),n=y(h.x,s*.8),d=y(h.x,2.4*s),g=y(p.x,s*.8),T=y(p.x,2.4*s),U=D(n,d),V=D(g,T),B=y(m.x,s*.8),C=y(m.x,2.4*s),k=y(f.x,s*.8),G=y(f.x,2.4*s),E=y(r.x,s*.8),j=y(r.x,2.4*s),H=D(B,C),I=D(E,j),L=w(n,d,"blue"),R=w(g,T,"blue"),O=w(k,G,"blue"),F=w(U,H,"blue"),N=w(I,V,"blue");L.epaisseur=2,R.epaisseur=2,O.epaisseur=2,F.epaisseur=2,N.epaisseur=2;const Q=J([B,C,j,E],"blue");Q.epaisseur=2,Q.couleurDeRemplissage=K("blue"),Q.opaciteDeRemplissage=.15;const $=w(M,b);$.epaisseur=1,$.styleExtremites="->",$.couleur="black";const A=W(m,f,r,h,p);A.taille=2,A.epaisseur=2,A.style=".";const z=[$,A,L,R,O,F,N,Q];return u&&z.push(q(x(a.min),h.x,h.y-.8,{letterSize:"scriptsize"}),q(x(a.q1),m.x,m.y-.8,{letterSize:"scriptsize"}),q(x(a.q2),f.x,f.y-.8,{letterSize:"scriptsize"}),q(x(a.q3),r.x,r.y-.8,{letterSize:"scriptsize"}),q(x(a.max),p.x,p.y-.8,{letterSize:"scriptsize"})),c&&z.push(q("\\text{Min}",h.x,h.y-1.6,{letterSize:"scriptsize"}),q("Q_1",m.x,m.y-1.6,{letterSize:"scriptsize"}),q("\\text{Méd}",f.x,f.y-1.6,{letterSize:"scriptsize"}),q("Q_3",r.x,r.y-1.6,{letterSize:"scriptsize"}),q("\\text{Max}",p.x,p.y-1.6,{letterSize:"scriptsize"})),X(Object.assign({},Y(z)),z)}static createSerieFromQuartiles({q1:t,mediane:e,q3:o,min:s,max:c,n:u=20,isInteger:a=!1}){if(u<5)throw new Error("La taille de la série doit être au moins de 5");a&&(t=Math.round(t),e=Math.round(e),o=Math.round(o),s=Math.round(s),c=Math.round(c),t>e&&(e=t),e>o&&(o=e),s>t&&(s=t),c<o&&(c=o));const i=[],M=Math.floor(u/4),b=u-3*M;for(let r=0;r<M;r++){const n=t-(t-s)*(Math.random()*.5+.1);i.push(a?Math.round(n):n)}for(let r=0;r<M;r++){const n=t+(e-t)*(Math.random()*.8+.1);i.push(a?Math.round(n):n)}for(let r=0;r<M;r++){const n=e+(o-e)*(Math.random()*.8+.1);i.push(a?Math.round(n):n)}for(let r=0;r<b;r++){const n=o+(c-o)*(Math.random()*.5+.1);i.push(a?Math.round(n):n)}i.sort((r,n)=>r-n);const h=r=>{const n=Math.floor(u/2),d=n;if(r==="q1")return d%2===1?[Math.floor(d/2)]:[d/2-1,d/2];if(r==="q2")return u%2===1?[n]:[n-1,n];{const g=u-d;return d%2===1?[g+Math.floor(d/2)]:[g+d/2-1,g+d/2]}},p=(r,n)=>{if(r.length===1)i[r[0]]=a?Math.round(n):n;else{const d=a?Math.round(n):n;i[r[0]]=d,i[r[1]]=d}};p(h("q1"),t),p(h("q2"),e),p(h("q3"),o),i[0]=a?Math.round(s):s,i[u-1]=a?Math.round(c):c;for(let r=0;r<u;r++)i[r]<s&&(i[r]=s),i[r]>c&&(i[r]=c);for(let r=1;r<u;r++)if(i[r]<i[r-1]){const n=i[r];i[r]=n,i[r-1]=n,r++}const m=l.quartiles(i),f=(r,n)=>a?r===n:Math.abs(r-n)<1e-9;if(!f(m.q1,t)||!f(m.q2,e)||!f(m.q3,o))throw new Error("Impossible de construire une série respectant exactement les quartiles demandés avec les contraintes fournies");if(i[0]!==(a?Math.round(s):s)||i[u-1]!==(a?Math.round(c):c))throw new Error("Impossible de conserver min/max comme extrêmes sans violer les quartiles demandés");return i}}const he="a5ab7",me={"fr-fr":["betaBAM"],"fr-ch":[]},pe=!0,de="qcm",fe="true",Me="qcmMono",be="Comparer deux nombres",xe="02/09/2025";class ye extends S{constructor(){super(),this.nbQuestions=1,this.nbQuestionsModifiable=!1,this.spacing=2,this.besoinFormulaire2CaseACocher=["Avec les légendes",!0],this.sup2=!0,this.besoinFormulaireCaseACocher=["Avec les valeurs",!0],this.sup=!0}nouvelleVersion(){const t=P(15,45),e=P(55,85),o=P(t+2,e-2),s=P(t-10,t-5),c=P(e+5,e+10),u=l.createSerieFromQuartiles({q1:t,mediane:o,q3:e,min:s,max:c,n:30,isInteger:!0}),a=new l(u),i=l.boiteAMoustache(u),M=i.valeurs,b=i.q3-i.q1,h=i.q1-1.5*b,p=i.q3+1.5*b,m=u.filter(r=>r<h||r>p),f=m.length>0?"Oui":"Non";this.listeQuestions[0]=`Voici la série de nombres : ${u.map(r=>`$${x(r)}$`).join(" ; ")}.<br>
Peut-on affirmer qu'il y a des valeurs aberrantes dans cette série selon la méthode de la boîte à moustaches ?<br>
${a.traceBoiteAMoustache({size:25,height:4,legendeOn:this.sup2,valeursOn:this.sup})}`,this.listeCorrections[0]=`Rangeons les valeurs de la série par ordre croissant : ${M.join(", ")}.<br>
    Pour déterminer s'il y a des valeurs aberrantes dans la série, nous devons calculer l'écart interquartile (IQR).<br>
$Q_1 = ${x(i.q1,2)}$, $Q_3 = ${x(i.q3,2)}$<br>
$\\text{IQR} = Q_3 - Q_1 = ${x(b,2)}$<br>
Les bornes pour détecter les valeurs aberrantes sont :<br>
Borne inférieure $= Q_1 - 1{,}5 * \\text{ IQR} = ${x(h,2)}$<br>
Borne supérieure $= Q_3 + 1{,}5 * \\text{ IQR} = ${x(p,2)}$<br>
Les valeurs aberrantes sont celles qui sont en dehors de ces bornes : ${m.length>0?m.join(", "):"Aucune"}.<br>
Donc, peut-on affirmer qu'il y a des valeurs aberrantes dans cette série ? ${Z(f)}.`}}export{fe as amcReady,Me as amcType,xe as dateDePublication,ye as default,pe as interactifReady,de as interactifType,me as refs,be as titre,he as uuid};
