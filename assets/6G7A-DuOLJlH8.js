import{S as R}from"./main-Vl0czKSA.js";import{h as F}from"./exerciseMethods-CtbYPwln.js";import{af as C,r as j,a as Q,y as E,aP as V,p as k,bH as H,B as $,c9 as _,q as I,cB as B,I as q,bg as N,aF as K,cI as X,cQ as T,cL as Y,aH as D,bj as U,aG as z,o as v,a1 as A}from"./embellissements-BYV7mIDn.js";import{g as W}from"./reperes-WwrVcExd.js";import{f as J}from"./figureApigeom-Da_B6AP0.js";import{E as Z}from"./Exercice-DtXhjCyI.js";import"./index-BUDQz6-w.js";import"katex";import"mathjs";import"crypto-js";import"seedrandom";import"decimal.js";import"earcut";import"roughjs";import"./generalStore-C3E9FHtR.js";import"./canStore-DaSrd7sp.js";const ye="Construire des symétriques de points",xe="07/01/2024",ge="15/04/2025",Pe=!0,$e="custom",Ae="26ea4",Ge={"fr-fr":["6G7A"],"fr-2016":["6G24-0"],"fr-ch":["9ES6-11"]};function S(d,t){return d.x<t.x?"above left":d.x>t.x?"below right":d.y>t.y?"above left":"below right"}function ee(d,t){const p=[],a=[{x:1,y:0},{x:0,y:1},{x:1,y:1},{x:1,y:-1}];for(const e of d)e.x>=-7.5&&e.x<=7.5&&e.y>=-7.5&&e.y<=7.5&&e.x!==e.y&&e.x!==-e.y&&(p.some(o=>o.x===e.x&&o.y===e.y||a[t].x*e.x+a[t].y*e.y===a[t].x*o.x+a[t].y*o.y)||p.push(e));return p}class Le extends Z{figuresApiGeom;nbPoints;antecedents;labels;d;exoCustomResultat;constructor(){super(),this.exoCustomResultat=!0,this.nbQuestions=1,this.besoinFormulaireNumerique=["Type d'axes",5,`1 : Axe horizontal
2 : Axe vertical
3 : Axe oblique /
4 : Axe oblique \\
5 : Mélange`],this.besoinFormulaire2Numerique=["Type d'aide",4,`Quadrillages
Perpendiculaires en pointillés
Marques de compas
Aucune`],this.besoinFormulaire3Numerique=["Nombre de points à construire (5 maxi)",5],this.sup=1,this.sup2=1,this.sup3=3,this.nbPoints=3}nouvelleVersion(){const t=["//","///","x","O","|||"],p=["red","green","purple","blue","gray"];this.answers={};let a=[];this.figuresApiGeom=[],this.sup===5?a=C([1,2,3,4],this.nbQuestions):a=C([this.sup],this.nbQuestions),this.nbPoints=Math.max(Math.min(this.sup3,5),1),this.antecedents=[],this.labels=[],this.d=[];for(let e=0;e<this.nbQuestions;e++){let o="",r=[];const b=[],G=[],f=[];let c=[];const u=[];let l;f.length=0,c.length=0,b.length=0,G.length=0,r.length=0;let n=[],m=[];do{n=[];for(let s=-4;s<4;s+=1)n.push({y:(j(1,3)*2+1)*Q([-.5,.5]),x:s});if(a[e]===1)for(let s=0;s<n.length;s++)n[s]={x:n[s].x*2,y:n[s].y*2};else if(a[e]===2)for(let s=0;s<n.length;s++)n[s]={x:n[s].y*2,y:n[s].x*2};else if(a[e]===3)for(let s=0;s<n.length;s++)n[s]={x:Math.round(Math.sqrt(2)*(n[s].x-n[s].y)),y:Math.round(Math.sqrt(2)*(n[s].x+n[s].y))};else for(let s=0;s<n.length;s++)n[s]={x:Math.round(Math.sqrt(2)*(n[s].x+n[s].y)),y:Math.round(Math.sqrt(2)*(n[s].y-n[s].x))};m.push(...n),m=ee(m,a[e]-1)}while(m.length<this.nbPoints);m=E(m),n=m.slice(0,this.nbPoints),this.labels[e]=V(n.length).split(""),r=E(n).map((s,i)=>k(s.x,s.y,this.labels[e][i]));const x=k(0,0,"","above");a[e]===1?(u[e]=H(x),l=$("(d)",-7.5,-.8,"black",0,0,"",8)):a[e]===2?(u[e]=_(x),l=$("(d)",-.8,-7.5,"black",0,0,"",8)):a[e]===3?(u[e]=I(x,1),l=$("(d)",-7.5,-6.2,"black",0,0,"",8)):(u[e]=I(x,-1),l=$("(d)",-7.5,6.2,"black",0,0,"",8));const y=[];for(let s=0;s<this.nbPoints;s++){const i=B(r[s],u[e]);i.pointilles=2,i.color=q(p[s]),i.opacite=.8,y.push(i)}o=`${this.sup2===1?"Placer":"Construire"} le${this.nbPoints>1?"s":""} symétrique${this.nbPoints>1?"s":""} $${this.nbPoints>1?this.labels[e].slice(0,this.nbPoints-1).join("',")+"'":this.labels[e][0]+"' "}$`+(this.nbPoints>1?` et $${this.labels[e][this.nbPoints-1]+"'"}$`:"")+(this.nbPoints>1?" respectifs ":""),o+=`${this.nbPoints>1?" des":" du"} point${this.nbPoints>1?"s":""} $${this.nbPoints>1?this.labels[e].slice(0,this.nbPoints-1).join(","):this.labels[e][0]+"$ par rapport à la droite $(d)."}$`+(this.nbPoints>1?` et $${this.labels[e][this.nbPoints-1]}$ par rapport à la droite $(d)$.<br>`:"<br>");const g=[];for(let s=0;s<this.nbPoints;s++){G[s]=N(r[s],u[e]),b[s]=K(r[s],u[e]);const i=X(b[s],r[s],p[s]);i.pointilles=2,i.opacite=.8,g.push(i)}this.sup2===1?f.push(W(-8,-8,8,8,"gray",.5,1,0)):this.sup2===2?(o+="Les droites tracées en pointillés sont perpendiculaires à $(d)$.<br>",f.push(...y)):this.sup2===3&&(o+="Les cercles tracés en pointillés sont centrés sur $(d)$.<br>",f.push(...g)),f.push(u[e],l);for(let s=0;s<this.nbPoints;s++){f.push(new T(r[s]));const i=N(r[s],u[e],r[s].nom+"'");i.positionLabel=S(i,r[s]),r[s].positionLabel=S(r[s],i);const L=Y(r[s],i,p[s],t[s]),P=new T(i);P.color=q("red");const M=D(i),h=D(r[s]);f.push(h),c.push(P,M,L)}c=[...f,...c,...y],this.sup2===2&&(y.forEach(s=>{s.epaisseur=1,s.opacite=.8}),c.push(...y)),this.sup2===3&&(g.forEach(s=>{s.epaisseur=1,s.opacite=.8}),c.push(...g));const w=U(u[e],50,"","above");for(let s=0;s<this.nbPoints;s++){const i=z(r[s],b[s],w,"blue",.3,.5);c.push(i)}const O={};if(this.sup2===1&&Object.assign(O,{snapGrid:!0,dx:1,dy:1}),this.interactif){this.figuresApiGeom[e]=new R(Object.assign(O,{xMin:-10,yMin:-10,width:300,height:300})),this.figuresApiGeom[e].options.labelAutomaticBeginsWith=this.labels[e][0]+"'",this.figuresApiGeom[e].scale=.5,this.figuresApiGeom[e].setToolbar({tools:["POINT","POINT_ON","POINT_INTERSECTION","LINE_PERPENDICULAR","CIRCLE_CENTER_POINT","DRAG","NAME_POINT","SHAKE","UNDO","REDO","REMOVE"],nbCols:6,position:"top"});const s=this.figuresApiGeom[e].create("Point",{x:0,y:0,isVisible:!1,isSelectable:!1});let i;a[e]===1?i=this.figuresApiGeom[e].create("Point",{x:7,y:0}):a[e]===2?i=this.figuresApiGeom[e].create("Point",{x:0,y:7}):a[e]===3?i=this.figuresApiGeom[e].create("Point",{x:7,y:7}):i=this.figuresApiGeom[e].create("Point",{x:7,y:-7}),i.isVisible=!1,i.isFree=!1,s.isFree=!1,this.d[e]=this.figuresApiGeom[e].create("Line",{point1:s,point2:i}),this.d[e].color="blue",this.d[e].thickness=2;const L=l.x,P=l.y;this.figuresApiGeom[e].create("TextByPosition",{text:"$(d)$",x:L,y:P}),this.antecedents[e]=[];for(let h=0;h<this.nbPoints;h++)this.antecedents[e][h]=this.figuresApiGeom[e].create("Point",{x:r[h].x,y:r[h].y,isSelectable:!0,isFree:!1,label:r[h].nom});if(this.sup2===1&&this.figuresApiGeom[e].create("Grid",{xMin:-10,yMin:-10,xMax:10,yMax:10,stepX:1,stepY:1,color:"gray",axeX:!1,axeY:!1,labelX:!1,labelY:!1}),this.sup2===2)for(let h=0;h<this.nbPoints;h++)this.figuresApiGeom[e].create("LinePerpendicular",{point:this.antecedents[e][h],line:this.d[e],isDashed:!0,color:"gray"});if(this.sup2===3)for(let h=0;h<this.nbPoints;h++)this.figuresApiGeom[e].create("CircleCenterPoint",{center:this.figuresApiGeom[e].create("Point",{isVisible:!1,x:b[h].x,y:b[h].y}),point:this.antecedents[e][h],isDashed:!0,color:"gray"});const M=J({exercice:this,i:e,figure:this.figuresApiGeom[e],defaultAction:"POINT"});this.listeQuestions[e]=o+"<br><br>"+M}else this.listeQuestions[e]=o+"<br><br>"+v({xmin:-10,xmax:10,ymin:-10,ymax:10,scale:.5,pixelsParCm:15},f);this.listeCorrections[e]=v({xmin:-10,xmax:10,ymin:-10,ymax:10,scale:.5,pixelsParCm:15},c)}}correctionInteractive=t=>{this.answers===void 0&&(this.answers={}),this.answers[this.figuresApiGeom[t].id]=this.figuresApiGeom[t].json;const p=[],a=document.querySelector(`#feedbackEx${this.numeroExercice}Q${t}`);let e="";for(let o=0;o<this.nbPoints;o++){const{x:r,y:b}=F(this.antecedents[t][o],this.d[t]),f=Array.from(this.figuresApiGeom[t].elements.values()).filter(l=>l.type!=="pointer"&&(l.type==="Point"||l.type==="PointOnLine"||l.type==="PointOnCircle"||l.type==="PointIntersectionLL"||l.type==="PointIntersectionLC"||l.type==="PointIntersectionCC")),c=f.find(l=>l.label===`${this.labels[t][o]}'`),u=f.find(l=>A(r,l.x,.001)&&A(b,l.y,.001));c!=null?A(r,c.x,.001)&&A(b,c.y,.001)?(c.color="green",c.thickness=2,c.colorLabel="green",p.push("OK")):(c.color="green",c.thickness=2,c.colorLabel="green",e+=`Il y a  bien un point nommé $${this.antecedents[t][o].label}'$ mais ce n'est pas le symétrique de $${this.antecedents[t][o].label}$ !<br>`,p.push("KO")):(u!=null?(u.color="green",u.thickness=2,u.colorLabel="red",e+=`Le symétrique de $${this.antecedents[t][o].label}$ est bien construit mais il n'est pas nommé $${this.antecedents[t][o].label}'$ !<br>`):e+=`Il n'y a pas de point symétrique de $${this.antecedents[t][o].label}$ et il n'y a pas de point nommé $${this.antecedents[t][o].label}'$ !<br>`,p.push("KO"))}return this.sup2!==1&&(this.figuresApiGeom[t].shake(),e="On « secoue » la figure pour voir si les points sont bien définis.<br>"+e),a&&(a.innerHTML=e),this.figuresApiGeom[t].isDynamic=!1,this.figuresApiGeom[t].divButtons.style.display="none",this.figuresApiGeom[t].divUserMessage.style.display="none",p}}export{ge as dateDeModifImportante,xe as dateDePublication,Le as default,Pe as interactifReady,$e as interactifType,Ge as refs,ye as titre,Ae as uuid};
