import{g as q,af as F,F as e,r as t,m as d,l as D}from"./embellissements-BYV7mIDn.js";import{E as y}from"./Exercice-DtXhjCyI.js";import{P as h}from"./PolynomePlusieursVariables-DEsXl1Ev.js";import{M as l}from"./MonomePlusieursVariables-DHq3iA-O.js";import{E as L}from"./EquationSecondDegre-Dejvrn5a.js";import"mathjs";import"decimal.js";import"katex";import"earcut";import"roughjs";import"./exerciseMethods-CtbYPwln.js";import"./index-BUDQz6-w.js";import"crypto-js";import"seedrandom";import"./languagesStore-wAwK5LyE.js";import"./canStore-DaSrd7sp.js";const H="Déterminer l'ensemble des points d'intersection entre deux courbes",J=!1,K="mathLive",W="05/01/2025",X="e37e2",Y={"fr-fr":["2G34-13"],"fr-ch":["1mF2-13"]};class Z extends y{constructor(){super(),this.consigne="",this.nbQuestions=1,this.besoinFormulaireNumerique=["Type de questions",3,`1 : Aucun point d'intersection
2 : Au moins un point d'intersection
3 : Mélange`],this.besoinFormulaire2CaseACocher=["Avec des fractions"],this.besoinFormulaire3Numerique=["Type de courbes",4,`1 : Deux droites
2 : Une droite et une parabole
3 : Deux paraboles
4 : Mélange`],this.sup2=!1,this.sup=3,this.sup3=4}nouvelleVersion(){this.listeQuestions=[],this.listeCorrections=[],this.autoCorrection=[];const b=q({saisie:this.sup,min:1,max:2,melange:3,defaut:3,listeOfCase:["aucune","unOuDeux"],nbQuestions:this.nbQuestions,shuffle:!0}),c=q({saisie:this.sup3,min:1,max:3,melange:4,defaut:3,listeOfCase:["droiteDroite","droitePara","paraPara"],nbQuestions:this.nbQuestions,shuffle:!0}),g=F(b,this.nbQuestions);for(let s=0,_=0;s<this.nbQuestions&&_<50;){let m="",n="",w=[new e(0,1),new e(0,1)],p=[new e(0,1),new e(0,1),new e(0,1)],x=[new e(0,1),new e(0,1),new e(0,1)],C,v,S,i,a,o,r;if(c[s]!=="droiteDroite"){do{do this.sup2===!1?(w=[new e(t(-10,10,[0]),1),new e(t(-10,10),1)],p=[new e(t(-10,10,[0]),1),new e(t(-10,10),1),new e(t(-10,10,[0]),1)],x=[new e(t(-10,10,[0]),1),new e(t(-10,10),1),new e(t(-10,10,[0]),1)]):(w=[new e(t(-10,10,[0]),t(-10,10,[0])),new e(t(-10,10),t(-10,10,[0]))],p=[new e(t(-10,10,[0]),t(-10,10,[0])),new e(t(-10,10),t(-10,10,[0])),new e(t(-10,10,[0]),t(-10,10,[0]))],x=[new e(t(-10,10,[0]),t(-10,10,[0])),new e(t(-10,10),t(-10,10,[0])),new e(t(-10,10,[0]),t(-10,10,[0]))]),C=new h([new l(w[0],{variables:["x"],exposants:[0]}),new l(w[1],{variables:["x"],exposants:[1]})]).ordonner(),v=new h([new l(p[0],{variables:["x"],exposants:[0]}),new l(p[1],{variables:["x"],exposants:[1]}),new l(p[2],{variables:["x"],exposants:[2]})]).ordonner(),S=new h([new l(x[0],{variables:["x"],exposants:[0]}),new l(x[1],{variables:["x"],exposants:[1]}),new l(x[2],{variables:["x"],exposants:[2]})]).ordonner(),c[s]==="droitePara"?(o=C,r=v):(o=v,r=S),a=r.difference(o).ordonner().reduire();while(a.monomes.length<3);i=L.aPartirDesCoefficients(a.monomes[0].coefficient,a.monomes[1].coefficient,a.monomes[2].coefficient,new e(0,1),new e(0,1),new e(0,1),{variable:"x",format:"reduit"}),a=a.reduire()}while(g[s]==="aucune"&&i.delta.signe===1||g[s]==="unOuDeux"&&i.delta.signe===-1||g[s]==="unOuDeux"&&(i.solutionsListeTex[0].includes("sqrt")||i.solutionsListeTex[0].includes(",")));c[s]==="droitePara"&&(m+=`Soit la droite $d$ d'équation $y=${o.toString()}$ et la parabole $\\mathcal{C}$ d'équation $y=${r.toString()}$.<br> Déterminer l'ensemble des points d'intersection de $d$ et $\\mathcal{C}$.`,n+="Afin de déterminer les points d'intersection de $d$ et $\\mathcal{C}$, on cherche les solutions de l'équation "),c[s]==="paraPara"&&(m+=`Soit la parabole $\\mathcal{C_1}$ d'équation $y=${r.toString()}$ et la parabole $\\mathcal{C_2}$ d'équation $y=${o.toString()}$. <br>Déterminer l'ensemble des points d'intersection de $\\mathcal{C_1}$ et $\\mathcal{C_2}$.`,n+="Afin de déterminer les points d'intersection de $\\mathcal{C_1}$ et $\\mathcal{C_2}$, on cherche les solutions de l'équation "),n+=`\\[${r.toString()}=${o.toString()}\\]
    c'est-à-dire
    \\[${i.printToLatexMDG()}=0\\]
    On résout cette équation en utilisant la méthode de résolution du deuxième degré. On calcule le discriminant $\\Delta=${i.delta.texFractionSimplifiee}$.<br>`,i.delta.num===0?(n+=`Le discriminant étant nul, l'équation admet une unique solution réelle. Elle vaut $x_1=${i.solutionsListeTex[0]}$.<br>`,n+="On détermine la deuxième coordonnée du point d'intersection en évaluant l'équation de la droite en $x=x_1$. On obtient",n+=`\\[y_1=${o.toStringEvaluate({x:i.solutionFrac()[0]})}=${o.evaluer({x:i.solutionFrac()[0]}).texFractionSimplifiee}\\]`,n+=`On a ${c[s]!=="paraPara"?`$${d("d\\cap \\mathcal{C}")}$`:`$${d("\\mathcal{C_1} \\cap \\mathcal{C_2}")}$`}$ ${d(`=\\left\\{\\left(${i.solutionsListeTex[0]}\\,;\\,${r.evaluer({x:i.solutionFrac()[0]}).texFractionSimplifiee}\\right)\\right\\}`)}$.<br>`):i.delta.signe===1?(n+=`Le discriminant étant positif, l'équation admet deux solutions réelles. Elles valent $x_1=${i.solutionsListeTex[0]}$ et $x_2=${i.solutionsListeTex[1]}$.<br> 
        On détermine la deuxième coordonnée des points d'intersection en évaluant l'expression ${c[s]==="paraPara"?"d'une des paraboles":"de la droite"} en $x=x_1$ et $x=x_2$. On obtient `,n+=`\\[y_1=${o.toStringEvaluate({x:i.solutionFrac()[0]})}=${o.evaluer({x:i.solutionFrac()[0]}).texFractionSimplifiee}\\quad\\text{ et }\\quad y_2=${o.toStringEvaluate({x:i.solutionFrac()[1]})}=${o.evaluer({x:i.solutionFrac()[1]}).texFractionSimplifiee}\\]`,n+=`On a ${c[s]!=="paraPara"?`$${d("d\\cap \\mathcal{C}")}$`:`$${d("\\mathcal{C_1} \\cap \\mathcal{C_2}")}$`} $${d(`=\\left\\{\\left(${i.solutionsListeTex[0]}\\,;\\,${r.evaluer({x:i.solutionFrac()[0]}).texFractionSimplifiee}\\right)\\,;\\,\\left(${i.solutionsListeTex[1]}\\,;\\,${r.evaluer({x:i.solutionFrac()[1]}).texFractionSimplifiee}\\right)\\right\\}`)}$.<br>`):n+=`Le discriminant étant négatif, l'équation n'admet pas de solution réelle. ${c[s]!=="paraPara"?`$${d("d\\cap\\mathcal{C}=\\emptyset")}$`:`$${d("\\mathcal{C_1}\\cap\\mathcal{C_2}=\\emptyset")}$.<br>`}`}else if(c[s]==="droiteDroite"){let u=[new e(0,1),new e(0,1)],$=[new e(0,1),new e(0,1)];if(b[s]!=="aucune")do this.sup2===!1?(u=[new e(t(-10,10,[0]),1),new e(t(-10,10,[0]),1)],$=[new e(t(-10,10,[0]),1),new e(t(-10,10,[0]),1)]):(u=[new e(t(-10,10,[0]),t(-10,10,[0])),new e(t(-10,10,[0]),t(-10,10,[0]))],$=[new e(t(-10,10,[0]),t(-10,10,[0])),new e(t(-10,10,[0]),t(-10,10,[0]))]);while(u[1].isEqual($[1])||u[0].isEqual($[0]));else do this.sup2===!1?(u=[new e(t(-10,10,[0]),1),new e(t(-10,10),1)],$=[new e(t(-10,10),1),u[1]]):(u=[new e(t(-10,10,[0]),t(-10,10,[0])),new e(t(-10,10),t(-10,10,[0]))],$=[new e(t(-10,10,[0]),t(-10,10,[0])),u[1]]);while(u[0].isEqual($[0]));if(o=new h([new l(u[0],{variables:["x"],exposants:[0]}),new l(u[1],{variables:["x"],exposants:[1]})]).ordonner(),r=new h([new l($[0],{variables:["x"],exposants:[0]}),new l($[1],{variables:["x"],exposants:[1]})]).ordonner(),a=o.difference(r).ordonner().reduire(),a=a.reduire(),m+=`Soit la droite $d_1$ d'équation $y=${o.toString()}$ et la droite $d_2$ d'équation $y=${r.toString()}$. <br>Déterminer l'ensemble des points d'intersection de $d_1$ et $d_2$.`,b[s]!=="aucune"){n+="Afin de déterminer les points d'intersection de $d_1$ et $d_2$, on cherche les solutions de l'équation ",n+=`\\[${o.toString()}=${r.toString()} \\iff ${a.monomes[0].toString()}=${a.monomes[1].oppose().toString()}\\]`;const f=a.monomes[1].coefficient.produitFraction(a.monomes[0].coefficient.oppose().inverse());n+=`L'équation admet une solution $x_1=${f.texFractionSimplifiee}$.<br>
        On détermine la deuxième coordonnée du point d'intersection en évaluant l'équation d'une des droites en $x=x_1$.`,n+=`\\[y_1=${o.toStringEvaluate({x:f})}=${o.evaluer({x:f}).texFractionSimplifiee}\\]`,n+=`Les points d'intersection de $${d(`d_1\\cap d_2=\\left\\{\\left(${f.texFractionSimplifiee}\\,;\\,${r.evaluer({x:f}).texFractionSimplifiee}\\right)\\right\\}`)}$.<br>`}else n+=`Les deux droites ont la même pente, mais une ordonnée à l'origine différente; elles sont donc parallèles. Ainsi, les droites $${d("d_1 \\cap d_2=\\emptyset")}$.<br>`}this.listeQuestions.indexOf(m)===-1&&(this.listeQuestions.push(m),this.listeCorrections.push(n),s++),_++}D(this)}}export{W as dateDePublication,Z as default,J as interactifReady,K as interactifType,Y as refs,H as titre,X as uuid};
