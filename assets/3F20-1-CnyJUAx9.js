import{g as We,am as ze,af as W,r as C,a as ne,F as P,b2 as Be,U as Ke,e as c,p as F,n as ve,T as ae,E as re,W as Ze,Y as d,f as s,ab as se,b as H,o as z,x as Y,a2 as R,m as _e,l as et}from"./embellissements-BYV7mIDn.js";import{r as Fe}from"./reperes-WwrVcExd.js";import{a as k}from"./questionMathLive-DdRvWqlN.js";import{E as tt}from"./Exercice-DtXhjCyI.js";import{h as j}from"./gestionInteractif-DujZpSu8.js";import"mathjs";import"decimal.js";import"katex";import"earcut";import"roughjs";import"./tableauMathlive-xx-nDjq0.js";import"./index-BUDQz6-w.js";import"./canStore-DaSrd7sp.js";import"./generalStore-C3E9FHtR.js";import"seedrandom";import"./comparisonFunctions-B45ZZ3C7.js";import"./compute-engine.min.umd-BwAhpA7x.js";import"./Hms-u2AUyU1C.js";import"./ListeDeroulanteElement-CXmzV-cr.js";import"./sizeTools-DfTC1Dgv.js";import"./time-DMC-jnVL.js";import"./exerciseMethods-CtbYPwln.js";import"crypto-js";import"./AjouteTableauMathlive-Bz24QHd3.js";const Mt="Fonctions affines",At="mathLive",kt=!0,jt=!0,wt="AMCHybride",Ot="08/05/2023",Tt="01/06/2024",Nt={"fr-fr":["3F20-1"],"fr-ch":["10FA5-13","11FA8-7"]},Lt="20d20";class Vt extends tt{lycee;constructor(){super(),this.comment=`L'exercice propose différents types de questions sur les fonctions affines comme son homologue 3F20 sur les fonctions affines :<br>
calcul d'image, calcul d'antécédent.<br>
Ce coefficient peut être au choix entier relatif ou rationnel relatif.<br>
Certaines questions de calcul d'image nécessitent des calculs préalables.<br>
Le choix a été fait d'un antécédent primaire entier positif, le coefficient étant négatif avec une probabilité de 50% ainsi que l'ordonnée à l'origine.<br>`,this.sup=1,this.nbQuestions=8,this.lycee=!1,this.sup2=this.lycee?"11":"9",this.spacingCorr=3,this.besoinFormulaireNumerique=["Coefficient : ",3,`1: Coefficient entier
2: Coefficient rationnel
3: Mélange`]}nouvelleVersion(){this.besoinFormulaire2Texte=this.lycee?["Types de questions",`Nombres séparés par des tirets :
1: Image par expression
2: Image par valeurs
3: Image par graphique
4: Antécédent par expression
5: Antécédent par valeurs
6: Antécédent par graphique
7: Expression par valeurs
8: Expression par graphique
9: Expression par graphique (formule des accroissements)
10: Expression par valeurs (formule des accroissements)
11: Mélange`]:["Types de questions",`Nombres séparés par des tirets :
1: Image par expression
2: Image par valeurs
3: Image par graphique
4: Antécédent par expression
5: Antécédent par valeurs
6: Antécédent par graphique
7: Expression par valeurs
8: Expression par graphique
9: Mélange`];const oe=this.lycee?["imageParExpression","imageParValeurs","imageParGraphique","antecedentParExpression","antecedentParValeurs","antecedentParGraphique","expressionParValeurs","expressionParGraphique","expressionParGraphique2","expressionParValeurs2"]:["imageParExpression","imageParValeurs","imageParGraphique","antecedentParExpression","antecedentParValeurs","antecedentParGraphique","expressionParValeurs","expressionParGraphique"],Ee=We({saisie:this.sup2,min:1,max:this.lycee?10:8,defaut:this.lycee?11:9,nbQuestions:this.nbQuestions,listeOfCase:oe,melange:this.lycee?11:9});this.sup=ze(1,3,this.sup,1);const Se=this.sup===1?W([1],this.nbQuestions):this.sup===2?W([2],this.nbQuestions):W([1,2],this.nbQuestions),ce=W(Ee,this.nbQuestions),le=[];for(let x=0,it,nt,De,Pe,ye,fe=0;x<this.nbQuestions&&fe<50;){De="",ye="",Pe="";const $=String.fromCharCode(102+x);let l="",t="";const i=2*C(2,5)+1,e=C(-10,10,[0]);let a,o;switch(Se[x]){case 2:a=new P(Be(i,le,!1)*ne([-1,1]),i);break;case 1:default:a=C(2,8)*ne([-1,1]);break}const p=a instanceof P;let m;const r=ne(Ke(-10,10,[i,0,1,-1])),n=e+(p?a.num:a*i);p?(o=a.multiplieEntier(r).ajouteEntier(e),m=o.texFSD):(o=e+a*r,m=c(o,0)),le.push(r,i);const u=p?a.simplifie().texFSD:a.toString();let E,g,D,M,w,O;const q=[[5,1,1],[10,.5,2],[20,.25,4],[50,.1,10],[100,.05,20],[250,.02,50],[500,.01,100],[1e3,.005,200],[2e3,25e-5,400]],v=[[5,1,1],[10,.5,2],[20,.25,4],[50,.1,10],[100,.05,20],[250,.02,50],[500,.01,100],[1e3,.005,200],[2e3,25e-5,400]];E=q[0][1],D=q[0][2],w=-q[0][0]-D;for(let f=1;Math.abs(i)>q[f-1][0]&&!(f>=q.length);f++)E=q[f][1],D=q[f][2],w=-q[f][0]-D;g=v[0][1],M=v[0][2],O=-v[0][0]-M;for(let f=1;Math.max(Math.abs(n),Math.abs(e))>v[f-1][0]&&!(f>=v.length);f++)g=v[f][1],M=v[f][2],O=-v[f][0]-M;const pe=w,xe=-w+D,ue=O,me=-O,B=pe*E-1,K=ue*g-1,Z=xe*E+1,_=me*g+1,ee=Fe({xUnite:E,yUnite:g,xMin:pe,yMin:ue,xMax:xe,yMax:me,xThickDistance:D,yThickDistance:M,yLabelEcart:.8,grille:!1}),Ce=F(0,e*g),V=F(i*E,n*g),te=ve(Ce,V),$e=ae(V),Me=F(V.x,0),Ae=F(0,V.y),X=re([Ae,V,Me],"red");X.pointilles=2,X.epaisseur=1;const ie=Ze(`(${i};${n})`,F(V.x+.2,V.y),0,"black",1,"gauche");switch(ce[x]){case"imageParExpression":l+=`Soit $${$}(x)=${p?a.texFSD:c(a)}x${s(e)}$.<br>`,l+=`Calculer l'image de $${r}$ par $${$}$`,l+=this.interactif?k(this,x," ",{texteAvant:" :"}):".",t+=`$${$}(${c(r,0)})=${p?a.texFSD:c(a,0)} \\times ${d(r)}${s(e)}$<br>`,t+=`$\\phantom{f(${c(r,0)})}=${p?a.multiplieEntier(r).texFraction:c(a*r,0)}${p?R(e*a.den,a.den).ecritureAlgebrique:s(e)}$<br>`,t+=`$\\phantom{f(${c(r,0)})}=${p?o.texFSD:c(o,0)}$`,j(this,x,{reponse:{value:o}});break;case"imageParValeurs":if(l+=`Soit $${$}$ la fonction affine telle que $${$}(${i})=${c(n,0)}$ et $${$}(0)=${e}$.<br>`,l+=`Calculer l'image de $${r}$ par $${$}$`,l+=this.interactif?k(this,x," ",{texteAvant:" :"}):".",t+=`Comme $${$}(0)=${e}$, la fonction $${$}(x)=ax+b$ vérifie $a\\times 0 + b = b = ${e}$ et par suite $${$}(x)=ax${s(e)}$.<br>`,t+=`Comme $${$}(${i})=${c(n,0)}$, le coefficient $a$ tel que de $${$}(x)=ax${s(e)}$ vérifie $a\\times ${i}${s(e)} = ${n}$ soit $${i}a=${n-e}$.<br>`,t+=`On en déduit $a=\\dfrac{${c(n-e,0)}}{${i}}`,Y(n-e,i)!==1){const f=new P(n-e,i).simplifie().texFSD;t+=`=${f}`}t+=`$ et par suite $${$}(x)=${u}x${s(e)}$.<br>`,t+=`$${$}(${c(r,0)})=${p?a.texFSD:c(a,0)} \\times ${d(r)}${s(e)}$<br>`,t+=`$\\phantom{f(${c(r,0)})}=${p?a.multiplieEntier(r).texFraction:c(a*r,0)}${p?R(e*a.den,a.den).ecritureAlgebrique:s(e)}$<br>`,t+=`$\\phantom{f(${c(r,0)})}=${p?o.texFSD:c(o,0)}$`,j(this,x,{reponse:{value:o}});break;case"imageParGraphique":if(l+=`La droite représentant la fonction affine $${$}$ passe par le point de coordonnées $(${i};${n})$ et coupe l'axe des ordonnées en $(0;${e})$.<br>`,l+=`Calculer l'image de $${r}$ par $${$}$`,l+=this.interactif?k(this,x," ",{texteAvant:" :"}):".",l+="<br>",l+=z({scale:.6,xmin:B,ymin:K,xmax:Z,ymax:_},ee,te,$e,ie,X),t+=`Comme $${$}(0)=${e}$, la fonction $${$}(x)=ax+b$ vérifie $a\\times 0 + b = b = ${e}$ et par suite $${$}(x)=ax${s(e)}$.<br>`,t+=`Comme $${$}(${i})=${c(n,0)}$, le coefficient $a$ tel que de $${$}(x)=ax${s(e)}$ vérifie $a\\times ${i}${s(e)} = ${n}$ soit $${i}a=${n-e}$.<br>`,t+=`On en déduit $a=\\dfrac{${c(n-e,0)}}{${i}}`,Y(n-e,i)!==1){const f=new P(n-e,i).simplifie().texFSD;t+=`=${f}`}t+=`$ et par suite $${$}(x)=${u}x${s(e)}$.<br>`,t+=`$${$}(${c(r,0)})=${p?a.texFSD:c(a,0)} \\times ${d(r)}${s(e)}$<br>`,t+=`$\\phantom{f(${c(r,0)})}=${p?a.multiplieEntier(r).texFraction:c(a*r,0)}${p?R(e*a.den,a.den).ecritureAlgebrique:s(e)}$<br>`,t+=`$\\phantom{f(${c(r,0)})}=${p?o.texFSD:c(o,0)}$`,j(this,x,{reponse:{value:o}});break;case"antecedentParExpression":l+=`Soit $${$}(x)=${p?a.texFSD:c(a)}x${s(e)}$.<br>`,l+=`Calculer l'antécédent de $${m}$ par $${$}$`,l+=this.interactif?k(this,x," ",{texteAvant:" :"}):".",t+=`Posons $b$ l'antécédent de $${m}$, alors $${$}(b)=${u}\\times b${s(e)}=${m}$.<br>`,t+=`On en déduit $${u}b=${m}${s(-e)}`,p&&(t+=`=${m}${R(-e*a.den,a.den).ecritureAlgebrique}`),t+=`=${p?o.ajouteEntier(-e).texFraction:o-e}$.<br>`,p?(t+=`Donc $b=\\dfrac{${o.ajouteEntier(-e).texFSD}}{${u}}=`,t+=`${o.ajouteEntier(-e).texFSD}\\times ${a.inverse().texFSP}=`):t+=`Donc $b=\\dfrac{${c(o-e,0)}}{${u}}=`,t+=`${r}$`,j(this,x,{reponse:{value:r}});break;case"antecedentParValeurs":if(l+=`Soit $${$}$ la fonction affine telle que $${$}(${i})=${c(n,0)}$ et $${$}(0)=${e}$.<br>`,l+=`Calculer l'antécédent de $${m}$`,l+=this.interactif?k(this,x," ",{texteAvant:" :"}):".",t+=`Comme $${$}(0)=${e}$, la fonction $${$}(x)=ax+b$ vérifie $a\\times 0 + b = b = ${e}$ et par suite $${$}(x)=ax${s(e)}$.<br>`,t+=`Comme $${$}(${i})=${c(n,0)}$, le coefficient $a$ tel que de $${$}(x)=ax${s(e)}$ vérifie $a\\times ${i}${s(e)} = ${n}$ soit $${i}a=${n-e}$.<br>`,t+=`On en déduit $a=\\dfrac{${c(n-e,0)}}{${i}}`,Y(n-e,i)!==1){const f=new P(n-e,i).simplifie().texFSD;t+=`=${f}`}t+=`$ et ainsi que $${$}(x)=${u}x${s(e)}$.<br>`,t+=`Posons $b$ l'antécédent de $${m}$, alors $${$}(b)=${u}\\times b${s(e)}=${m}$.<br>`,t+=`On en déduit $${u}b=${m}${s(-e)}`,p&&(t+=`=${m}${R(-e*a.den,a.den).ecritureAlgebrique}`),t+=`=${p?o.ajouteEntier(-e).texFraction:o-e}$.<br>`,p?(t+=`Donc $b=\\dfrac{${o.ajouteEntier(-e).texFSD}}{${u}}=`,t+=`${o.ajouteEntier(-e).texFSD}\\times ${a.inverse().texFSP}=`):t+=`Donc $b=\\dfrac{${c(o-e,0)}}{${u}}=`,t+=`${r}$`,j(this,x,{reponse:{value:r}});break;case"antecedentParGraphique":if(l+=`La droite représentant la fonction affine $${$}$ passe par le point de coordonnées $(${i};${n})$ et coupe l'axe des ordonnées en $(0;${e})$.<br>`,l+=`Calculer l'antécédent de $${m}$ par $${$}$`,l+=this.interactif?k(this,x," ",{texteAvant:" :"}):".",l+="<br>",l+=z({scale:.6,xmin:B,ymin:K,xmax:Z,ymax:_},ee,te,$e,ie,X),t+=`Comme $${$}(0)=${e}$, la fonction $${$}(x)=ax+b$ vérifie $a\\times 0 + b = b = ${e}$ et par suite $${$}(x)=ax${s(e)}$.<br>`,t+=`Comme $${$}(${i})=${c(n,0)}$, le coefficient $a$ tel que de $${$}(x)=ax${s(e)}$ vérifie $a\\times ${i}${s(e)} = ${n}$ soit $${i}a=${n-e}$.<br>`,t+=`On en déduit $a=\\dfrac{${c(n-e,0)}}{${i}}`,Y(n-e,i)!==1){const f=new P(n-e,i).simplifie().texFSD;t+=`=${f}`}t+=`$ et ainsi que $${$}(x)=${u}x${s(e)}$.<br>`,t+=`Posons $b$ l'antécédent de $${m}$, alors $${$}(b)=${u}\\times b${s(e)}=${m}$.<br>`,t+=`On en déduit $${u}b=${m}${s(-e)}`,p&&(t+=`=${m}${R(-e*a.den,a.den).ecritureAlgebrique}`),t+=`=${p?o.ajouteEntier(-e).texFraction:o-e}$.<br>`,p?(t+=`Donc $b=\\dfrac{${o.ajouteEntier(-e).texFSD}}{${u}}=`,t+=`${o.ajouteEntier(-e).texFSD}\\times ${a.inverse().texFSP}=`):t+=`Donc $b=\\dfrac{${c(o-e,0)}}{${u}}=`,t+=`${r}$`,j(this,x,{reponse:{value:r}});break;case"expressionParValeurs":if(l+=`Soit $${$}$ la fonction affine telle que $${$}(${i})=${c(n,0)}$ et $${$}(0)=${e}$.<br>`,l+=`Donner l'expression de  $${$}(x)$.`,l+=k(this,x," ",{texteAvant:`<br>$${$}(x)=$`}),t+=`Comme $${$}(0)=${e}$, la fonction $${$}(x)=ax+b$ vérifie $a\\times 0 + b = b = ${e}$ et par suite $${$}(x)=ax${s(e)}$.<br>`,t+=`Comme $${$}(${i})=${c(n,0)}$, le coefficient $a$ tel que de $${$}(x)=ax${s(e)}$ vérifie $a\\times ${i}${s(e)} = ${n}$ soit $${i}a=${n-e}$.<br>`,t+=`On en déduit $a=\\dfrac{${c(n-e,0)}}{${i}}`,Y(n-e,i)!==1){const f=new P(n-e,i).simplifie().texFSD;t+=`=${f}`}t+=`$ et ainsi que $${$}(x)=${u}x${s(e)}$`,j(this,x,{reponse:{value:`${u}x${s(e)}`}});break;case"expressionParGraphique":if(l+=`La droite représentant la fonction affine $${$}$ passe par le point de coordonnées $(${i};${n})$ et coupe l'axe des ordonnées en $(0;${e})$.<br>`,l+=`Donner l'expression de  $${$}(x)$.`,l+=k(this,x," ",{texteAvant:`<br>$${$}(x)=$`}),l+="<br>",l+=z({scale:.6,xmin:B,ymin:K,xmax:Z,ymax:_},ee,te,$e,ie,X),t+=`Comme $${$}(0)=${e}$, la fonction $${$}(x)=ax+b$ vérifie $a\\times 0 + b = b = ${e}$ et par suite $${$}(x)=ax${s(e)}$.<br>`,t+=`Comme $${$}(${i})=${c(n,0)}$, le coefficient $a$ tel que de $${$}(x)=ax${s(e)}$ vérifie $a\\times ${i}${s(e)} = ${n}$ soit $${i}a=${n-e}$.<br>`,t+=`On en déduit $a=\\dfrac{${c(n-e,0)}}{${i}}`,Y(n-e,i)!==1){const f=new P(n-e,i).simplifie().texFSD;t+=`=${f}`}t+=`$ et ainsi que $${$}(x)=${u}x${s(e)}$`,j(this,x,{reponse:{value:`${u}x${s(e)}`}});break;case"expressionParGraphique2":{let f,y=C(2,6),Q=C(-7,7,[0,y]);for(;new P(Q,y).estEntiere;)y=C(2,6),Q=C(-7,7,[0,y]);p?(a=new P(Q,y).simplifie(),f=a.texFSD):(a=C(-4,4,0),f=a.toString());const h=C(-4,4,[-1,0,1])*y,b=C(Math.abs(h),8,[-1,0,1])*y,A=C(-10,10,0),T=p?a.multiplieEntier(h).ajouteEntier(A):a*h+A,J=p?T.texFraction:T,N=p?a.multiplieEntier(b).ajouteEntier(A):a*b+A,G=p?N.texFraction:N,ke=p?N.sommeFraction(T.oppose()).texFraction:N-T;E=q[0][1],D=q[0][2],w=-q[0][0]-D;for(let S=1;Math.abs(b)>q[S-1][0]&&!(S>=q.length);S++)E=q[S][1],D=q[S][2],w=-q[S][0]-D;g=v[0][1],M=v[0][2],O=-v[0][0]-M;for(let S=1;Math.max(Math.abs(N),Math.abs(A))>v[S-1][0]&&!(S>=v.length);S++)g=v[S][1],M=v[S][2],O=-v[S][0]-M;const de=w,be=-w+D,he=O,ge=-O,je=de*E-1,we=he*g-1,Oe=be*E+1,Te=ge*g+1,Ne=Fe({xUnite:E,yUnite:g,xMin:de,yMin:he,xMax:be,yMax:ge,xThickDistance:D,yThickDistance:M,yLabelEcart:.8,grille:!1}),Le=F(0,A*g),I=F(b*E,N*g),Ve=ve(Le,I),Qe=ae(I),Ge=F(I.x,0),Ie=F(0,I.y),U=re([Ie,I,Ge],"red");U.pointilles=2,U.epaisseur=1;const Ye=se(`(${b};${G})`,F(I.x+.2,I.y),"black",12,20,""),L=F(h*E,p?T.valeurDecimale*g:T*g),Re=ae(L),Xe=F(L.x,0),Ue=F(0,L.y),He=re([Ue,L,Xe],"blue");U.pointilles=2,U.epaisseur=1;const qe=h<0?L.x-.5:L.x+.5,Je=p?se(`(${H(h)};${J})`,F(qe,L.y),"black",12,20,""):se(`(${h};${J})`,F(qe,L.y),"black",12,20,"");l+=`La droite représentant la fonction affine $${$}$ passe par le point de coordonnées $(${b};${G})$ et par le point de coordonnées $(${H(h)};${J})$.<br>`,l+=`Donner l'expression de  $${$}(x)$.`,l+=k(this,x," ",{texteAvant:`<br>$${$}(x)=$`}),l+="<br>",l+=z({scale:.6,xmin:je,ymin:we,xmax:Oe,ymax:Te},Ne,Ve,Qe,Ye,U,Re,Je,He),t+=`La fonction $${$}(x)=ax+b$ est telle que `,h-b>0?t+=`$a=\\dfrac{f(${H(h)})-f(${b})}{${H(h)}-${d(b)}}=\\dfrac{${J}-${d(N)}}{${h-b}}=\\dfrac{${T-N}}{${h-b}}=${f}$.<br>`:t+=`$a=\\dfrac{f(${b})-f(${H(h)})}{${b}-${d(h)}}=\\dfrac{${G}-${d(T)}}{${b-h}}=\\dfrac{${ke}}{${b-h}}=${f}$.<br>`,t+=`On en déduit que $${$}(x)=${f}x+b$.<br>`,t+=`Comme $${$}(${b})=${G}$, on a $${f}\\times ${d(b)}+b=${G}$ et par suite `,t+=p?`$b=${G}${a.multiplieEntier(-1).ecritureAlgebrique}\\times ${d(b)}=${A}$.<br>`:`$b=${G}${s(-a)}\\times ${d(b)}=${A}$.<br>`,t+=`D'où $${$}(x)=${f}x${s(A)}$`,j(this,x,{reponse:{value:`${f}x${s(A)}`}})}break;case"expressionParValeurs2":{l+=`Soit $${$}$ la fonction affine telle que $${$}(${i})=${c(n,0)}$ et $${$}(${r})=${m}$.<br>`,l+=`Donner l'expression de  $${$}(x)$.`,l+=k(this,x," ",{texteAvant:`<br>$${$}(x)=$`}),t+=`La fonction $${$}(x)=ax+b$ est telle que `,r-i>0?p?t+=`$a=\\dfrac{f(${r})-f(${i})}{${r}-${d(i)}}=\\dfrac{${m}-${d(n)}}{${r-i}}=\\dfrac{${m}-${new P(n*o.den,o.den).ecritureParentheseSiNegatif}}{${r-i}}=\\dfrac{${o.ajouteEntier(-n).texFraction}}{${r-i}}=${o.ajouteEntier(-n).texFraction}\\times \\dfrac{1}{${r-i}}=${u}$.<br>`:t+=`$a=\\dfrac{f(${r})-f(${i})}{${r}-${d(i)}}=\\dfrac{${m}-${d(n)}}{${r-i}}=\\dfrac{${o-n}}{${r-i}}=${u}$.<br>`:p?t+=`$a=\\dfrac{f(${i})-f(${r})}{${i}-${d(r)}}=\\dfrac{${n}-${o.ecritureParentheseSiNegatif}}{${i-r}}=\\dfrac{${new P(n*o.den,o.den).texFraction}-${o.ecritureParentheseSiNegatif}}{${i-r}}=\\dfrac{${o.multiplieEntier(-1).ajouteEntier(n).texFraction}}{${i-r}}=${o.multiplieEntier(-1).ajouteEntier(n).texFraction}\\times \\dfrac{1}{${i-r}}=${u}$.<br>`:t+=`$a=\\dfrac{f(${i})-f(${r})}{${i}-${d(r)}}=\\dfrac{${n}-${d(o)}}{${i-r}}=\\dfrac{${n-o}}{${i-r}}=${u}$.<br>`,t+=`On en déduit que $${$}(x)=${u}x+b$.<br>`,t+=`Comme $${$}(${i})=${n}$, on a $${u}\\times ${d(i)}+b=${n}$ et par suite `,a!==void 0&&(t+=p?`$b=${n}${a.multiplieEntier(-1).ecritureAlgebrique}\\times ${d(i)}=${e}$.<br>`:`$b=${n}${s(-a)}\\times ${d(i)}=${e}$.<br>`),t+=`D'où $${$}(x)=${u}x${s(e)}$`,j(this,x,{reponse:{value:`${u}x${s(e)}`}});break}}if(a!==void 0&&(a=0),this.questionJamaisPosee(x,a,i,n)&&Math.abs(n)>1){const f=t.split("=");let y=f[f.length-1];y=y.replace("$",""),t="";for(let Q=0;Q<f.length-1;Q++)t+=f[Q]+"=";t+=`$ $${_e(y)}$`,oe.indexOf(ce[x].toString())>2&&(t+="."),this.listeQuestions[x]=l,this.listeCorrections[x]=t,x++}fe++}et(this)}}export{jt as amcReady,wt as amcType,Tt as dateDeModifImportante,Ot as dateDePublication,Vt as default,kt as interactifReady,At as interactifType,Nt as refs,Mt as titre,Lt as uuid};
