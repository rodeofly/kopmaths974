import{round as d,polynomialRoot as y}from"mathjs";import j from"decimal.js";import{F as g,b as p,a1 as G,a as w,O as N,p as E,T as F,I as M,r as v}from"./embellissements-BYV7mIDn.js";import{B as L}from"./courbes-C9fk0WuH.js";import{b as k,v as O,a as T}from"./etudeFonction-BXXWUyni.js";import{m as Y,M as $}from"./Matrice-C65I2nuw.js";import{P as D,c as q}from"./Polynome-BIt5zaQj.js";function W(l,e,t=-12/2,i=0,n=2){const r=[],s=e;let o=i,c=Math.cos(Math.random()*Math.PI)*v(1,2);for(let a=t;a<-t+1;a+=n){const x=o;r.push({x:a,y:o,deriveeGauche:c,deriveeDroit:c,isVisible:s});do o=o+w([-1,1])*v(1,2);while(o>5||o<-5);do c=Math.cos(Math.random()*Math.PI)*v(0,2);while(c*(o-x)<0)}return r}class b{n;polys;nbPointsForApiGeom;noeuds;x;y;visibles;fonctions;constructor(e){if(this.polys=[],this.x=[],this.y=[],this.noeuds=[],this.visibles=[],this.nbPointsForApiGeom=100,this.fonctions=[],(e==null||!Array.isArray(e)||e.length<2)&&(window.notify("Spline : nombre de noeuds insuffisant",{noeuds:e}),e=[{x:-3,y:-5,deriveeGauche:0,deriveeDroit:2,isVisible:!1},{x:3,y:0,deriveeGauche:-2,deriveeDroit:-2,isVisible:!1}]),!B(e)){this.n=e.length,window.notify("Il y a un problème avec ces noeuds (peut-être un doublon ?) ",{noeuds:e});return}this.n=e.length;for(let t=0;t<e.length-1;t++){const i=e[t].x,n=e[t].y,r=e[t].deriveeDroit,s=e[t+1].x,o=e[t+1].y,c=e[t+1].deriveeGauche,a=Y([[i**3,i**2,i,1],[s**3,s**2,s,1],[3*i**2,2*i,1,0],[3*s**2,2*s,1,0]]);if(n+(s-i)*c===o&&r===c){const x=(o-n)/(s-i),m=n-x*i;this.polys.push(new D({coeffs:[m,x,0,0]}))}else if(a!=null){if(a.determinant()===0){window.notify("Spline : impossible de trouver un polynome ici car la matrice n'est pas inversible, il faut revoir vos noeuds : ",{noeudGauche:e[t],noeudDroit:e[t+1]});return}const x=a.inverse();if(x!=null){const m=[n,o,r,c],h=x.multiply(m);if(h!=null)this.polys.push(new D({useFraction:!0,coeffs:(h instanceof $?h.toArray():h).reverse().map(u=>Number(Number(u).toFixed(6)))}));else{window.notify("Spline : impossible de trouver un polynome ici car la matrice n'est pas inversible, il faut revoir vos noeuds : ",{noeudGauche:e[t],noeudDroit:e[t+1]});return}}}}this.noeuds=[...e],this.n=this.noeuds.length,this.x=this.noeuds.map(t=>t.x),this.y=this.noeuds.map(t=>t.y),this.visibles=this.noeuds.map(t=>t.isVisible),this.n=this.y.length,this.fonctions=this.#t()}get image(){return this.fonction}pointsOfSpline(e){const t=[],i=(this.x[this.x.length-1]-this.x[0])/this.nbPointsForApiGeom;let n=this.x[0];do t.push(e.create("Point",{x:n,y:this.#e(n),isVisible:!1})),n+=i;while(n<=this.x[this.x.length-1]);return t.push(e.create("Point",{x:this.x[this.x.length-1],y:this.#e(this.x[this.x.length-1]),isVisible:!1})),t}#t(){const e=[];for(let t=0;t<this.n-1;t++)e.push(this.polys[t].fonction);return e}add(e,t){if(this.n!==e.n||this.x.filter(n=>e.x.includes(n)).length!==this.n)throw Error("Veuillez vous assurer de donner deux splines compatibles");const i=[];for(let n=0;n<this.n;n++){const r=this.x[n],s=this.y[n]+(t?-1:1)*e.y[n],o=this.noeuds[n].deriveeGauche+(t?-1:1)*e.noeuds[n].deriveeGauche,c=this.noeuds[n].deriveeDroit+(t?-1:1)*e.noeuds[n].deriveeDroit,a=this.noeuds[n].isVisible&&e.noeuds[n].isVisible;i.push({x:r,y:s,deriveeGauche:o,deriveeDroit:c,isVisible:a})}return new b(i)}zeros(e=1){const t=[];for(let i=this.x[0];i<this.x[this.n-1];i+=.5)if(this.#e(i)*this.#e(i+.5)<0){const{root:n}=k(this.fonction,i,i+.5,1e-9,100);n!=null&&t.push(d(n,e))}else this.#e(i)===0&&t.push(d(i,e)),this.#e(i+.5)===0&&t.push(d(i+.5,e));return Array.from(new Set(t).values())}solve(e,t=2){const i=e;if(e=Number(e),isNaN(e))window.notify(`Spline.solve() a reçu un truc bizarre à la place d'un nombre : ${i} !`,{valeurArgument:i});else{const n=[];for(let r=0;r<this.polys.length;r++){const s=this.polys[r].add(-e);try{const o=s.useFraction?y(...s.monomes.map(Number)):y(...s.monomes.map(Number));for(const c of o){let a;if(typeof c=="number")a=d(c,t);else if(c.toPolar().r<10**(-t-4))a=0;else{const m=c.arg();Math.abs(m)<.001||Math.abs(Math.abs(m)-Math.PI)<.001?a=d(c.re,t):a=null}a!==null&&a>=this.x[r]&&a<=this.x[r+1]&&(n.includes(a)||n.push(a))}}catch(o){const c=o instanceof Error?o.message:String(o);window.notify("Erreur dans Spline.solve()"+c,{valeur_de_y:e})}}return n}}variations(e=new g(1,100)){return O(this.derivee,this.noeuds[0].x,this.noeuds[this.n-1].x)}signes(){const e=[],t=this.zeros(1);let i;if(t.length===0)return[{xG:this.x[0],xD:this.x[this.n-1],signe:this.y[0]>0?"+":"-"}];this.x[0]!==t[0]&&e.push({xG:this.x[0],xD:t[0],signe:this.y[0]>0?"+":"-"}),i=t[0],e.push({xG:t[0],xD:t[0],signe:"z"});for(let r=1;r<t.length;r++){const s=this.#e((i+t[r])/2);e.push({xG:i,xD:t[r],signe:s>0?"+":"-"}),e.push({xG:t[r],xD:t[r],signe:"z"}),i=t[r]}if(t[t.length-1]===this.x[this.n-1])return e;const n=this.#e((t[t.length-1]+this.x[this.n-1])/2);return e.push({xG:t[t.length-1],xD:this.x[this.n-1],signe:n>0?"+":"-"}),e}tableauSignes(e="x",t="f(x)"){const i=this.signes(),n=[];for(let s=0;s<i.length;s++)s===0&&n.push(p(i[0].xG,2),10),s>0&&i[s].xG!==i[s-1].xG&&n.push(p(i[s].xG,2),10);i[i.length-1].xD!==i[i.length-1].xG&&n.push(p(i[i.length-1].xD,2),10);const r=["Line",30];G(this.#e(this.x[0]),0)||r.push("",10);for(let s=0;s<i.length;s++)r.push(i[s].signe,10);return T({tabInit:[[[e,2,10],[t,2,10]],n],tabLines:[r],espcl:3.5,deltacl:.8,lgt:8})}nombreAntecedentsEntiers(e){return(this.solve(e)?.filter(n=>Number.isInteger(n))??[]).length}nombreAntecedents(e){return this.solve(e)?.length??0}nombreAntecedentsMaximum(e,t,i=!0,n=!0){let r=0;for(let s=e;s<t;s+=i?1:.1)n?r=Math.max(r,this.nombreAntecedentsEntiers(s)):r=Math.max(r,this.nombreAntecedents(s));return r}trouveYPourNAntecedents(e,t,i,n=!0,r=!0){const s=[];if(Number.isInteger(t)&&Number.isInteger(i))if(n)for(let o=t;o<=i;o++)(r&&this.nombreAntecedentsEntiers(o)===e&&this.nombreAntecedents(o)===e||!r&&this.nombreAntecedents(o)===e)&&s.push(o);else for(let o=t;o<=i;o+=.1)(r&&this.nombreAntecedentsEntiers(o)===e&&this.nombreAntecedents(o)===e||!r&&this.nombreAntecedents(o)===e)&&s.push(o);else window.notify("trouveYPourNAntecedentsEntiers() appelé avec des valeurs incorrectes",{n:e,yMin:t,yMax:i});return s.length<1?!1:w(s)}trouveMaxes(){if(Array.isArray(this.noeuds)&&this.noeuds.length>0){const e=Math.ceil(Math.min(...this.noeuds.map(r=>r.x))),t=Math.ceil(Math.min(...this.noeuds.map(r=>r.y))),i=Math.floor(Math.max(...this.noeuds.map(r=>r.x))),n=Math.floor(Math.max(...this.noeuds.map(r=>r.y)));return{xMin:e,xMax:i,yMin:t,yMax:n}}else return window.notify("Spline.trouveMaxes() on demande ça alors que la Spline n'a pas de noeuds !",{laSpline:JSON.stringify(this)}),{xMin:0,xMax:0,yMin:0,yMax:0}}amplitude(){let e=1e3,t=-1e3;for(let i=0;i<this.x.length-1;i++){const{minLocal:n,maxLocal:r}=q({poly:this.polys[i],xG:this.x[i],xD:this.x[i+1]});e=Math.min(e,n),t=Math.max(t,r)}return{yMin:e,yMax:t}}get fonction(){return e=>this.#e(e)}#e(e){typeof e!="number"&&(e instanceof g?e=e.valeurDecimale:e instanceof j&&(e=e.toNumber()));const t=e;let i=!1,n=0;for(let r=0;r<this.n-1;r++)if(t>=this.x[r]&&t<=this.x[r+1]){n=r,i=!0;break}if(i)return this.fonctions[n](t);{const r=`D = [${this.x[0]} ; ${this.x[this.n-1]}]`;return window.notify("Spline: la valeur de x fournie n'est pas dans lìntervalle de définition de la fonction",{x:e,intervalle:r}),NaN}}get derivees(){const e=[];for(let t=0;t<this.polys.length;t++)e.push(this.polys[t].derivee());return e}get derivee(){const e=[];for(let t=0;t<this.noeuds.length-1;t++)e.push({xG:this.noeuds[t].x,xD:this.noeuds[t+1].x});return t=>{const i=e.findIndex(n=>t>=n.xG&&t<=n.xD);return this.derivees[i].image(t)}}get splineDerivee(){const e=[];for(const t of this.noeuds)e.push({x:t.x,y:t.deriveeGauche,deriveeGauche:0,deriveeDroit:0,isVisible:t.isVisible});return new b(e)}courbe({color:e="black",epaisseur:t=1,ajouteNoeuds:i=!1,optionsNoeuds:n={}}={}){return new R(this,{color:e,epaisseur:t,ajouteNoeuds:i,optionsNoeuds:n})}}function Z(l){return new b(l)}function B(l){let e,t,i,n,r;for(let s=0;s<l.length-1;s++)for(let o=s+1;o<l.length;o++)if(l[s].x>l[o].x)e=l[s].x,t=l[s].y,i=l[s].deriveeGauche,n=l[s].deriveeDroit,r=l[s].isVisible,l[s].x=l[o].x,l[s].y=l[o].y,l[s].deriveeGauche=l[o].deriveeGauche,l[s].deriveeDroit=l[o].deriveeDroit,l[s].isVisible=l[o].isVisible,l[o].x=e,l[o].y=t,l[o].deriveeGauche=i,l[o].deriveeDroit=n,l[o].isVisible=r;else if(G(l[s].x,l[o].x))return!1;return!0}class R extends N{constructor(e,{color:t="black",epaisseur:i=2,opacite:n=1,ajouteNoeuds:r=!0,optionsNoeuds:s={}}){super(),this.objets=[];const{xMin:o,xMax:c,yMin:a,yMax:x}=e.trouveMaxes();this.bordures=[o,a,c,x];const m=[];for(let h=0;h<e.n-1;h++){const u=e.x[h+1]-e.x[h],f=e.y[h+1]-e.y[h],A=u/3,V=e.noeuds[h].deriveeDroit*u/3,P=2*u/3,S=f-e.noeuds[h+1].deriveeGauche*u/3,I=u,z=f;m.push([[A,V],[P,S],[I,z]])}if(this.objets.push(new L({xStart:e.x[0],yStart:e.y[0],listeOfTriplets:m,color:t,epaisseur:i,opacite:n})),r){for(let h=0;h<e.n;h++)if(e.visibles[h]){const u=E(e.x[h],e.y[h]),f=F(u);s&&(s.color&&(f.color=M(s.color),f.couleurDeRemplissage=M(s.color)),s.epaisseur&&(f.epaisseur=s.epaisseur),s.style&&(f.style=s.style),s.taille&&(f.taille=s.taille)),this.objets.push(f)}}this.svg=function(h){let u="";if(this.objets==null)return u;for(const f of this.objets)u+=`
	`+f.svg(h);return u},this.tikz=function(){let h="";if(this.objets==null)return h;for(const u of this.objets)h+=u.tikz();return h}}}export{b as S,W as n,Z as s};
