import{P as D}from"./PolynomePlusieursVariables-DEsXl1Ev.js";import{F as v,g as E,af as w,r as x,m as F,l as P}from"./embellissements-BYV7mIDn.js";import{E as b}from"./EquationSecondDegre-Dejvrn5a.js";import{E as k}from"./Exercice-DtXhjCyI.js";import"./MonomePlusieursVariables-DHq3iA-O.js";import"mathjs";import"decimal.js";import"katex";import"earcut";import"roughjs";import"./languagesStore-wAwK5LyE.js";import"./canStore-DaSrd7sp.js";import"./exerciseMethods-CtbYPwln.js";import"./index-BUDQz6-w.js";import"crypto-js";import"seedrandom";const J="Déterminer le domaine de définition d'une fonction inverse ou racine",K=!1,W="mathLive",X="14/03/2025",Y="6ea62",Z={"fr-fr":[],"fr-ch":["1mF1-12"]};class ee extends k{constructor(){super(),this.consigne="",this.nbQuestions=1,this.besoinFormulaireNumerique=["Type de questions",8,`1 : 1/q(x)
2 : p(x)/q(x)
3 : √p(x)
4 : √p(x)/q(x)
5 : p(x)/√q(x)
6 : √p(x)/√q(x)
7 : √p(x)+√q(x)
8 : Mélange`],this.besoinFormulaire2Numerique=["Degrés des polynômes",3,`1 : 1er degré
2 : 2e degré
3 : Mélange`],this.sup2=3,this.sup=1}solutionEq(s){if(s.monomes.length===1)return new v(0,1);{const l=s.monomes.find(e=>e.degre===0),i=s.monomes.find(e=>e.degre===1);return l.coefficient.oppose().diviseFraction(i.coefficient).simplifie()}}computeDomainePolynome(s,l,i){if(s==="sqrt"){if(i.length===1)return l.monomes.find(e=>e.degre===1)?.coefficient.signe===1?[["f",i[0].texFractionSimplifiee,"o","+infty"]]:[["o","-infty","f",i[0].texFractionSimplifiee]];if(i.length===2){if(l.monomes.find(e=>e.degre===2)?.coefficient.signe===1)return[["o","-infty","f",i[0].texFractionSimplifiee],["f",i[1].texFractionSimplifiee,"o","+infty"]];if(l.monomes.find(e=>e.degre===2)?.coefficient.signe===-1)return[["f",i[0].texFractionSimplifiee,"f",i[1].texFractionSimplifiee]]}}else if(s==="invSqrt"){if(i.length===1)return l.monomes.find(e=>e.degre===1)?.coefficient.signe===1?[["o",i[0].texFractionSimplifiee,"o","+infty"]]:[["o","-infty","o",i[0].texFractionSimplifiee]];if(i.length===2){if(l.monomes.find(e=>e.degre===2)?.coefficient.signe===1)return[["o","-infty","o",i[0].texFractionSimplifiee],["o",i[1].texFractionSimplifiee,"o","+infty"]];if(l.monomes.find(e=>e.degre===2)?.coefficient.signe===-1)return[["o",i[0].texFractionSimplifiee,"o",i[1].texFractionSimplifiee]]}}else if(s==="inverse"){if(i.length===1)return[["R",i[0].texFractionSimplifiee]];if(i.length===2)return[["R",i[0].texFractionSimplifiee,i[1].texFractionSimplifiee]]}return[[""]]}parseEndpoint(s){if(s==="+infty")return 1/0;if(s==="-infty")return-1/0;const l=/\\dfrac\{([^}]+)\}\{([^}]+)\}/,i=s.match(l);if(i){const e=parseFloat(i[1].replace(",",".")),o=parseFloat(i[2].replace(",","."));return s.match(/-/)?-e/o:e/o}return parseFloat(s)}intersectTwoIntervals(s,l){if(s[0]==="R"&&l[0]==="R"){const p=Array.from(new Set([...s.slice(1),...l.slice(1)]));return p.sort((d,q)=>this.parseEndpoint(d)-this.parseEndpoint(q)),[["R",...p]]}if(s[0]==="R"&&l[0]!=="R")return this.intersectSqrtAndR(l,s);if(l[0]==="R"&&s[0]!=="R")return this.intersectSqrtAndR(s,l);const i=this.parseEndpoint(s[1]),e=this.parseEndpoint(s[3]),o=this.parseEndpoint(l[1]),t=this.parseEndpoint(l[3]);let f,c;i>o?(f=s[1],c=s[0]):o>i?(f=l[1],c=l[0]):(f=s[1],c=s[0]==="o"||l[0]==="o"?"o":"f");let h,g;e<t?(h=s[3],g=s[2]):t<e?(h=l[3],g=l[2]):(h=s[3],g=s[2]==="o"||l[2]==="o"?"o":"f");const n=this.parseEndpoint(f),r=this.parseEndpoint(h);return n>r||n===r&&(c==="o"||g==="o")?[]:[[c,f,g,h]]}intersectSqrtAndR(s,l){const i=l.slice(1);let e=[s];return i.forEach(o=>{const t=this.parseEndpoint(o),f=[];e.forEach(c=>{const h=this.parseEndpoint(c[1]),g=this.parseEndpoint(c[3]);if(t<=h||t>=g)f.push(c);else{const n=[c[0],c[1],"o",o],r=["o",o,c[2],c[3]];this.parseEndpoint(n[1])<this.parseEndpoint(n[3])&&f.push(n),this.parseEndpoint(r[1])<this.parseEndpoint(r[3])&&f.push(r)}}),e=f}),e}reduceUnionSqrt(s){const l=s.map(e=>({left:this.parseEndpoint(e[1]),right:this.parseEndpoint(e[3]),leftMarker:e[0],rightMarker:e[2],leftStr:e[1],rightStr:e[3]}));l.sort((e,o)=>e.left!==o.left?e.left-o.left:e.leftMarker===o.leftMarker?0:e.leftMarker==="f"?-1:1);const i=[];for(const e of l)if(i.length===0)i.push({...e});else{const o=i[i.length-1];e.left<o.right||e.left===o.right&&(o.rightMarker==="f"||e.leftMarker==="f")?e.right>o.right?(o.right=e.right,o.rightMarker=e.rightMarker,o.rightStr=e.rightStr):e.right===o.right&&o.rightMarker==="o"&&e.rightMarker==="f"&&(o.rightMarker="f"):i.push({...e})}return i.length===1&&i[0].left===-1/0&&i[0].right===1/0?[["R"]]:i.length===0?[[]]:i.map(e=>[e.leftMarker,e.leftStr,e.rightMarker,e.rightStr])}intersectDomains(s,l){let i=[];return s.forEach(o=>{l.forEach(t=>{const f=this.intersectTwoIntervals(o,t);i.push(...f)})}),i.every(o=>o.length===4&&o[0]!=="R")&&(i=this.reduceUnionSqrt(i)),i}convertDomainToLatex(s){function l(e){return e==="+infty"?"+\\infty":e==="-infty"?"-\\infty":e}const i=[];for(const e of s)if(e.length===0)i.push("\\emptyset");else if(e[0]==="R"){const o=e.slice(1).map(l).join("\\,;\\,");i.push(`\\mathbb{R}\\setminus\\left\\{${o}\\right\\}`)}else if(e.length===4){const[o,t,f,c]=e,h=o==="f"?"\\left[":"\\left]",g=f==="f"?"\\right]":"\\right[",n=l(t),r=l(c);i.push(`${h}${n}\\,;\\,${r}${g}`)}else i.push(e.join("\\,;\\,"));return i.join(" \\cup ")}nouvelleVersion(){this.listeQuestions=[],this.listeCorrections=[],this.autoCorrection=[];const s=E({saisie:this.sup,min:1,max:7,melange:8,defaut:1,listeOfCase:["1/q","p/q","racineP","racineP/q","p/racineQ","racineP/racineQ","racineP+racineQ"],nbQuestions:this.nbQuestions,shuffle:!0}),l=w(s,this.nbQuestions);for(let i=0,e=0;i<this.nbQuestions&&e<50;){let o="",t="";o="Déterminer le domaine de définition de la fonction $f$ définie par $f(x) = ";let f,c,h,g,n="",r="",p,d,q,S;if(this.sup2===3?(q=x(1,2),S=x(1,2)):this.sup2===2?(q=2,S=2):(q=1,S=1),q===2&&S===2){do{const $=new v(x(-10,10,[0]),x(-10,10,[0])).simplifie(),a=new v(x(-10,10,[0]),x(-10,10,[0])).simplifie(),u=new v(x(-10,10,[0]),x(-10,10,[0])).simplifie(),y=new v(x(-10,10,[0]),x(-10,10,[0])).simplifie();h=b.aPartirDesSolutions($,a,new v($.den*a.den,1),{variable:"x",format:"reduit"}),g=b.aPartirDesSolutions(u,y,new v(u.den*y.den,1),{variable:"x",format:"reduit"})}while(h.equationTex===g.equationTex&&h.delta.signe!==1&&g.delta.signe!==1);f=h.polynomeFormeReduite(),c=g.polynomeFormeReduite(),p=h.solutionFrac(),d=g.solutionFrac()}else if(q===1&&S===2){do{const $=new v(x(-10,10,[0]),x(-10,10,[0])).simplifie(),a=new v(x(-10,10,[0]),x(-10,10,[0])).simplifie();h=b.aPartirDesSolutions($,a,new v($.den*a.den,1),{variable:"x",format:"reduit"})}while(h.delta.signe!==1);f=h.polynomeFormeReduite(),p=h.solutionFrac(),c=D.createRandomPolynome(1,1,2,"entier",["x"]),d=[this.solutionEq(c)]}else if(q===2&&S===1){do{const $=new v(x(-10,10,[0]),x(-10,10,[0])).simplifie(),a=new v(x(-10,10,[0]),x(-10,10,[0])).simplifie();g=b.aPartirDesSolutions($,a,new v($.den*a.den,1),{variable:"x",format:"reduit"})}while(g.delta.signe!==1);c=g.polynomeFormeReduite(),d=g.solutionFrac(),f=D.createRandomPolynome(1,1,2,"entier",["x"]),p=[this.solutionEq(f)]}else f=D.createRandomPolynome(1,1,2,"entier",["x"]),c=D.createRandomPolynome(1,1,2,"entier",["x"]),p=[this.solutionEq(f)],d=[this.solutionEq(c)];r=f.toString(),n=c.toString();const m=f.ordonner().monomes[0].coefficient,L=c.ordonner().monomes[0].coefficient;switch(l[i]){case"1/q":{const $=this.convertDomainToLatex(this.computeDomainePolynome("inverse",c,d));o+=`\\dfrac{1}{${n}}$`,t+=`La condition sur le domaine de définition est la suivante \\[${n}\\neq 0,\\] car le dénominateur d'une fraction ne peut pas valoir $0$. `,S===2?t+=`On détermine les valeurs qui annulent $${n}$. On obtient que ces valeurs sont $\\left\\{${d.map(a=>a.texFractionSimplifiee).join(",")}\\right\\}.$ `:t+=`La valeur qui annule $${n}$ est $${d.map(a=>a.texFractionSimplifiee).join(",")}.$ `,t+=`Ainsi, le domaine de définition est donné par
          \\[D_f=${F($)}\\]`}break;case"p/q":{const $=this.convertDomainToLatex(this.computeDomainePolynome("inverse",c,d));o+=`\\dfrac{${r}}{${n}}$`,t+=`La condition sur le domaine de définition est la suivante \\[${n}\\neq 0,\\] car le dénominateur d'une fraction ne peut pas valoir $0$. <br> Le numérateur n'influence pas le domaine de définition dans ce cas.`,S===2?t+=`On détermine les valeurs qui annulent $${n}$. On obtient que ces valeurs sont $\\left\\{${d.map(a=>a.texFractionSimplifiee).join(",")}\\right\\}.$ `:t+=`La valeur qui annule $${n}$ est $${d.map(a=>a.texFractionSimplifiee).join(",")}.$ `,t+=`Ainsi, le domaine de définition est donné par
          \\[D_f=${F($)}\\]`}break;case"racineP":{o+=`\\sqrt{${r}}$`;const $=this.convertDomainToLatex(this.computeDomainePolynome("sqrt",f,p));t+=`La condition sur le domaine de définition est la suivante : \\[${r}\\geq 0,\\] car la racine est définie sur les nombres positifs.
          <br>`,q===2?t+=`On détermine les valeurs qui annulent $${r}$. On obtient que ces valeurs sont $\\left\\{${p.map(a=>a.texFractionSimplifiee).join(",")}\\right\\}.$ Le coefficient dominant de $${r}$ est $${m.texFractionSimplifiee}${m.signe===1?">0":"<0"}$, donc la parabole associée est ${m.signe===1?"convexe":"concave"}. `:t+=`Le zéro de $${r}$ est $${p.map(a=>a.texFractionSimplifiee).join(",")}.$ La pente de $${r}$ est $${m.texFractionSimplifiee}${m.signe===1?">0":"<0"}$, donc la droite associée est ${m.signe===1?"croissante":"décroissante"}. `,t+=`Ainsi, $${r}$ est positif sur l'intervalle sur l'intervalle $${$}$, c'est également l'intervalle qui vérifie la première condition.<br> Le domaine de définition de $f$ correspond à l'intervalle déterminé '
          \\[D_f=${F($)}\\]`}break;case"racineP/q":{o+=`\\dfrac{\\sqrt{${r}}}{${n}}$`;const $=this.convertDomainToLatex(this.computeDomainePolynome("sqrt",f,p)),a=this.convertDomainToLatex(this.computeDomainePolynome("inverse",c,d));t+=`Les conditions sur le domaine de définition sont les suivantes : \\[\\text{Première condition : }${r}\\geq 0,\\] car la racine est définie sur les nombres positifs. \\[\\text{Deuxième condition : }${n}\\neq 0,\\] car le dénominateur ne peut pas valoir $0$.
          <br>`,q===2?t+=`On détermine les valeurs qui annulent $${r}$. On obtient que ces valeurs sont $\\left\\{${p.map(u=>u.texFractionSimplifiee).join(",")}\\right\\}.$ Le coefficient dominant de $${r}$ est $${m.texFractionSimplifiee}${m.signe===1?">0":"<0"}$, donc la parabole associée est ${m.signe===1?"convexe":"concave"}. `:t+=`Le zéro de $${r}$ est $${p.map(u=>u.texFractionSimplifiee).join(",")}.$ La pente de $${r}$ est $${m.texFractionSimplifiee}${m.signe===1?">0":"<0"}$, donc la droite associée est ${m.signe===1?"croissante":"décroissante"}. `,t+=`Ainsi, $${r}$ est positif sur l'intervalle sur l'intervalle $${$}$, c'est également l'intervalle qui vérifie la première condition.<br> On s'occupe à présent de la deuxième condition.   `,S===2?t+=`On détermine les valeurs qui annulent $${n}$. On obtient que ces valeurs sont $\\left\\{${d.map(u=>u.texFractionSimplifiee).join(",")}\\right\\}.$ `:t+=`Le zéro de $${n}$ est $${d.map(u=>u.texFractionSimplifiee).join(",")}.$ `,t+=`Ainsi, $${n}$ est différent de zéro sur l'intervalle $${a}$, c'est également l'intervalle qui vérifie la deuxième condition.<br> Le domaine de définition de $f$ correspond à l'intersection des deux intervalles 
          \\[D_f=${$.match("cup")?"\\left (\\,":""}${$}${$.match("cup")?"\\,\\right )":""}\\cap ${a.match("cup")?"\\left (\\,":""}${a}${a.match("cup")?"\\,\\right )":""}=${F(this.convertDomainToLatex(this.intersectDomains(this.computeDomainePolynome("inverse",c,d),this.computeDomainePolynome("sqrt",f,p))))}\\]`}break;case"p/racineQ":{o+=`\\dfrac{${r}}{\\sqrt{${n}}}$`;const $=this.convertDomainToLatex(this.computeDomainePolynome("invSqrt",c,d));t+=`La condition sur le domaine de définition est la suivante\\[${n}> 0,\\] car la racine est définie sur les nombres positifs et le dénominateur ne peut pas valoir $0$. Le numérateur n'influence pas le domaine de définition dans ce cas.
          <br>`,S===2?t+=`On détermine les valeurs qui annulent $${n}$. On obtient que ces valeurs sont $\\left\\{${d.map(a=>a.texFractionSimplifiee).join(",")}\\right\\}.$ Le coefficient dominant de $${n}$ est $${L.texFractionSimplifiee}${m.signe===1?">0":"<0"}$, donc la parabole associée est ${L.signe===1?"convexe":"concave"}. `:t+=`Le zéro de $${n}$ est $${d.map(a=>a.texFractionSimplifiee).join(",")}.$ La pente de $${n}$ est $${L.texFractionSimplifiee}${m.signe===1?">0":"<0"}$, donc la droite associée est ${L.signe===1?"croissante":"décroissante"}. `,t+=`Ainsi, $${n}$ est strictement positif sur l'intervalle $${$}$, c'est également l'intervalle qui vérifie la deuxième condition.<br> Le domaine de définition de $f$ est donc
          \\[D_f=${F($)}\\]`}break;case"racineP/racineQ":{const $=this.convertDomainToLatex(this.computeDomainePolynome("sqrt",f,p)),a=this.convertDomainToLatex(this.computeDomainePolynome("invSqrt",c,d));o+=`\\dfrac{\\sqrt{${r}}}{\\sqrt{${n}}}$`,t+=`Les conditions sur le domaine de définition sont les suivantes : \\[\\text{Première condition : }${r}\\geq 0,\\] car la racine est définie sur les nombres positifs. \\[\\text{Deuxième condition : }${n}> 0,\\] car la racine est définie sur les nombres positifs et le dénominateur ne peut pas valoir $0$.
          <br>`,q===2?t+=`On détermine les valeurs qui annulent $${r}$. On obtient que ces valeurs sont $\\left\\{${p.map(u=>u.texFractionSimplifiee).join(",")}\\right\\}.$ Le coefficient dominant de $${r}$ est $${m.texFractionSimplifiee}${m.signe===1?">0":"<0"}$, donc la parabole associée est ${m.signe===1?"convexe":"concave"}. `:t+=`Le zéro de $${r}$ est $${p.map(u=>u.texFractionSimplifiee).join(",")}.$ La pente de $${r}$ est $${m.texFractionSimplifiee}${m.signe===1?">0":"<0"}$, donc la droite associée est ${m.signe===1?"croissante":"décroissante"}. `,t+=`Ainsi, $${r}$ est positif sur l'intervalle sur l'intervalle $${$}$, c'est également l'intervalle qui vérifie la première condition.<br> On fait de même avec $${n}$.   `,S===2?t+=`On détermine les valeurs qui annulent $${n}$. On obtient que ces valeurs sont $\\left\\{${d.map(u=>u.texFractionSimplifiee).join(",")}\\right\\}.$ Le coefficient dominant de $${n}$ est $${L.texFractionSimplifiee}${m.signe===1?">0":"<0"}$, donc la parabole associée est ${L.signe===1?"convexe":"concave"}. `:t+=`Le zéro de $${n}$ est $${d.map(u=>u.texFractionSimplifiee).join(",")}.$ La pente de $${n}$ est $${L.texFractionSimplifiee}${m.signe===1?">0":"<0"}$, donc la droite associée est ${L.signe===1?"croissante":"décroissante"}. `,t+=`Ainsi, $${n}$ est strictement positif sur l'intervalle $${a}$, c'est également l'intervalle qui vérifie la deuxième condition.<br> Le domaine de définition de $f$ correspond à l'intersection des deux intervalles 
          \\[D_f=${$.match("cup")?"\\left (\\,":""}${$}${$.match("cup")?"\\,\\right )":""}\\cap ${a.match("cup")?"\\left (\\,":""}${a}${a.match("cup")?"\\,\\right )":""}=${F(this.convertDomainToLatex(this.intersectDomains(this.computeDomainePolynome("invSqrt",c,d),this.computeDomainePolynome("sqrt",f,p))))}\\]`}break;case"racineP+racineQ":{o+=`\\sqrt{${r}}+\\sqrt{${n}}$`;const $=this.convertDomainToLatex(this.computeDomainePolynome("sqrt",f,p)),a=this.convertDomainToLatex(this.computeDomainePolynome("sqrt",c,d));t+=`Les conditions sur le domaine de définition sont les suivantes : \\[\\text{Première condition : }${r}\\geq 0\\] \\[\\text{Deuxième condition : }${n}\\geq 0,\\] car la racine est définie sur les nombres positifs.
          <br>`,q===2?t+=`On détermine les valeurs qui annulent $${r}$. On obtient que ces valeurs sont $\\left\\{${p.map(u=>u.texFractionSimplifiee).join(",")}\\right\\}.$ Le coefficient dominant de $${r}$ est $${m.texFractionSimplifiee}${m.signe===1?">0":"<0"}$, donc la parabole associée est ${m.signe===1?"convexe":"concave"}. `:t+=`Le zéro de $${r}$ est $${p.map(u=>u.texFractionSimplifiee).join(",")}.$ La pente de $${r}$ est $${m.texFractionSimplifiee}${m.signe===1?">0":"<0"}$, donc la droite associée est ${m.signe===1?"croissante":"décroissante"}. `,t+=`Ainsi, $${r}$ est positif sur l'intervalle sur l'intervalle $${$}$, c'est également l'intervalle qui vérifie la première condition.<br> On fait de même avec $${n}$.   `,S===2?t+=`On détermine les valeurs qui annulent $${n}$. On obtient que ces valeurs sont $\\left\\{${d.map(u=>u.texFractionSimplifiee).join(",")}\\right\\}.$ Le coefficient dominant de $${n}$ est $${L.texFractionSimplifiee}${m.signe===1?">0":"<0"}$, donc la parabole associée est ${L.signe===1?"convexe":"concave"}. `:t+=`Le zéro de $${n}$ est $${d.map(u=>u.texFractionSimplifiee).join(",")}.$ La pente de $${n}$ est $${L.texFractionSimplifiee}${m.signe===1?">0":"<0"}$, donc la droite associée est ${L.signe===1?"croissante":"décroissante"}. `,t+=`Ainsi, $${n}$ est positif sur l'intervalle $${a}$, c'est également l'intervalle qui vérifie la deuxième condition.<br> Le domaine de définition de $f$ correspond à l'intersection des deux intervalles 
          \\[D_f=${$.match("cup")?"\\left (\\,":""}${$}${$.match("cup")?"\\,\\right )":""}\\cap ${a.match("cup")?"\\left (\\,":""}${a}${a.match("cup")?"\\,\\right )":""}=${F(this.convertDomainToLatex(this.intersectDomains(this.computeDomainePolynome("sqrt",c,d),this.computeDomainePolynome("sqrt",f,p))))}\\]`}break}this.listeQuestions.indexOf(o)===-1&&(this.listeQuestions.push(o),this.listeCorrections.push(t),i++),e++,P(this)}}}export{X as dateDePublication,ee as default,K as interactifReady,W as interactifType,Z as refs,J as titre,Y as uuid};
