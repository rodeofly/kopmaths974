import{g as S,a1 as B,a as G,r as v,a3 as I,p as J,k as H,A as K,T as L,j as N,o as P,D as Y,e as n,m as U,l as W}from"./embellissements-BYV7mIDn.js";import{R as Z}from"./RepereBuilder-bnSkEkR5.js";import{o as z}from"./colors-bl7PrqSM.js";import{c as _}from"./questionMathLive-DdRvWqlN.js";import{c as ee}from"./aleatoires-BLhzzHLc.js";import{E as te}from"./Exercice-DtXhjCyI.js";import"mathjs";import"decimal.js";import"katex";import"earcut";import"roughjs";import"./reperes-WwrVcExd.js";import"./tableauMathlive-xx-nDjq0.js";import"./index-BUDQz6-w.js";import"./canStore-DaSrd7sp.js";import"./generalStore-C3E9FHtR.js";import"seedrandom";import"./comparisonFunctions-B45ZZ3C7.js";import"./compute-engine.min.umd-BwAhpA7x.js";import"./Hms-u2AUyU1C.js";import"./ListeDeroulanteElement-CXmzV-cr.js";import"./sizeTools-DfTC1Dgv.js";import"./time-DMC-jnVL.js";import"./exerciseMethods-CtbYPwln.js";import"crypto-js";import"./gestionInteractif-DujZpSu8.js";import"./AjouteTableauMathlive-Bz24QHd3.js";import"./dateEtHoraires-yqKtvK1K.js";const Xe="Déterminer les coordonnées des sommets d’un parallélogramme",Ae="25/05/2025",Ie=!0,Le="mathLive",Ne="37e38",Pe={"fr-fr":["5G42-2"],"fr-ch":[]},se=[[[5,-2],[-1,3]],[[-3,4],[2,-1]],[[1,2],[3,-4]],[[-2,-3],[4,1]],[[2,-1],[-1,3]],[[-1,-4],[3,2]],[[4,3],[-2,1]],[[-3,-2],[1,4]]],ie=[[[3.5,-2],[1,2.5]],[[-2.5,4],[1.5,2.5]],[[4.5,1],[1.5,-2]],[[4,-1.25],[-2.5,3.75]],[[-1.5,-2.5],[3,1.5]],[[2.5,-1],[-1.5,3]],[[-2,3.5],[4,-1.5]],[[1.5,-3],[2,2.5]]];class Ye extends te{constructor(){super(),this.besoinFormulaireTexte=["Choix des questions",`Nombres séparés par des tirets :
1 : 4e sommet
2 : 3e sommet
3 : 2e sommet
4 : 1er sommet
5 : Mélange`],this.sup="1",this.besoinFormulaire2CaseACocher=["Avec des fractions",!1],this.sup2=!1,this.besoinFormulaire3CaseACocher=["Avec des relatifs",!1],this.sup3=!1,this.besoinFormulaire4CaseACocher=["Avec les côtés tracés",!1],this.sup4=!1,this.nbQuestions=2,this.correctionDetaillee=!0,this.correctionDetailleeDisponible=!0}nouvelleVersion(){const F=S({saisie:this.sup,min:1,max:4,melange:5,defaut:1,nbQuestions:this.nbQuestions}).map(Number);for(let g=0,T=0;g<this.nbQuestions&&T<50;){let q="",d="";const s=ee(5,"QOX",!0),f=s[0]+s[1]+s[2]+s[3],C=[],j=[],D=this.sup2,x=this.sup3,R=this.sup4,b=F[g],t=[];let l,c,r;do{const e=G(D?ie:se),i=v(0,1),a=v(0,1);l=I(e[i][a],e[i][1-a]),c=I(e[1-i][a],e[1-i][1-a]),D?Number.isInteger(l.x*2)&&Number.isInteger(l.y*2)&&Number.isInteger(c.x*2)&&Number.isInteger(c.y*2)?r=2:r=4:r=1}while(B(l.x*c.y-l.y*c.x,0,1e-7));t.push({x:0,y:0,nom:s[0],visible:b!==4,p:null}),t.push({x:l.x,y:l.y,nom:s[1],visible:b!==3,p:null}),t.push({x:l.x+c.x,y:l.y+c.y,nom:s[2],visible:b!==2,p:null}),t.push({x:c.x,y:c.y,nom:s[3],visible:b!==1,p:null});let u,m,M,y;if(u=Math.min(...t.map(e=>e.x)),m=Math.min(...t.map(e=>e.y)),M=Math.max(...t.map(e=>e.x)),y=Math.max(...t.map(e=>e.y)),x){const e=v(-2*r,2*r,0)/r,i=v(-2*r,2*r,0)/r;t.forEach(a=>{a.x+=e,a.y+=i}),u+=e,m+=i,M+=e,y+=i}else{const e=u<=0?-u+v(0,2*r)/r:0,i=m<=0?-m+v(0,2*r)/r:0;t.forEach(a=>{a.x+=e,a.y+=i}),u+=e,m+=i,M+=e,y+=i}for(let e=0;e<4;e++)t[e].p=J(t[e].x,t[e].y,t[e].nom);const w=new Z({xMin:Math.min(Math.floor(u-1),0),yMin:Math.min(Math.floor(m-1),0),xMax:Math.max(Math.ceil(M+1)+.5,1.5),yMax:Math.max(Math.ceil(y+1)+.5,1.5)}).setThickX({xMin:x?u-1.1:0,xMax:M+1.1,dx:1}).setThickY({yMin:x?m-1.1:0,yMax:y+1.1,dy:1}).setGrille({grilleX:{xMin:x?Math.floor(u-1):0,xMax:Math.ceil(M+1),dx:1},grilleY:{yMin:x?Math.floor(m-1):0,yMax:Math.ceil(y+1),dy:1}});D&&w.setGrilleSecondaire({grilleX:{xMin:x?Math.floor(u-1):0,xMax:Math.ceil(M+1),dx:1/r},grilleY:{yMin:x?Math.floor(m-1):0,yMax:Math.ceil(y+1),dy:1/r}});const E=w.buildCustom();if(C.push(E),j.push(E),R){for(let e=0;e<4;e++)if(t[e%4].visible&&t[(e+1)%4].visible){const i=t[e].p,a=t[(e+1)%4].p;i!=null&&a!=null&&C.push(H(i,a))}}const k=t.map(e=>e.p).filter(e=>e!==null),X=k.map((e,i)=>t[i].visible?e:null).filter(e=>e!==null),o=k.find((e,i)=>!t[i].visible),V=K(...k),Q=L(...X);Q.epaisseur=2;const O={x:(t[0].x+t[2].x)/2,y:(t[0].y+t[2].y)/2},A=X.map(e=>N(e.nom,e.x+.3*(e.x>O.x?1:-1),e.y+.3*(e.y>O.y?1:-1),{color:"black",letterSize:"small"}));if(C.push(Q,A),j.push(Q,A,V),o){const e=L(o,z);e.epaisseur=2,j.push(e,N(o.nom,o.x+.3*(o.x>O.x?1:-1),o.y+.3*(o.y>O.y?1:-1),{color:z,letterSize:"small"}))}if(q+=`Dans le repère ci-dessous, donner les coordonnées du sommet $${s[4-b]}$ du parallélogramme $${f}$.`,o){if(q+=_({exercice:this,question:g,typeInteractivite:"fillInTheBlank",content:`${o.nom}(%{champ1}~;~%{champ2})`,objetReponse:{champ1:{value:o.x},champ2:{value:o.y}}}),q+=P(Object.assign({pixelsParCm:30},Y(C)),C),d+=P(Object.assign({pixelsParCm:30},Y(j)),j),this.correctionDetaillee){let e,i,a="",p="",$="",h="";switch(b){case 1:e=t[2].x-t[1].x,i=t[2].y-t[1].y,$=e>0?"droite":"gauche",h=i>0?"haut":"bas",a=Math.abs(e)>1?"s":"",p=Math.abs(i)>1?"s":"",d+=`Les segments $[${s[0]}${s[3]}]$ et $[${s[1]}${s[2]}]$ sont parallèles, de même longueur et $${f}$ est un quadrilatère non croisé.<br>
              On peut donc compter les déplacements horizontaux et verticaux à partir de $${s[1]}$ jusqu'à $${s[2]}$, puis reproduire les mêmes déplacements à partir de $${s[0]}$.<br>
              On se déplace de $${n(Math.abs(e),2)}$ unité${a} vers la ${$}, et de $${n(Math.abs(i),2)}$ unité${p} vers le ${h}.<br>`;break;case 2:e=t[3].x-t[0].x,i=t[3].y-t[0].y,$=e>0?"droite":"gauche",h=i>0?"haut":"bas",a=Math.abs(e)>1?"s":"",p=Math.abs(i)>1?"s":"",d+=`Les segments $[${s[0]}${s[1]}]$ et $[${s[2]}${s[3]}]$ sont parallèles, de même longueur et $${f}$ est un quadrilatère non croisé.<br>
              On peut donc compter les déplacements horizontaux et verticaux à partir de $${s[0]}$ jusqu'à $${s[1]}$, puis reproduire les mêmes déplacements à partir de $${s[2]}$.<br>
              On se déplace de $${n(Math.abs(e),2)}$ unité${a} vers la ${$}, et de $${n(Math.abs(i),2)}$ unité${p} vers le ${h}.<br>`;break;case 3:e=t[1].x-t[0].x,i=t[1].y-t[0].y,$=e>0?"droite":"gauche",h=i>0?"haut":"bas",a=Math.abs(e)>1?"s":"",p=Math.abs(i)>1?"s":"",d+=`Les segments $[${s[0]}${s[2]}]$ et $[${s[1]}${s[3]}]$ sont parallèles, de même longueur et $${f}$ est un quadrilatère non croisé.<br>
              On peut donc compter les déplacements horizontaux et verticaux à partir de $${s[0]}$ jusqu'à $${s[2]}$, puis reproduire les mêmes déplacements à partir de $${s[1]}$.<br>
              On se déplace de $${n(Math.abs(e),2)}$ unité${a} vers la ${$}, et de $${n(Math.abs(i),2)}$ unité${p} vers le ${h}.<br>`;break;case 4:e=t[3].x-t[2].x,i=t[3].y-t[2].y,$=e>0?"droite":"gauche",h=i>0?"haut":"bas",a=Math.abs(e)>1?"s":"",p=Math.abs(i)>1?"s":"",d+=`Les segments $[${s[0]}${s[3]}]$ et $[${s[1]}${s[2]}]$ sont parallèles, de même longueur et $${f}$ est un quadrilatère non croisé.<br>
              On peut donc compter les déplacements horizontaux et verticaux à partir de $${s[0]}$ jusqu'à $${s[3]}$, puis reproduire les mêmes déplacements à partir de $${s[1]}$.<br>
              On se déplace de $${n(Math.abs(e),2)}$ unité${a} vers la ${$}, et de $${n(Math.abs(i),2)}$ unité${p} vers le ${h}.<br>`;break}}d+=`Les coordonnées du sommet $${s[4-b]}$ sont : $${U(`(~${n(o.x,2)}~;~${n(o.y,2)}~)`)}$.`}this.questionJamaisPosee(g,f)&&(this.listeQuestions.push(q),this.listeCorrections.push(d),g++),T++,W(this)}}}export{Ae as dateDePublication,Ye as default,Ie as interactifReady,Le as interactifType,Pe as refs,Xe as titre,Ne as uuid};
