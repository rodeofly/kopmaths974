import{g as W,p as a,r as f,ai as L,a as v,T as O,aa as F,ah as B,k as y,P as Z,bf as _,I as N,a2 as X,aH as ee,o as se,D as te}from"./embellissements-BYV7mIDn.js";import{c as ie}from"./questionMathLive-DdRvWqlN.js";import{M as oe}from"./Matrice-C65I2nuw.js";import{c as re}from"./aleatoires-BLhzzHLc.js";import{E as ae}from"./Exercice-DtXhjCyI.js";import"mathjs";import"decimal.js";import"katex";import"earcut";import"roughjs";import"./tableauMathlive-xx-nDjq0.js";import"./index-BUDQz6-w.js";import"./canStore-DaSrd7sp.js";import"./generalStore-C3E9FHtR.js";import"seedrandom";import"./comparisonFunctions-B45ZZ3C7.js";import"./compute-engine.min.umd-BwAhpA7x.js";import"./Hms-u2AUyU1C.js";import"./ListeDeroulanteElement-CXmzV-cr.js";import"./sizeTools-DfTC1Dgv.js";import"./time-DMC-jnVL.js";import"./exerciseMethods-CtbYPwln.js";import"crypto-js";import"./gestionInteractif-DujZpSu8.js";import"./AjouteTableauMathlive-Bz24QHd3.js";import"./dateEtHoraires-yqKtvK1K.js";const Ce=!0,Ke="mathLive",Le="2c20c",Oe="Lire des coordonnées en repère orthogonal, normé ou quelconque",Ne={"fr-fr":["2G12-6"],"fr-ch":["9FA1-10","10FA5-21"]};class Re extends ae{constructor(){super(),this.nbQuestions=1,this.besoinFormulaireTexte=["Type de repère",["Nombres séparés par des tirets  :","1 : Orthogonal","2 : Normé","3 : Quelconque","4 : Mélange"].join(`
`)],this.sup="1",this.besoinFormulaire2CaseACocher=["Présence de coordonnées fractionnaires",!1],this.sup2=!1,this.besoinFormulaire3Numerique=["Nombre de points à trouver/placer",3],this.sup3=3,this.besoinFormulaire4CaseACocher=["Papier pointé / Quadrillage",!1],this.sup4=!1,this.comment=`Exercice fait suite à une demande sur la forge de Carole Feugère.<br> Il y a trois types de repères, le premier est orthogonal mais pas normé, le deuxième est normé mais pas orthonormal, le troisième n'est ni normé ni orthogonal.<br>
    Les points à trouver sont choisis aléatoirement à coordonnées entières. On peut choisir le nombre de points à trouver de 1 à 3.`}nouvelleVersion(){const Y=W({saisie:this.sup,min:1,max:3,melange:4,nbQuestions:this.nbQuestions,defaut:4}),n=[],o=[],I=[],A=[],$=[],x=[];for(let s=0;s<this.nbQuestions;){n[s]=[],o[s]=[],I[s]=[],A[s]=[],x[s]=[],$[s]=[];let c,m,p,R;const M=re(3+this.sup3),[j,D,P]=M.slice(0,3);$[s]=M.slice(3);const l=a(0,0,P,"below left");do{switch(Y[s]){case 1:c=[v([1.5,2.5]),0],m=[0,v([1,2])];break;case 2:{const e=L(a(f(6,8)*.2,0),l,f(-20,20),1);c=[e.x,e.y];const t=L(a(...c),l,f(60,80),1);m=[t.x,t.y]}break;case 3:default:{c=[1.5,f(-4,4,[0])*.2];const e=L(a(...c),l,f(60,80),v([.6,.7,1.25,1.3,1.4]));m=[e.x,e.y]}break}p=new oe([[c[0],m[0]],[c[1],m[1]]]),R=p.inverse()}while(p==null||R==null);const Q=a(c[0],c[1],j,"below"),T=a(m[0],m[1],D,"left"),w=O(l,Q,T);w.style=".",w.epaisseur=1;const S=F(Q,l,4),k=F(T,l,3),G=B(S,l,180),J=B(k,l,180),C=y(G,F(S,l,1.05));C.epaisseur=1.5,C.styleExtremites="->";const K=y(J,F(k,l,1.1));K.epaisseur=1.5,K.styleExtremites="->";const u=[];let h=1,d=1;this.sup2&&(h=v([1,2,3]),d=v([1,2,3],[h]));for(let e=-4;e<4+1/h;e+=1/h){if(this.sup4){const t=a(...p.multiply([e,-3]).toArray()),i=a(...p.multiply([e,3]).toArray());Math.abs(e)>.01&&u.push(y(t,i))}for(let t=-3;t<3+1/d;t+=1/d){if(this.sup4&&e===-4){const i=a(...p.multiply([-4,t]).toArray()),r=a(...p.multiply([4,t]).toArray());Math.abs(t)>.01&&u.push(y(i,r))}if(!this.sup4)if(Math.abs(e)>.1&&Math.abs(t)>.1)u.push(a(...p.multiply([e,t]).toArray()));else{const[i,r]=p.multiply([e,t]).toArray();if(Math.abs(i)<.1){const g=y(i-.1,r,i+.1,r);g.epaisseur=1.5,Math.abs(r)>.1&&u.push(g)}if(Math.abs(r)<.1){const g=y(i,r-.1,i,r+.1);g.epaisseur=1.5,Math.abs(i)>.1&&u.push(g)}}}}const b=this.sup4?u:O(...u.filter(e=>e instanceof Z)),V=this.sup4?[]:u.filter(e=>e instanceof _);if(this.sup4)for(const e of b)e.styleExtremites="-",e.epaisseur=.5,e.color=N("gray"),e.opacite=.6;else b.style=".",b.epaisseur=.4,b.opacite=.6,b.color=N("gray");for(let e=0;e<this.sup3;e++){do n[s][e]=X(f(-3*h,3*h),h),o[s][e]=X(f(-2*d,2*d),d);while(n[s][e].isEqual(0)&&o[s][e].isEqual(1)||n[s][e].isEqual(1)&&o[s][e].isEqual(0)||n[s][e].isEqual(0)&&o[s][e].isEqual(0)||n[s].slice(0,e).map(r=>r.num).includes(n[s][e].num)&&o[s].slice(0,e).map(r=>r.num).includes(o[s][e].num));const[t,i]=p.multiply([n[s][e].valeurDecimale,o[s][e].valeurDecimale]).toArray();I[s][e]=t,A[s][e]=i,x[s][e]=a(t,i,M[3+e],`${n[s][e].valeurDecimale<0?o[s][e].valeurDecimale<0?"below left":"above left":o[s][e].valeurDecimale?"below right":"above right"}`)}const q=O(...x[s]);q.style="x",q.epaisseur=2,q.color=N("black");const z=ee(l,Q,T,...x[s]),H=[q,w,z,C,K,b,V];let E=se(Object.assign({scale:.5},te(H)),H);E+=`Quelles sont les coordonnées des points $${$[s].join("$, $")}$ dans le repère $(${P},${j},${D})$ ?<br>`,this.interactif?E+=$[s].map((e,t)=>`Coordonnées de $${e}$ : ${ie({exercice:this,question:s*this.sup3+t,typeInteractivite:"fillInTheBlank",objetReponse:{champ1:{value:n[s][t].texFractionSimplifiee},champ2:{value:o[s][t].texFractionSimplifiee},bareme:i=>[Math.min(...i),1]},content:"(%{champ1}~~;~~%{champ2})"})}`).join("<br>"):E+=$[s].map(e=>`Coordonnées de $${e}$ : $(\\ldots~~;~~\\ldots)$`).join("<br>");const U=`Dans le repère $(${P},${j},${D})$ sont :<br>
            $${x[s].map((e,t)=>`${M[t+3]}(${n[s][t].texFractionSimplifiee};${o[s][t].texFractionSimplifiee})`).join(", ")}$`;this.questionJamaisPosee(s,...I[s],...A[s],...c,...m)&&(this.listeQuestions[s]=E,this.listeCorrections[s]=U,s++)}}}export{Re as default,Ce as interactifReady,Ke as interactifType,Ne as refs,Oe as titre,Le as uuid};
