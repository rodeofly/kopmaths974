import{create as u,fractionDependencies as c,zerosDependencies as p,transposeDependencies as m,subsetDependencies as h,parseDependencies as l,multiplyDependencies as _,matrixDependencies as f,invDependencies as x,indexDependencies as D,divideDependencies as y,detDependencies as g,addDependencies as v}from"mathjs";import{U as d}from"./embellissements-BYV7mIDn.js";const A={epsilon:1e-12,matrix:"Array",number:"Fraction",precision:64,predictable:!1,randomSeed:null},t=u({addDependencies:v,detDependencies:g,divideDependencies:y,indexDependencies:D,invDependencies:x,matrixDependencies:f,multiplyDependencies:_,parseDependencies:l,subsetDependencies:h,transposeDependencies:m,zerosDependencies:p,fractionDependencies:c},A);class s{constructor(e){this._data=Array.isArray(e)?e:t.zeros(e,e).valueOf(),this.dim=this._data.length}determinant(){return t.det(this._data)}inverse(){return t.det(this._data)!==0?i(t.inv(this._data)):new s(t.zeros(this.dim,this.dim).valueOf())}subset(e,n){const r=t.subset(this._data,t.index(e,n));return typeof r=="number"?r:i(r)}getValue(e,n){return t.subset(this._data,t.index(e,n))}transpose(){return i(t.transpose(this._data))}multiply(e){const n=e._data??e,r=t.multiply(this._data,n);return Array.isArray(r)?i(r):r}add(e){return i(t.add(this._data,e))}divide(e){return i(t.divide(this._data,e))}toTex(){return t.parse(this.toString()).toTex().replaceAll("bmatrix","pmatrix")}toArray(){return this._data}toString(){return"["+this._data.map(e=>"["+e.join(",")+"]").join(",")+"]"}texDet(){let e="";for(let n=0;n<this._data.length;n++)e+=`${this._data[n].join(" & ")}`,n<this._data.length-1&&(e+="\\\\");return`\\begin{vmatrix}
${e}
\\end{vmatrix}`}reduite(e,n){const r=d(0,this.dim-1,e),o=d(0,this.dim-1,n);return i(t.subset(this._data,t.index(r,o)))}}function i(a){if(Array.isArray(a)||typeof a=="number")return new s(a);if(a._data!=null)return new s(a._data);throw new Error("Invalid argument for matrice()")}export{s as M,i as m};
