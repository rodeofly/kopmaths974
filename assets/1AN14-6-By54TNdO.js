import{e as f,a as M}from"./comparisonFunctions-B45ZZ3C7.js";import{h as Q}from"./gestionInteractif-DujZpSu8.js";import{a as S}from"./questionMathLive-DdRvWqlN.js";import{P as p}from"./Polynome-BIt5zaQj.js";import{g as L,r as P,F as h,f as O,m as b,t as N,l as V}from"./embellissements-BYV7mIDn.js";import{T as X}from"./Trinome-CS3WnuMQ.js";import{E as j}from"./Exercice-DtXhjCyI.js";import"./compute-engine.min.umd-BwAhpA7x.js";import"./index-BUDQz6-w.js";import"mathjs";import"decimal.js";import"./Hms-u2AUyU1C.js";import"./ListeDeroulanteElement-CXmzV-cr.js";import"./tableauMathlive-xx-nDjq0.js";import"./canStore-DaSrd7sp.js";import"./generalStore-C3E9FHtR.js";import"seedrandom";import"katex";import"earcut";import"roughjs";import"./sizeTools-DfTC1Dgv.js";import"./time-DMC-jnVL.js";import"./exerciseMethods-CtbYPwln.js";import"crypto-js";import"./AjouteTableauMathlive-Bz24QHd3.js";const xe="Dériver $\\dfrac{u}{v}$",fe="22/01/2022",be="07/05/2024",ve=!0,ye="mathLive",he="b32f2",Ne={"fr-fr":["1AN14-6"],"fr-ch":[]};class qe extends j{constructor(){super(),this.besoinFormulaireTexte=["Types de fonctions : ",`Nombres séparés par des tirets :
1 : (ax+b)/(cx+d)
2 : ax^n/(cx+d)
3 : (ax²+bx+c)/(ex+f)
4 ax^n/(ax²+bx+c)
5 : Mélange`],this.besoinFormulaire2CaseACocher=["Montrer que... (non interactif)",!1],this.consigne="Pour chacune des fonctions suivantes, déterminer l'expression de sa fonction dérivée.",this.nbQuestions=5,this.nbCols=2,this.nbColsCorr=2,this.sup="5",this.sup2=!1}nouvelleVersion(){const q=[];this.sup2?this.interactifReady=!1:this.interactifReady=!0;const g=L({saisie:this.sup,nbQuestions:this.nbQuestions,listeOfCase:["poly1a/poly1","mon/poly1","poly/poly1","mon/poly2centre"],min:1,max:4,melange:5,defaut:1}).map(String);for(let $=0,D=0;$<this.nbQuestions&&D<50;){let c="",e="",v="",l="";const y=new Array(P(2,9));y.fill(0),y.push(1);const I={exp:"e^x",mon:new p({coeffs:y}),poly1:new p({rand:!0,deg:1}),poly1a:new p({rand:!0,deg:1}),poly2centre:new p({rand:!0,coeffs:[[10,!0],0,[10,!0]]}),poly:new p({rand:!0,deg:2}),monome2:new p({rand:!0,coeffs:[0,0,[10,!0]]}),racine:"sqrt(x)"},C=g[$].split("/"),w=C[0],F=C[1],r=I[w],s=I[F],x=f.parse(["pol","mon"].includes(w.substr(0,3))?r.toMathExpr():r),i=f.parse(["pol","mon"].includes(F.substr(0,3))?s.toMathExpr():s);v=`(${x.latex})/(${i.latex})`;const a=["f","g","h","l","m","p","r","s","t","u","v","w","b","c","d","e"][$%16];c="",c+=`$${a}(x)=${f.parse(v).simplify().latex}$`;const R=f.box(["D",x,"x"]).evaluate(),E=f.box(["D",i,"x"]).evaluate();e="",e+="On rappelle le cours : si $u,v$ sont  deux fonctions dérivables sur un même intervalle $I$, et que $v$ ne s'annule pas sur $I$ alors leur quotient est dérivable sur $I$ et on a la formule : ",e+="\\[\\left(\\frac{u}{v}\\right)'=\\frac{u'\\times v-u\\times v'}{v^2}.\\]",e+=`Ici $${a}=\\frac{u}{v}$ avec : `,e+=`\\[\\begin{aligned}u(x)&=${x.latex},\\ u'(x)=${R.latex}\\\\ v(x)&=${i.latex},\\ v'(x)=${E.latex}.\\end{aligned}\\]`;let m="";switch(g[$]){case"poly1a/poly1":case"poly/poly1":{const t=s.monomes[1],o=s.monomes[0],n=new h(-o,Number(t));if(n==null&&window.notify("Erreur dans la détermination de l'ensemble de dérivation",{c:t,d:o}),m=`\\R\\backslash\\{${n.texFractionSimplifiee}\\}`,e+=`Ici la formule ci-dessus est applicable pour tout $x$ tel que $${i.latex}\\neq 0$. C'est-à-dire $x\\neq${n.texFractionSimplifiee}$.<br>`,e+="On obtient alors : ",Number(r.deg)===1){const u=r.monomes[1],d=r.monomes[0];e+=`\\[${a}'(x)=\\frac{${u}(${i.latex})-(${x.latex})\\times${Number(t)<0?`(${t})`:t}}{(${i.latex})^2}.\\]`,e+="D'où, en développant le numérateur : ",e+=`\\[${a}'(x)=\\frac{${s.multiply(u)}-(${r.multiply(t)})}{(${i.latex})^2}.\\]`,e+="Les termes en $x$ se compensent et on obtient : ",e+=`\\[${a}'(x)=\\frac{${Number(u)*Number(o)}${O(-t*Number(d))}}{(${i.latex})^2}.\\]`,e+="C'est-à-dire : ",e+=`$${b(`${a}'(x)=\\frac{${Number(u)*Number(o)-Number(t)*Number(d)}}{(${i.latex})^2}`)}$.`,l=`\\frac{${Number(u)*Number(o)-Number(t)*Number(d)}}{(${i.latex})^2}`}else if(r.deg===2){e+=`\\[${a}'(x)=\\frac{(${r.derivee()})(${i.latex})-(${x.latex})\\times${Number(t)<0?`(${t})`:t}}{(${i.latex})^2}.\\]`,e+="D'où, en développant le numérateur : ";const u=r.derivee().multiply(s);e+=`\\[${a}'(x)=\\frac{${u}-(${r.multiply(t)})}{(${i.latex})^2}.\\]`,e+="On réduit le numérateur pour obtenir : ",l=`\\frac{${u.add(r.multiply(-t))}}{(${i.latex})^2}`,e+=`$${b(`${a}'(x)=${l}`)}$.<br>`,e+=`${N("Remarque :","black")} la plupart du temps, on veut le signe de la dérivée. Il serait donc plus logique de factoriser le numérateur si possible, mais cela sort du cadre de cet exercice.`}break}case"mon/poly2centre":{const t=s.monomes[2],o=s.monomes[0];m="\\R";const n=s.derivee().toLatex();if(Number(t)*Number(o)>0)e+=`Ici la formule ci-dessus est applicable pour tout $x$ car $${i.latex}${Number(t)<0?"<0":">0"}$ pour tout $x$.<br>`;else{const u=new X(Number(t),0,Number(o)),[d,k]=[u.texX1,u.texX2];m=`\\R\\backslash\\{${d};${k}\\}`;const T=d,A=k;e+=`Ici la formule ci-dessus est applicable pour tout $x$ tel que $${i.latex}\\neq 0$. C'est-à-dire $x\\neq${T}$ et $x\\neq${A}$.<br>`}e+="On obtient alors : ",e+=`\\[${a}'(x)=\\frac{${r.derivee()}(${s})-${r}\\times${n.startsWith("-")?`(${n})`:`${n}`}}{(${i.latex})^2}.\\]`,e+="D'où, en développant le numérateur : ",e+=`\\[${a}'(x)=\\frac{${r.derivee().multiply(s)}${r.multiply(s.derivee().multiply(-1)).toMathExpr(!0)}}{(${i.latex})^2}.\\]`,e+="On simplifie pour obtenir :",l=`\\frac{${r.derivee().multiply(s).add(r.multiply(s.derivee().multiply(-1)))}}{(${i.latex})^2}`,e+=`$${b(`${a}'(x)=${l}.`)}$.<br>`,e+=`${N("Remarque :","black")} la plupart du temps, on veut le signe de la dérivée. Il serait donc plus logique de factoriser le numérateur, mais cela sort du cadre de cet exercice.`}break;case"mon/poly1":{const t=s.monomes[1],o=s.monomes[0],n=new h(-o,Number(t));m=`\\R\\backslash\\{${n.texFractionSimplifiee}\\}`,e+=`Ici la formule ci-dessus est applicable pour tout $x$ tel que $${i.latex}\\neq 0$. C'est-à-dire $x\\neq${n.texFractionSimplifiee}$.<br>`,e+="On obtient alors : ",e+=`\\[${a}'(x)=\\frac{${r.derivee()}(${s})-${r}\\times${Number(t)<0?`(${t})`:t}}{(${i.latex})^2}.\\]`,e+="D'où, en développant le numérateur : ",e+=`\\[${a}'(x)=\\frac{${r.derivee().multiply(s)}${r.multiply(-t).toMathExpr(!0)}}{(${i.latex})^2}.\\]`,e+="On simplifie pour obtenir :",l=`\\frac{${r.derivee().multiply(s).add(r.multiply(-t))}}{(${i.latex})^2}`,e+=`$${b(`${a}'(x)=${l}`)}$.<br>`,e+=`${N("Remarque :","black")} la plupart du temps, on veut le signe de la dérivée. Il serait donc plus logique de factoriser le numérateur, mais cela sort du cadre de cet exercice.`;break}case"exp/poly1":{const t=s.monomes[1],o=s.monomes[0],n=new h(-o,Number(t));m=`\\R\\backslash\\{${n.texFractionSimplifiee}\\}`,e+=`Ici la formule ci-dessus est applicable pour tout $x$ tel que $${i.latex}\\neq 0$. C'est-à-dire $x\\neq${n.texFractionSimplifiee}$.<br>`,e+="On obtient alors : ",e+=`\\[${a}'(x)=\\frac{${r}(${s})-${r}\\times${Number(t)<0?`(${t})`:t}}{(${i.latex})^2}.\\]`,e+="On factorise par $e^x$, et on obtient : ",e+=`\\[${a}'(x)=\\frac{${r}(${s}${O(-t)})}{(${i.latex})^2},\\]`,e+="ce qui donne, après réduction : ",l=`\\frac{${r}(${p.print([Number(o)-Number(t),Number(t)])})}{(${i.latex})^2}`,e+=`$${b(`${a}'(x)=${l}`,"black")}$.`;break}default:e+="TODO",m="\\R";break}c=c.replaceAll("\\frac","\\dfrac"),this.sup2?c+=`<br>Montrer que $${a}^\\prime(x)=${l.replaceAll("\\frac","\\dfrac")}$`:c=`Donner l'expression de la dérivée de $${a}$ définie pour tout $x\\in${m}$ par : `+c,e=e.replaceAll("\\frac","\\dfrac"),this.interactif&&!this.sup2&&(c+="<br><br>"+S(this,$,"",{texteAvant:`$${a}'(x)=$`})),q.indexOf(v)===-1&&(q.push(v),this.listeQuestions[$]=c,this.listeCorrections[$]=e,Q(this,$,{reponse:{value:l,compare:M}}),$++),D++}V(this)}}export{be as dateDeModifImportante,fe as dateDePublication,qe as default,ve as interactifReady,ye as interactifType,Ne as refs,xe as titre,he as uuid};
