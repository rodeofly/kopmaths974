import{c as pe}from"./compute-engine.min.umd-BwAhpA7x.js";import{number as me}from"mathjs";import $ from"decimal.js";import{b as de,e as K,dm as j}from"./embellissements-BYV7mIDn.js";import{H as T}from"./Hms-u2AUyU1C.js";class S{mesureDecimal;unite;puissanceUnite;uniteDeReference;prefixe;puissancePrefixe;constructor(e,r){this.mesureDecimal=e instanceof $?e:new $(e),this.unite=r;const t=z(r);this.puissanceUnite=t.puissanceUnite,this.uniteDeReference=t.uniteDeReference,this.prefixe=t.prefixe,this.puissancePrefixe=t.puissancePrefixe}get mesure(){return this.mesureDecimal.toNumber()}set mesure(e){this.mesureDecimal=new $(e)}convertirEn(e){const r=z(e);if(U(this.unite)&&U(e)){const t=be(this.mesureDecimal,this.unite),n=ke(t,e);return new S(n,e)}if(q(this.unite)&&q(e)){const t=H(this.mesureDecimal,this.unite),n=he(t,e);return new S(n,e)}if(r.puissanceUnite===this.puissanceUnite&&r.uniteDeReference===this.uniteDeReference){const t=new $(this.puissancePrefixe).minus(r.puissancePrefixe).times(this.puissanceUnite),n=new $(10).pow(t);return new S(this.mesureDecimal.times(n),e)}else if(r.uniteDeReference==="m^3"&&this.uniteDeReference==="L"){const t=new $(this.puissancePrefixe).minus(r.puissancePrefixe).minus(3).times(this.puissanceUnite),n=new $(10).pow(t);return new S(this.mesureDecimal.times(n),"L")}else if(r.uniteDeReference==="L"&&this.uniteDeReference==="m^3"){const t=new $(this.puissancePrefixe).times(this.puissanceUnite).plus(3),n=new $(10).pow(t);return new S(this.mesureDecimal.times(n),"m^3")}else if(r.uniteDeReference==="m^2"&&this.uniteDeReference==="a"){const t=new $(this.puissancePrefixe).plus(2),n=new $(10).pow(t);return new S(this.mesureDecimal.times(n),"m^2")}else if(r.uniteDeReference==="a"&&this.uniteDeReference==="m^2"){const t=new $(this.puissancePrefixe).times(this.puissanceUnite).minus(2),n=new $(10).pow(t);return new S(this.mesureDecimal.times(n),"a")}else throw new Error(`Conversion impossible de ${this.unite} en ${e}`)}estEgal(e){if(e.uniteDeReference!==this.uniteDeReference)return!1;try{const r=this.convertirEn(this.uniteDeReference),t=e.convertirEn(this.uniteDeReference);return r&&t?r.mesure===t.mesure:!1}catch(r){return console.error(r),!1}}estUneApproximation(e,r){if(e.uniteDeReference!==this.uniteDeReference)return!1;try{let t,n;return this.puissancePrefixe>e.puissancePrefixe?(t=this.convertirEn(e.unite),n=e):(t=this.convertirEn(this.unite),n=e.convertirEn(this.unite)),t!==void 0&&n!==void 0?Math.abs(t.mesure-n.mesure)<=r:!1}catch(t){return console.error(t),!1}}toString(e=12){if(this.unite==="hhmmss")return W(this.mesureDecimal);const r=String(this.mesure).split(".")[1]?.length;return r<e&&(e=r),`${de(this.mesure,e).replace(".",",")} ${this.unite}`}toTex(e=12){if(q(this.unite)){const r=H(this.mesureDecimal,this.unite);return ge(r)}return`${K(this.mesure,e).replace(".",",")}~\\text{${this.unite}}`}get latexUnit(){return U(this.unite)||q(this.unite)?`\\text{${this.unite}}`:`\\text{${this.prefixe}${this.uniteDeReference.split("^")[0]}}${this.puissanceUnite===1?"":`^{${this.puissanceUnite.toString()}}`}`}static fromString(e){e=e.replace("\\,",""),e=e.replace("~",""),e=e.replace(",","."),e=e.replace(" ",""),e=e.replace(/\\text{([^}]+)}/g,"$1");const r=parseFloat(e),t=e.replace(String(r),"");return new S(r,t)}static fromHHMMSS(e){const r=Oe(e);return new S(r,"hhmmss")}toHHMMSS(){if(!q(this.unite))throw new Error(`Impossible d'appeler toHHMMSS() sur une grandeur qui n'est pas une durée (unité: ${this.unite})`);const e=H(this.mesureDecimal,this.unite);return W(e)}}function U(s){return s==="m/s"||s==="km/h"}function q(s){return s==="hhmmss"||s==="hdec"||s==="mindec"||s==="sec"}function be(s,e){if(e==="m/s")return s;if(e==="km/h")return s.div(3.6);throw new Error(`Unité de vitesse inconnue: ${e}`)}function ke(s,e){if(e==="m/s")return s;if(e==="km/h")return s.times(3.6);throw new Error(`Unité de vitesse inconnue: ${e}`)}function H(s,e){if(e==="hhmmss")return s;if(e==="hdec")return s.times(3600);if(e==="mindec")return s.times(60);if(e==="sec")return s;throw new Error(`Unité de durée inconnue: ${e}`)}function he(s,e){if(e==="hhmmss")return s;if(e==="hdec")return s.div(3600);if(e==="mindec")return s.div(60);if(e==="sec")return s;throw new Error(`Unité de durée inconnue: ${e}`)}function Oe(s){const e=s.trim();if(/^\d{1,2}:\d{2}:\d{2}$/.test(e)){const[r,t,n]=e.split(":").map(Number);return new $(r).times(3600).plus(new $(t).times(60)).plus(n)}if(/^\d{6}$/.test(e)){const r=Number(e.slice(0,2)),t=Number(e.slice(2,4)),n=Number(e.slice(4,6));return new $(r).times(3600).plus(new $(t).times(60)).plus(n)}throw new Error(`Format hhmmss invalide: "${s}"`)}function ge(s){const e=s.toDecimalPlaces(0,$.ROUND_HALF_UP).toNumber(),r=Math.floor(e/3600),t=Math.floor(e%3600/60),n=e%60,a=[];return r>0&&a.push(`${r}~\\text{h}`),t>0&&a.push(`${t}~\\text{min}`),n>0&&a.push(`${n}~\\text{s}`),a.join("~")}function W(s){const e=s.toDecimalPlaces(0,$.ROUND_HALF_UP).toNumber(),r=Math.floor(e/3600),t=Math.floor(e%3600/60),n=e%60,a=[];return r>0&&a.push(`${r} h`),t>0&&a.push(`${t} min`),n>0&&a.push(`${n} s`),a.join(" ")}function z(s){if(U(s))return{prefixe:"",uniteDeReference:"m/s",puissanceUnite:1,puissancePrefixe:0};if(q(s))return{prefixe:"",uniteDeReference:"s",puissanceUnite:1,puissancePrefixe:0};let e,r;s==="°"&&(e=1,r="°"),s==="°C"&&(e=1,r="°C"),s.indexOf("^")>0?(e=Number(s.split("^")[1]),r=s.split("^")[0]):s.indexOf("ha")===0?(e=1,r="ha"):s.indexOf("a")===0?(e=1,r="a"):s.indexOf("ca")===0?(e=1,r="ca"):(e=1,r=s);const t=s==="°C"?"":["t","q"].includes(s)?s:r.substring(0,r.length-1),n=ve(t,s),a=["t","q"].includes(s)?"g":s.substring(t.length);return{prefixe:t,uniteDeReference:a,puissanceUnite:e,puissancePrefixe:n}}function ve(s,e){let r;switch(s){case"m":r=-3;break;case"c":r=-2;break;case"d":r=-1;break;case"":r=0;break;case"da":r=1;break;case"h":r=2;break;case"k":r=3;break;case"q":r=e==="q"?5:NaN;break;case"t":r=e==="t"?6:NaN;break;case"M":r=6;break;case"G":r=9;break;case"T":r=12;break;case"\\mu{}":r=-6;break;case"n":r=-9;break;default:r=NaN}return r}const l=new pe.ComputeEngine;function xe(s){return s.replaceAll(/dfrac/g,"frac")}function Ne(s){let e;return e=s.replaceAll(/dfrac/g,"frac"),e=e.replace(/^-\\frac(?:(\d)(\d)|{(-?\d+)}{(-?\d+)})$/i,(r,t,n,a,i)=>`\\frac{${(t||a)*(n||i)>0?"-":""}${Math.abs(t||a)}}{${Math.abs(n||i)}}`),e=e.replace(/^\\frac(?:(\d)(\d)|{(-?\d+)}{(-?\d+)})$/i,(r,t,n,a,i)=>`\\frac{${(t||a)*(n||i)<0?"-":""}${Math.abs(t||a)}}{${Math.abs(n||i)}}`),e}function $e(s){return s.replaceAll(/\\div/g,"/")}function De(s){return s.replace(/,/g,(e,r,t)=>r>0&&t[r-1]==="\\"?e:".")}function Se(s){return s.replaceAll(/\\,/g,"")}function Ce(s){return Se(De(s.replaceAll(/\{,}/g,".")))}function we(s){const e=[/\s/g,/~/g,/\\,/g,/\\:/g,/\\;/g,/\\!/g,/\\quad/g,/\\qquad/g];for(const r of e)s=s.replace(r,"");return s}function Ae(s){let e=s;for(;e.includes("  ");)e=e.replace("  "," ");return e[0]===" "&&(e=e.substring(1,e.length)),e[e.length-1]===" "&&(e=e.substring(0,e.length-1)),e}function Re(s){return s.replaceAll(/\\,/g," ")}function Me(s){return s.replaceAll(/\\lparen(\+?-?\d+,?\.?\d*)\\rparen/g,"($1)").replaceAll(/\\left\((\+?-?\d+)\\right\)/g,"($1)").replaceAll(/\\lparen(\+?-?\d+)\\rparen/g,"($1)").replaceAll(/\\left\\{(.*?)\\right\\}/g,"\\{$1\\}").replaceAll("\\lparen","(").replaceAll("\\rparen",")").replaceAll("\\left\\lbrack","[").replaceAll("\\right\\rbrack","]").replaceAll("\\right\\lbrack","[").replaceAll("\\left\\rbrack","]").replaceAll("\\left[","[").replaceAll("\\right]","]").replaceAll("\\right[","[").replaceAll("\\left]","]").replace(/\{\}/g,(e,r,t)=>r>0&&t[r-1]==="^"||t==="{}"?e:"")}function Pe(s){return s.replace(/\\mathrm\{(\w+)}/g,"$1")}function qe(s){return s.replaceAll("}}","").replaceAll("{\\text{","").replaceAll("{\\:\\text{","").replaceAll("}\\:}","")}function ye(s){return s.replaceAll("²","^2").replaceAll("³","^3").replaceAll("^{}","").replaceAll("^{^","^{")}function Ee(s){const e=s.match(/(\\text\{)(.*)}/);return e&&e?.length>2?e[2]:s}function Le(s){return s.match(/\D*1([a-z])/)?s.replace(/(\D*)1([a-z])/g,"$1$2"):s}function x(s){const e=s.map(r=>{switch(r){case"fractions":return xe;case"fractionsMemesNegatives":return Ne;case"virgules":return Ce;case"espaces":return we;case"parentheses":return Me;case"puissances":return ye;case"mathrm":return Pe;case"divisions":return $e;case"latex":return Ee;case"foisUn":return Le;case"unites":return qe;case"doubleEspaces":return Ae;case"espaceNormal":return Re;default:throw new Error(`Unsupported cleaning operation: ${r}`)}});return r=>{let t=String(r);return t=t.replaceAll("_{}","").replaceAll("^{}",""),e.reduce((n,a)=>a(n),t)}}function Ue(s){if(s.indexOf("°C")>0){const t=s.split("°C");return new S(Number.parseFloat(t[0].replace(",",".")),"°C")}if(s.indexOf("°")>0){const t=s.split("°");return new S(Number.parseFloat(t[0].replace(",",".")),"°")}if(s.split("operatorname").length!==2)return!1;const e=s.split("\\operatorname{"),r=Number.parseFloat(e[0].replace(",","."));if(e[1]){const t=e[1].split("}"),n=t[0]+t[1];return new S(r,n)}return!1}function I(s){if(s.operator==="Multiply")return s.ops==null?(window.notify("flatten a rencontré un problème avec une multiplication sans opérandes",{expr:s}),l.parse(s.latex)):l.box(["Multiply",...s.ops.map(r=>I(r))]);const e=["Power","Square"].includes(s.op1.operator)?I(s.op1):s.op1;if(s.operator==="Square")return l.box(["Multiply",e,e],{canonical:!0});if(s.operator==="Power"&&s.op2.operator==="Number"){const r=Number(s.op2.value),t=[];for(let n=0;n<r;n++)t.push(e);return l.box(["Multiply",...t],{canonical:!0})}return s}function L(s,e,r,t=!1){let n=r,a=0,i=0,f=!0;for(const u of e){let p=!1;for(const o of s){if(t&&o.isSame(u)||!t&&o.isEqual(u)){p=!0,a++;break}else if(t&&!o.isSame(u)&&o.isEqual(u)){i++;break}const c=l.box(["Subtract","0",o.json],{canonical:!0});if(t&&u.isSame(c)||!t&&u.isEqual(c)){n=!n,p=!0,a++;break}else if(t&&!u.isSame(c)&&u.isEqual(c)){i++;break}}f&&=p}return f?{isOk:n,feedback:n?"":"L'expression saisie est l'opposé de l'expression attendue."}:a>0?{isOk:!1,feedback:a>1?`Seulement $${a}$ facteurs sont corrects.`:`Seulement $${a}$ facteur est correct.`}:i>0?{isOk:!1,feedback:i>1?`$${a}$ facteurs ne sont pas sous la forme attendue.`:`$${a}$ facteur n'est pas  sous la forme attendue..`}:{isOk:!1,feedback:"Aucun facteur n'est correct."}}function Ie(s,e,{exclusifFactorisation:r=!1,nbFacteursIdentiquesFactorisation:t=!1,unSeulFacteurLitteral:n=!1}={}){const a=x(["puissances","virgules","fractions","parentheses"]);let i=!0;const f=a(s);if(s.includes("\\times1\\")||s.endsWith("\\times1")||s.startsWith("1\\times"))return{isOk:!1,feedback:"Une factorisation par 1 a peu d'intérêt."};const u=a(e),p=l.parse(f,{canonical:!0}),o=l.parse(u,{canonical:!0});if(p==null||o==null)return window.notify("factorisationCompare a rencontré un problème en analysant la réponse ou la saisie ",{saisie:s,reponse:e}),{isOk:!1};let c=p.operator,k=o.operator,d=p,m=o;c==="Negate"&&(d=p.op1,c=d.operator,i=!i),k==="Negate"&&(m=o.op1,k=m.operator,i=!i);const O=l.box(["ExpandAll",d]).evaluate().simplify().canonical,D=l.box(["ExpandAll",m]).evaluate().simplify().canonical,g=O.isEqual(D);if(!["Multiply","Power","Square"].includes(c)){let b="L'expression saisie n'est pas factorisée";return b+=g?" bien qu'elle soit égale à l'expression attendue.":".",{isOk:!1,feedback:b}}const v=I(m).ops,h=I(d).ops;if(v==null)return window.notify("factorisationCompare a rencontré un problème en analysant la réponse. ",{reponse:e}),{isOk:!1,feedback:"Un problème a eu lieu lors de la comparaison."};if(h==null)return{isOk:!1,feedback:"L'expression saisie n'a pas le format attendu."};if(t){if(h.length>v.length)return g?{isOk:!1,feedback:"L'expression saisie est trop factorisée."}:{isOk:!1,feedback:"L'expression saisie a trop de facteurs."};if(h.length<v.length)return g?{isOk:!1,feedback:"L'expression saisie peut être davantage factorisée."}:{isOk:!1,feedback:"Il manque des facteurs à l'expression saisie."};const b=L(h,v,i,r);if(!b.isOk)return{isOk:!1,feedback:`${b.feedback}`};const N=L(v,h,i,r);return{isOk:N.isOk,feedback:`${N.feedback??""}`}}if(!g||r){const b=L(h,v,i,r);if(!b.isOk)return{isOk:!1,feedback:`${b.feedback}`};const N=L(v,h,i,r);return{isOk:N.isOk,feedback:`${N.feedback??""}`}}if(g&&n){let b=0;for(const N of h)isNaN(Number(N.json))||b++;if(b===h.length-1)return{isOk:!1,feedback:"L'expression saisie peut être davantage factorisée."}}return{isOk:!0}}function He(s,e){const t=x(["unites"])(s),n=T.fromString(t);return{isOk:T.fromString(e).isTheSame(n)}}l.latexDictionary=[...l.latexDictionary.filter(s=>s.name!=="Subtract"),{...l.latexDictionary.find(s=>s.name==="Subtract"),parse:(s,e,r)=>{s.index-=1;const t=s.parseExpression({...r,minPrec:278});return["Add",e,t]}}];l.latexDictionary=[...l.latexDictionary,{identifierTrigger:"G",name:"G"}];function M(s,e,{expressionsForcementReduites:r,avecSigneMultiplier:t,avecFractions:n,sansTrigo:a,fractionIrreductible:i,fractionSimplifiee:f,fractionReduite:u,fractionDecimale:p,fractionEgale:o,fractionIdentique:c,nombreDecimalSeulement:k,expressionNumerique:d,additionSeulementEtNonResultat:m,soustractionSeulementEtNonResultat:O,multiplicationSeulementEtNonResultat:D,divisionSeulementEtNonResultat:g,ensembleDeNombres:v,fonction:h,kUplet:b,suiteDeNombres:N,suiteRangeeDeNombres:w,puissance:y,seulementCertainesPuissances:A,sansExposantUn:R,factorisation:P,exclusifFactorisation:G,nbFacteursIdentiquesFactorisation:V,unSeulFacteurLitteral:F,HMS:X,developpementEgal:Y,intervalle:Z,estDansIntervalle:_,ecritureScientifique:ee,unite:se,precisionUnite:re,texteAvecCasse:te,texteSansCasse:ne,nombreAvecEspace:ae,egaliteExpression:ie,calculFormel:ce,nonReponseAcceptee:le,variable:oe,entier:ue,domaine:fe}={expressionsForcementReduites:!0,avecSigneMultiplier:!0,avecFractions:!0,sansTrigo:!1,fractionIrreductible:!1,fractionSimplifiee:!1,fractionReduite:!1,fractionDecimale:!1,fractionEgale:!1,fractionIdentique:!1,nombreDecimalSeulement:!1,expressionNumerique:!1,additionSeulementEtNonResultat:!1,soustractionSeulementEtNonResultat:!1,multiplicationSeulementEtNonResultat:!1,divisionSeulementEtNonResultat:!1,ensembleDeNombres:!1,fonction:!1,kUplet:!1,seulementCertainesPuissances:!1,sansExposantUn:!1,suiteDeNombres:!1,suiteRangeeDeNombres:!1,factorisation:!1,exclusifFactorisation:!1,nbFacteursIdentiquesFactorisation:!1,unSeulFacteurLitteral:!1,HMS:!1,developpementEgal:!1,intervalle:!1,estDansIntervalle:!1,ecritureScientifique:!1,unite:!1,precisionUnite:0,puissance:!1,texteAvecCasse:!1,texteSansCasse:!1,nombreAvecEspace:!1,egaliteExpression:!1,calculFormel:!1,nonReponseAcceptee:!1,variable:"x",entier:!1,domaine:[-100,100]}){return le?s===""&&e===""?{isOk:!0}:{isOk:!1,feedback:"Une réponse doit être saisie"}:s===""?{isOk:!1,feedback:"Une réponse doit être saisie"}:X?He(s,e):h?Qe(s,e,{variable:oe??"x",domaine:fe??[-100,100],entier:ue??!1}):Z?Be(s,e):_?Ke(s,e):ee?je(s,e):se?Je(s,e,{precision:re}):P||G||V||F?Ie(s,e,{exclusifFactorisation:G,nbFacteursIdentiquesFactorisation:V,unSeulFacteurLitteral:F}):y||A||R?ze(s,e,{seulementCertainesPuissances:A,sansExposantUn:R}):te?Q(s,e):ne?Te(s,e):ie?Xe(s,e):ae?Ze(s,e):d?We(s,e):v||b?J(s,e,{kUplet:b}):N||w?J(s,e,{kUplet:w,avecAccolades:!1}):f||u||i||p||o||c?Ge(s,e,{fractionReduite:u,fractionIrreductible:i,fractionDecimale:p,fractionEgale:o,fractionIdentique:c,nombreDecimalSeulement:k}):Y?Ve(s,e):E(s,e,{expressionsForcementReduites:r,avecSigneMultiplier:t,avecFractions:n,sansTrigo:a,fractionIrreductible:i,additionSeulementEtNonResultat:m,soustractionSeulementEtNonResultat:O,multiplicationSeulementEtNonResultat:D,divisionSeulementEtNonResultat:g,nombreDecimalSeulement:k,calculFormel:ce})}function C(s,{expressionsForcementReduites:e=!0,fractionIrreductible:r=!1,nombreDecimalSeulement:t=!1}={}){let n=s;if(t)return n;if(typeof n.value=="number"){if(r){if((n.operator==="Divide"||n.operator==="Rational")&&(n.engine.box(["GCD",n.op1,n.op2]).value!==1||n.op2.value===1))return n;if(n.operator==="Number")return l.parse(`\\frac{${n.value}}{1}`,{canonical:!1})}return n.engine.number(n.value)}return(n.operator==="Divide"||n.operator==="Rational")&&n.op2.value===1&&(n=n.op1),n.operator!=="Subscript"&&n.ops?n.engine.box([n.operator,...n.ops.map(a=>C(a,{expressionsForcementReduites:e,fractionIrreductible:r,nombreDecimalSeulement:t}))],{canonical:["InvisibleOperator","Order","Flatten"]}):n.canonical}function Ge(s,e,{fractionReduite:r=!1,fractionIrreductible:t=!1,fractionDecimale:n=!1,fractionEgale:a=!1,fractionIdentique:i=!1,nombreDecimalSeulement:f=!1}={}){const u=x(["virgules","fractionsMemesNegatives"]),p=u(s),o=u(e),c=l.parse(p,{canonical:!1}),k=l.parse(o,{canonical:!1});if(f&&E(p,k.N().toString(),{nombreDecimalSeulement:!0}).isOk)return{isOk:!0,feedback:""};const d=k.engine.number(Number(k.value));if(c.isEqual(k)){if(i)return c.isSame(k)?{isOk:!0,feedback:""}:{isOk:!1,feedback:"Le résultat ne correspond pas à la fraction attendue."};if(c.operator==="Number"&&d.isInteger)return{isOk:!0};if(a){if(c.operator==="Divide"||c.operator==="Rational"||c.operator==="Negate"&&(c.op1.operator==="Divide"||c.op1.operator==="Rational")){let m,O;return c.operator!=="Negate"?(m=c.op1.evaluate().numericValue,O=c.op2.evaluate().numericValue):(m=c.op1.op1.evaluate().numericValue,O=c.op1.op2.evaluate().numericValue),Number.isInteger(m)&&Number.isInteger(O)?{isOk:!0}:{isOk:!1,feedback:"Résultat incorrect car dénominateur et numérateur doivent être entiers."}}return{isOk:!1,feedback:"Résultat incorrect car une fraction est attendue."}}return n?(c.operator==="Divide"||c.operator==="Rational")&&Number.isInteger(Math.log10(Number(c.op2.value)))&&Math.log10(Number(c.op2.value))>=0?c.op1.isInteger?{isOk:!0}:{isOk:!1,feedback:"Résultat incorrect car le numérateur n'est pas entier."}:{isOk:!1,feedback:"Résultat incorrect car une fraction décimale est attendue."}:t?(c.operator==="Divide"||c.operator==="Rational")&&c.engine.box(["GCD",c.op1,c.op2]).value===1||c.canonical.isInteger?{isOk:!0}:{isOk:!1,feedback:"Résultat incorrect car une fraction irréductible est attendue."}:(c.operator==="Divide"||c.operator==="Rational")&&Math.abs(Number(c.op1.value))<Math.abs(Number(k.op1.value))&&c.op1.isInteger&&c.op2.isInteger&&(r||Number(k.op1.value)%Number(c.op1.value)===0)?{isOk:!0}:!c.op1.value&&!d.isInteger?{isOk:!1,feedback:"Résultat incorrect car une fraction est attendue."}:c.operator==="Divide"||c.operator==="Rational"?Math.abs(Number(c.op1.value))>=Math.abs(Number(k.op1.value))?{isOk:!1,feedback:"Résultat incorrect car une fraction simplifiée est attendue."}:!c.op1.isInteger||!c.op2.isInteger?{isOk:!1,feedback:"Résultat incorrect car dénominateur et numérateur doivent être entiers."}:{isOk:!1,feedback:"Résultat incorrect car une fraction réduite est attendue."}:{isOk:!1,feedback:"Résultat incorrect car une fraction est attendue."}}return{isOk:!1,feedback:"Résultat incorrect."}}function E(s,e,{expressionsForcementReduites:r=!0,avecSigneMultiplier:t=!0,avecFractions:n=!0,sansTrigo:a=!1,fractionIrreductible:i=!1,nombreDecimalSeulement:f=!1,additionSeulementEtNonResultat:u=!1,soustractionSeulementEtNonResultat:p=!1,multiplicationSeulementEtNonResultat:o=!1,divisionSeulementEtNonResultat:c=!1,calculFormel:k=!1}={}){let d="";if(!t&&s.includes("times"))return{isOk:!1,feedback:"Aucun signe $\\times$ n'est autorisé."};if(!n&&s.includes("frac"))return{isOk:!1,feedback:"Aucune fraction n'est autorisée."};if(a&&(s.includes("cos")||s.includes("sin")||s.includes("tan")))return{isOk:!1,feedback:"Aucune fonction trigonométrique n'est autorisée."};const m=x(["puissances","virgules","fractionsMemesNegatives","parentheses","foisUn"]);let O=m(s);const D=m(e);if(k)return l.parse(O,{canonical:!1}).isEqual(l.parse(D,{canonical:!1}))?{isOk:!0,feedback:""}:{isOk:!1,feedback:"L'expresssion fournie est incorrecte."};if(f){O=O.replace("(","").replace(")","").replace("\\lparen","").replace("\\rparen","");const b=l.parse(O,{canonical:!1});if(!(b.operator==="Number"||b.operator==="Negate"&&b.ops!==null&&b.ops.length===1))return{isOk:!1,feedback:"Résultat incorrect car une valeur décimale (ou entière) est attendue."}}const g=C(l.parse(O,{canonical:!1}),{}),v=C(l.parse(D,{canonical:!1}),{}),h={a:2,b:2,c:2,x:2,y:2,z:2};if(u||p||o||c){const b=l.parse(O,{canonical:!1});if(b.operator==="Add"&&(b.op1.is(0)||b.op2.is(0)))return d="Résultat incorrect car la somme par 0 est inutile.",{isOk:!1,feedback:d};if(s.includes("-0"))return d="Résultat incorrect car la différence par 0 est inutile.",{isOk:!1,feedback:d};if(b.operator==="Multiply"&&(b.op1.is(1)||b.op2.is(1)))return d="Résultat incorrect car le produit par 1 est inutile.",{isOk:!1,feedback:d};if((b.operator==="Divide"||b.operator==="Rational")&&b.op2.is(0))return d="Résultat incorrect car la division par 1 est inutile.",{isOk:!1,feedback:d}}if(g.isEqual(v)&&!g.isSame(v)&&(u||p||o||c)){const b=C(l.parse(O,{canonical:!1}),{expressionsForcementReduites:r,fractionIrreductible:i,nombreDecimalSeulement:f}),N=C(l.parse(O,{canonical:!1}),{expressionsForcementReduites:r,fractionIrreductible:i});if(b.isSame(N)){let w=function(A){const R=A.indexOf("Negate"),P=A.indexOf("Delimiter");return R!==-1&&(P===-1||R<P)};if(u&&g.operator==="Add")return{isOk:!0,feedback:""};if(o&&(g.operator==="Multiply"||g.operator==="Power"))return{isOk:!0,feedback:""};if(c&&(g.operator==="Divide"||g.operator==="Power"))return{isOk:!0,feedback:""};const y=JSON.stringify(l.parse(O,{canonical:!1}).json);if(p&&w(y))return{isOk:!0,feedback:""}}}if(!g.isSame(v))if(f)C(l.parse(O,{canonical:!1}),{expressionsForcementReduites:r,fractionIrreductible:i,nombreDecimalSeulement:!1}).isSame(v)?d="Résultat incorrect car une valeur numérique est attendue.":d="Résultat incorrect.";else if(u||p||o||c){const b=C(l.parse(O,{canonical:!1}),{expressionsForcementReduites:r,fractionIrreductible:i,nombreDecimalSeulement:f}),N=C(l.parse(O,{canonical:!1}),{expressionsForcementReduites:r,fractionIrreductible:i});b.isSame(N)?g.operator==="Number"?d="Résultat incorrect car un calcul est attendu.":(d="Résultat incorrect car ",d+=u?"c'est une somme qui est attendue.":p?"c'est une différence qui est attendue.":o?"c'est un produit qui est attendu.":c?"c'est un quotient qui est attendu.":"ce n'est pas ce calcul qui est attendu."):d="Résultat incorrect."}else if(i){const b=C(l.parse(O,{canonical:!1}),{expressionsForcementReduites:r,fractionIrreductible:!1}),N=C(l.parse(O,{canonical:!1}),{expressionsForcementReduites:r,fractionIrreductible:!1});b.isSame(N)?l.parse(O,{canonical:!1}).operator==="Number"?d="Résultat incorrect car une fraction est attendue.":d="Résultat incorrect car une fraction irréductible est attendue.":d="Résultat incorrect."}else!g.isSame(v)&&B(D,h)===B(O,h)&&(d="Incorrect");return{isOk:g.isSame(v),feedback:d}}function Ve(s,e){const r=x(["puissances","virgules","parentheses","foisUn"]),t=r(s),n=r(e),a=l.parse(t,{canonical:!0}),i=l.parse(n,{canonical:!0});if(!a.ops||!i.ops)return{isOk:!1,feedback:"Cette expression n'est pas développée."};if(a.operator!==i.operator)return{isOk:!1,feedback:"Cette expression n'est pas développée."};let f=l.parse("0");for(const p of a.ops)f=f.add(p);let u=l.parse("0");for(const p of i.ops)u=u.add(p);return{isOk:f.isSame(u),feedback:f.isSame(u)?"":f.isEqual(u)?"Cette expression n'est pas assez développée.":"Incorrect"}}function B(s,e){let t=l.parse(s);for(const[a,i]of Object.entries(e))t=t.subs({[a]:i});const n=t.evaluate().value;return typeof n=="number"?n:"NAN"}function ns(s,e){return E(s,e,{expressionsForcementReduites:!1})}function Fe(s){const e=/^(-?\d+(?:\.\d+)?)\\times10\^{?(-?\d+)}?$/,r=/^10\^{?(-?\d+)}?\\times(-?\d+(?:\.\d+)?)$/;let t=null,n=null;if(e.test(s)){const a=s.match(e);t=Number(a[1]),n=Number(a[2])}else if(r.test(s)){const a=s.match(r);n=Number(a[1]),t=Number(a[2])}else return{isOk:!1,feedback:"Format incorrect : utilisez a\\times10^b ou 10^b\\timesa."};return isNaN(t)||isNaN(n)?{isOk:!1,feedback:"La mantisse ou l'exposant n'est pas un nombre valide."}:Math.abs(t)<1?{isOk:!1,feedback:"La mantisse doit être ≥ 1."}:Math.abs(t)>=10?{isOk:!1,feedback:"La mantisse doit être < 10."}:{isOk:!0,feedback:"La notation est correcte."}}function je(s,e){const r=x(["virgules","espaces","parentheses","puissances"]),t=r(s),n=r(e);let a=t.replace(/\s+/g,"").replace(/\\times/g,"\\cdot").replace(/\^(\d+)/g,"^{$1}").replace(/\{\+(\d+)\}/g,"{$1}");const i=a.match(/\^{(-?\d+)}$/);(i?me(i[i.length-1]):null)===0&&(a=l.parse(t).toLatex({notation:"scientific",avoidExponentsInRange:[0,0]}));const u=/(?:\{(-?\d+(?:\.\d+)?)\}|(-?\d+(?:\.\d+)?))\\cdot(.+)/,p=a.match(u);let o=null;p&&(o=p[1]||p[2]||null,o==="1"&&p[3]&&(a=p[3].trim()));const c=l.parse(n).toLatex({notation:"scientific",avoidExponentsInRange:[0,0]});return a=a.replace(/(\d+\.?\d*?)0*(?=\\cdot)/,"$1"),a===c?{isOk:!0}:l.parse(t).isEqual(l.parse(n))?{isOk:!1,feedback:"La réponse fournie est bien égale à celle attendue mais la réponse fournie n'est pas en notation scientifique."}:Fe(t).isOk?{isOk:!1,feedback:"La réponse fournie est bien en notation scientifique mais la réponse fournie n'est pas égale à celle attendue."}:{isOk:!1,feedback:"La réponse fournie n'est pas égale à celle attendue."}}function Q(s,e){const r=x(["parentheses","mathrm","fractions","virgules"]);s=s.replace(/\\lparen\s*([^{}]+)\s*\{,\}\s*([^{}]+)\s*\\rparen/g,"($1,$2)"),s=s.replace(/\\lparen\s*/g,"(").replace(/\\rparen/g,")"),e=e.replace(/\\lparen\s*/g,"(").replace(/\\rparen/g,")");let t=r(s);const n=r(e);return t=x(["espaceNormal","doubleEspaces"])(t),{isOk:n===t}}function Te(s,e){const r=s.toLowerCase(),t=e.toLowerCase();return Q(r,t)}function We(s,e){const t=x(["fractions"])(e),n=l.parse(t,{canonical:!0}),a=l.parse(s,{canonical:!0});return n.isSame(a)?{isOk:!0}:n.isEqual(a)?a.isNumber?{isOk:!1,feedback:"Ce résultat pourrait être correct mais un calcul est attendu."}:{isOk:!1,feedback:"Ce résultat pourrait être correct mais ce n'est pas ce calcul qui est attendu."}:{isOk:!1,feedback:"Ce résultat pourrait être correct mais ce n'est pas ce calcul qui est attendu."}}function as(s,e){const r=x(["fractions"]),t=r(s),n=r(e),a=t.match(/\\frac{[^}]*}{(\\sqrt[^}]*)/)?.[1]||null;return a===null?{isOk:M(t,n).isOk}:a.includes("sqrt")?{isOk:!1}:{isOk:M(t,n).isOk}}function ze(s,e,{seulementCertainesPuissances:r=!1,sansExposantUn:t=!1}={}){const n=x(["virgules","puissances"]),a=n(s).split("^"),i=n(e).split("^");if(a.length===1){const c=isNaN(Number(i[1]))?1:i[1];return(Number(c)===1||Number(c)===0)&&l.parse(n(s)).isEqual(l.parse(n(e)))?{isOk:!0}:{isOk:!1,feedback:"Une puissance est attendue."}}if(r&&a.length>2)return{isOk:!1,feedback:"Un seul exposant est attendu."};let f=a[0];if(f=f.replace(/\\lparen|\\rparen|\(|\)/g,""),f=f.replace(/--/g,""),Number.isNaN(f))return{isOk:!1,feedback:"Avant l'exposant, on attend un nombre unique."};let u=a[1];u=u.replace(/\\lparen|\\rparen|\(|\)/g,""),u=u.replace(/--/g,""),u=u.replace(/[{}]/g,"");const p=Number(u);if(Number.isNaN(p))return{isOk:!1,feedback:"On attend un nombre unique comme exposant."};if(i.length===1){if(t&&p===1)return{isOk:!1,feedback:"On attend un exposant différent de 1."};const c=l.parse(n(s)).isEqual(l.parse(n(e)));return{isOk:!!c,feedback:c?"":"La puissance n'est pas égale au résultat attendu."}}if(t){let c=i[1];c=c.replace(/\\lparen|\\rparen|\(|\)/g,""),c=c.replace(/--/g,"");const k=Number(c);if(p===1&&k!==1)return{isOk:!1,feedback:"On attend un exposant différent de 1."}}return(r?l.parse(n(s)).isSame(l.parse(n(e))):l.parse(n(s)).isEqual(l.parse(n(e))))?{isOk:!0}:l.parse(n(s)).isEqual(l.parse(n(e)))?{isOk:!1,feedback:"La puissance est égale au résultat attendu mais ne correspond pas à l'énoncé."}:{isOk:!1,feedback:"La puissance n'est pas égale au résultat attendu."}}function J(s,e,{kUplet:r=!1,avecAccolades:t=!0}={}){const n=x(["virgules","fractions","parentheses"]),a=n(s);if(e=n(e),e==="\\emptyset"&&a===e)return{isOk:!0};if(e==="\\emptyset"&&a.includes("\\emptyset"))return{isOk:!1,feedback:"Résultat incorrect car $\\emptyset doit être écrit seul."};let i,f;if(t){if(a[1]!=="{")return{isOk:!1,feedback:"Résultat incorrect car cet ensemble doit commencer par une accolade ou bien être l'ensemble vide."};if(a[a.length-1]!=="}")return{isOk:!1,feedback:"Résultat incorrect car cet ensemble doit se terminer par une accolade ou bien être l'ensemble vide."};i=a.replaceAll("\\{","").replaceAll("\\}","").split(";"),f=n(e).replaceAll("\\{","").replaceAll("\\}","").split(";")}else i=a.split(";"),f=n(e).split(";");if(new Set(i).size!==i.length)return{isOk:!1,feedback:"Résultat incorrect car cet ensemble contient des valeurs redondantes."};if(i.length>f.length)return{isOk:!1,feedback:"Résultat incorrect car cet ensemble contient trop de nombres."};if(i.length<f.length)return{isOk:!1,feedback:"Résultat incorrect car cet ensemble ne contient pas assez de nombres."};const u=i,p=f;return u.every(c=>{for(let k=0;k<p.length;k++)if(l.parse(c).isEqual(l.parse(p[k])))return!0;return!1})?r&&!i.every((c,k)=>l.parse(c).isSame(l.parse(p[k])))?{isOk:!1,feedback:"Résultat incorrect car les nombres ne sont pas rangés dans le bon ordre."}:{isOk:!0}:f.length===1?{isOk:!1,feedback:"Résultat incorrect car cet ensemble n'a pas la valeur attendue."}:{isOk:!1,feedback:"Résultat incorrect car cet ensemble n'a pas toutes les valeurs attendues."}}function Be(s,e){const r=x(["virgules","parentheses","espaces"]),t=r(s),n=r(e);if(n==="\\emptyset")return t==="\\emptyset"||t==="\\{\\}"?{isOk:!0,feedback:""}:{isOk:!1,feedback:"la bonne réponse était l'ensemble vide : $\\emptyset$"};let a=!0,i=!0,f="";const u=/[^[\];]+/g,p=/[[\]]/g,o=t.match(u),c=n.match(u),k=t.match(p),d=n.match(p);if(o!=null&&c!=null&&k!=null&&d!=null){if(o.length!==c.length)return{isOk:!1};let m;for(a=!0,m=0;m<o.length;m++)a&&=M(o[m],c[m]).isOk,a||(f+=["\\cup","\\cap"].includes(o[m])?`Il y a une erreur avec l'opérateur : $${o[m]}$.<br>`:`Il y a une erreur avec la valeur : $${o[m]}$.<br>`);if(i=k.length===d.length,i||(f+="Il y a une erreur avec les crochets."),i)for(m=0;m<k.length;m++)i=k[m]===d[m]&&i,k[m]!==d[m]&&(f+=`Le crochet placé en position ${m+1} est mal orienté.<br>`);return{isOk:a&&i,feedback:f}}return{isOk:!1,feedback:"Il faut donner un intervalle ou une réunion d'intervalles"}}function Je(s,e,{precision:r=1}={}){const t=s.replace("^\\circ","°").replace("\\degree","°"),n=x(["virgules","espaces","fractions","parentheses","mathrm"]),a=Ue(n(t)),i=S.fromString(n(e).replace("^\\circ","°").replace("\\degree","°"));if(a){if(a.uniteDeReference!==i.uniteDeReference)return{isOk:!1,feedback:`Il faut donner la réponse en $${i.latexUnit}$.`};if(r!==void 0){const p=a.estUneApproximation(i,r),o=i.estUneApproximation(a,r/10);return p&&o?{isOk:!0}:p?{isOk:!1,feedback:`La réponse n'est pas arrondie à $${K(10**-r,r)}$ près.`}:{isOk:!1}}return a.estEgal(i)?{isOk:!0}:{isOk:!1}}const f=Number(l.parse(n(s)));return new S(f,i.unite).estEgal(i)?{isOk:!1,feedback:"La réponse est correcte mais l'unité n'a pas été précisée."}:f!==0?{isOk:!1,feedback:"La réponse est fausse et il faut saisir l'unité."}:{isOk:!1}}function Ke(s,e){let r=!0,t=!0;e.startsWith("[")&&(r=!1),e.endsWith("]")&&(t=!1);const n=e.match(/[[\]](.+);(.+)[[\]]/);if(n==null)return window.notify("Il faut revoir la définition de l'intervalle ",{goodAnswer:e}),{isOk:!1,feedback:"Un problème avec goodAnswer !"};const a=x(["virgules","fractions","espaces"]),i=Number(l.parse(a(n[1])).N()),f=Number(l.parse(a(n[2])).N()),u=Number(l.parse(a(s)).N());if(Number.isNaN(u))return{isOk:!1};const p=r?u>i:u>=i,o=t?u<f:u<=f;return{isOk:p&&o}}function is(s,e){let r="";const[t,n,a]=s.includes("<")?s.split("<").map(o=>Number(l.parse(o).numericValue)):s.split(">").map(o=>Number(l.parse(o).numericValue)).sort((o,c)=>o-c);if(!(Number.isInteger(Number(a))&&Number.isInteger(Number(t))))return r="On attend comme réponse deux nombres entiers.",{isOk:!1,feedback:r};const[i,,f]=e.includes("<")?e.split("<").map(o=>Number(l.parse(o).numericValue)):e.split(">").map(o=>Number(l.parse(o).numericValue)).sort((o,c)=>o-c),u=Number(l.box(["Subtract",String(a),String(t)]).N().numericValue);if(u===-1)return r="Les nombres sont bien deux entiers consécutifs, mais ils sont donnés dans l'ordre inverse.",{isOk:!1,feedback:r};if(u!==1)return{isOk:!1,feedback:"Les deux nombres entiers donnés ne sont pas consécutifs."};if(n!=null){const o=Number(l.box(["Subtract",String(a),String(n)]).N().numericValue),c=Number(l.box(["Subtract",String(n),String(t)]).N().numericValue);if(!(o!=null&&c!=null&&o<1&&o>=0&&c<1&&c>=0))return{isOk:!1,feedback:`Les deux nombres entiers sont biens consécutifs mais n'encadrent pas la valeur ${n}`}}return{isOk:E(String(t),String(i)).isOk&&E(String(a),String(f)).isOk,feedback:""}}function cs(s,e,{tolerance:r=.1}={}){const t=x(["virgules","fractions","espaces","parentheses","puissances"]),n=Number(l.parse(t(s)).numericValue),a=Number(l.parse(t(e)).numericValue);return{isOk:Math.abs(n-a)<=r}}function Qe(s,e,{variable:r="x",domaine:t=[-100,100],entier:n=!1}={}){const a=x(["virgules","parentheses","fractions","divisions"]),i=a(s),u=l.parse(i).compile(),p=a(e),o=l.parse(p).compile(),c=t[0],d=t[1]-c,m=()=>c+d*Math.random();if(u==null||o==null)throw Error(`functionCompare : La saisie ou la bonne réponse ne sont pas des fonctions (saisie : ${s} et réponse attendue : ${e}`);let O,D,g,v,h,b,N=0;do[O,D,g]=n?[m(),m(),m()].map(Math.round):[m(),m(),m()],v=Object.fromEntries([[r??"x",O]]),h=Object.fromEntries([[r??"x",D]]),b=Object.fromEntries([[r??"x",g]]),N++;while(N<1e3&&(Number.isNaN(o(v))||Number.isNaN(o(h))||Number.isNaN(o(b))));if(N===1e3)return window.notify("functionCompare n'a pas réussi à trouver 3 valeurs dans le domaine qui donnent une image par la fonction goodAnswer !",{fonction:e,domaine:t}),{isOk:!1,feedback:"erreur dans le programme"};let w=!0;for(const y of[O,D,g]){const A=Object.fromEntries([[r??"x",y]]),R=Number(u(A)),P=Number(o(A));w=w&&Math.abs(R-P)<1e-10}return{isOk:w}}function Xe(s,e){const[r,t]=s.split("="),[n,a]=e.split("=");if(r==null||t==null)return{isOk:!1,feedback:"Une égalité est attendue"};const{isOk:i}=M(t,n),{isOk:f}=M(r,n),{isOk:u}=M(t,a),{isOk:p}=M(r,a);return{isOk:i&&p||u&&f}}function Ye(s){return s.replace(/\b\d+(?:[.,]\d+)?\b/g,e=>{const r=e.includes(",")?",":".",[t,n]=e.split(r),a=t.replace(/(\d)(?=(\d{3})+$)/g,"$1 ");if(n){const i=n.replace(/(\d{3})(?=\d)/g,"$1 ");return`${a}${r}${i.trim()}`}return a})}function Ze(s,e){let r=s.replaceAll(/(\s{2,})(?=\d{3})/g," ").trim();r=r.replaceAll(/\\,/g," ");const t=x(["espaces"]),n=t(s),a=t(e);let i=a.replace(/\s+/g,"");i=i.replace("{,}",","),i=Ye(i),i=i.replace(",","{,}");let f="";return r!==i&&n===a&&(f="Le nombre est mal écrit, il faut faire attention aux espaces. "),{isOk:r===i,feedback:f}}function ls(s,e,{noUselessParen:r=!1}){const t=x(["virgules","parentheses","divisions","fractions","puissances","fractions","mathrm"]),n=t(s)??"",a=t(e)??"";let i="",f=!0;const u=n.match(/([[()\]])/g)?.length,p=a.match(/([[()\]])/g)?.length,o=n.match(/\d+/g)?.sort((v,h)=>Number(v)-Number(h)),c=a.match(/\d+/g)?.sort((v,h)=>Number(v)-Number(h)),k=n.match(/[+\-/*]|(times)|(div)|(frac)/g)?.sort((v,h)=>v.charCodeAt(0)-h.charCodeAt(0)),d=a.match(/[+\-/*]|(times)|(div)|(frac)/g)?.sort((v,h)=>v.charCodeAt(0)-h.charCodeAt(0)),m=p===u,O=o!=null&&c!=null&&j(o,c),D=k!=null&&d!=null&&j(k,d),g=l.parse(n).isEqual(l.parse(t(e)));return r&&n!=null&&a!==null?(f=(m&&O&&D&&g)??!1,!m&&g&&(i="L'expression donne le bon résultat mais n'a pas la forme attendue.")):(f=(O&&D&&g)??!1,f||(g?D?i="L'expression ne contient pas les bons nombres.":i="L'expression ne contient pas les bonnes opérations.":i="L'expression ne donne pas le bon résultat.")),{isOk:f,feedback:i}}function os(s,e,r,t){const a=x(["virgules","parentheses","fractions","divisions"])(s),i=l.parse(a,{canonical:!1}),f=i.value;if(f!==r)return{isOk:!1,feedback:`L'expression vaut ${f} et non ${r}.`};let u=0,p=0,o=0,c=0,k=!1,d=!1,m=!1,O=!1,D=!1;const g=[...e],v=h=>{if(h.numericValue!==null){if(g.length===0)return e.includes(Math.abs(Number(h.value)))?(d=!0,"Au moins un nombre en doublon"):(k=!0,"Au moins un nombre en trop");if(g.includes(Math.abs(Number(h.value))))g.splice(g.indexOf(Math.abs(Number(h.value))),1);else return m=!0,"Au moins un mauvais nombre parmi ceux proposés"}if(h.symbol)return O=!0,"L'expression contient un symbole non autorisé.";if(h.operator){if(h.operator!=="Number"&&h.operator!=="Delimiter")switch(h.operator){case"Add":u++;break;case"Multiply":p++;break;case"Divide":o++;break;case"Subtract":case"Negate":c++;break;default:D=!0}if(h.ops!==null)for(const b of h.ops)v(b);else return"OK"}};return v(i),k?{isOk:!1,feedback:"L'expression utilise plus de nombres que demandés."}:d?{isOk:!1,feedback:"L'expression utilise plusieurs fois un même nombre parmi ceux proposés."}:m?{isOk:!1,feedback:"L'expression utilise au moins un nombre non autorisé."}:O?{isOk:!1,feedback:"L'expression contient un symbole non autorisé."}:D?{isOk:!1,feedback:"L'expression doit contenir que des additions, des soustractions, des multiplications, des divisions ou des parenthèses."}:t&&!(u===1&&o===1&&c===1&&p===1)?{isOk:!1,feedback:"L'expression doit contenir une addition, une soustraction, une multiplication et une division."}:{isOk:!0,feedback:""}}export{S as G,Qe as a,cs as b,is as c,as as d,l as e,M as f,x as g,ns as h,os as i,ls as j,Ze as n,Te as t};
