import{g as I,b as T,i as G}from"./courbes-C9fk0WuH.js";import{af as H,C as N,r as k,o as g,H as R,b3 as U,b4 as V,b5 as j,e as o,m as w,t as X,k as $,T as L,p as P,d as A,l as B}from"./embellissements-BYV7mIDn.js";import{r as J}from"./reperes-WwrVcExd.js";import{E as O}from"./Exercice-DtXhjCyI.js";import{a as D}from"./questionMathLive-DdRvWqlN.js";import{h as q}from"./gestionInteractif-DujZpSu8.js";import{b as C}from"./comparisonFunctions-B45ZZ3C7.js";import"mathjs";import"decimal.js";import"katex";import"earcut";import"roughjs";import"./exerciseMethods-CtbYPwln.js";import"./index-BUDQz6-w.js";import"crypto-js";import"seedrandom";import"./tableauMathlive-xx-nDjq0.js";import"./canStore-DaSrd7sp.js";import"./generalStore-C3E9FHtR.js";import"./ListeDeroulanteElement-CXmzV-cr.js";import"./sizeTools-DfTC1Dgv.js";import"./time-DMC-jnVL.js";import"./AjouteTableauMathlive-Bz24QHd3.js";import"./Hms-u2AUyU1C.js";import"./compute-engine.min.umd-BwAhpA7x.js";const ve="Déterminer graphiquement les extremums",De=!0,qe="mathLive",ke=!0,Ce="AMCHybride",Le="1/08/2021",Pe="5/08/2022",Te="573f2",we={"fr-fr":["2F20-3"],"fr-ch":["11FA9-4"]};class Ae extends O{constructor(){super(),this.correctionDetailleeDisponible=!0,this.correctionDetaillee=!0,this.nbQuestions=6,this.nbQuestionsModifiable=!1,this.nbCols=2,this.sup=1}nouvelleVersion(){const Q=H(["minimum","maximum","image","plusPetitAntécédent","plusGrandAntécédent","nombreAntécédents"],this.nbQuestions);let y=4,M=-4,c;const v=[],f=N("O",-.5,-.5,0,"black",1,"milieu",!0);let d=[],r=[];const h=J({xMin:-4.1,yMin:-4.1,xMax:4.1,yMax:4.1,yUnite:2,xUnite:2,grilleSecondaire:!0,grilleSecondaireYDistance:.2,grilleSecondaireXDistance:.2,grilleSecondaireXMin:-4,grilleSecondaireXMax:4,grilleSecondaireYMin:-4,grilleSecondaireYMax:4,xThickMax:4,yThickMax:4,xThickMin:-4,yThickMin:-4});let e=[],S,E,m,p,F=0;const Y=0;do{e=[];for(let t=-4,b=-5;t<5;t+=2)b=k(-8,8,Y)/2,e.push([t,b]),y=Math.min(b,y),M=Math.max(b,M);m=[-15,5],p=[-15,-5];for(let t=0;t<e.length;t++)m[1]>e[t][1]&&(m[0]=e[t][0],m[1]=e[t][1]),p[1]<e[t][1]&&(p[0]=e[t][0],p[1]=e[t][1]);S=e.filter(t=>t[1]===y),E=e.filter(t=>t[1]===M),F++}while((S.length>1||E.length>1)&&F<1e3);const x=I(e,{repere:h,step:.1});this.introduction="Voici la représentation graphique de la fonction $f$ définie sur $[-4;4]$.<br>"+g({xmin:-13.5,ymin:-9,xmax:13.5,ymax:9,scale:.5,pixelsParCm:30},h,x,f)+"<br>";for(let t=0,b=0;t<this.nbQuestions&&b<50;){let u="",l="",a=0,n=0,i=0;switch(Q[t]){case"minimum":u="Lire graphiquement le minimum de la fonction $f$ sur l'intervalle $[-4;4]$.<br>",q(this,t,{reponse:{value:m[1],compare:C,options:{tolerance:.1}}}),v[t]=m[1],u+=D(this,t),l=`Le minimum de $f$ est $${o(m[1],1)}$ et il est atteint en $x=${m[0]}$.<br>`,this.correctionDetaillee&&(r[0]=$(m[0]*2,0,m[0]*2,m[1]*2,"blue"),r[0].pointilles=5,r[1]=$(m[0]*2,m[1]*2,0,m[1]*2,"red"),r[1].pointilles=5,r[2]=L(P(m[0]*2,m[1]*2),"red"),l+=g({xmin:-13.5,ymin:-9,xmax:13.5,ymax:9,scale:.5,pixelsParCm:30},h,x,r,f));break;case"maximum":u="Lire graphiquement le maximum de la fonction $f$ sur l'intervalle $[-4;4]$.<br>",q(this,t,{reponse:{value:p[1],compare:C,options:{tolerance:.1}}}),v[t]=p[1],u+=D(this,t),l=`Le maximum de $f$ est $${o(p[1],1)}$ et il est atteint en $x=${p[0]}$.<br>`,this.correctionDetaillee&&(r[0]=$(p[0]*2,0,p[0]*2,p[1]*2,"blue"),r[0].pointilles=5,r[1]=$(p[0]*2,p[1]*2,0,p[1]*2,"red"),r[1].pointilles=5,r[2]=L(P(p[0]*2,p[1]*2),"red"),l+=g({xmin:-13.5,ymin:-9,xmax:13.5,ymax:9,scale:.5,pixelsParCm:30},h,x,r,f));break;case"image":for(r=[],a=k(-4,4),i=0;a>e[i+1][0];)i++;n=A(G([[e[i][0],e[i][1]],[e[i+1][0],e[i+1][1]]],a),1),u=`Lire graphiquement l'image de $${o(a,1)}$ par la fonction $f$.<br>Donner la réponse avec la précision permise par le graphique.<br>`,q(this,t,{reponse:{value:n,compare:C,options:{tolerance:.1}}}),v[t]=n,u+=D(this,t),l=`$f(${o(a,1)})=${o(n,1)}$.<br>`,this.correctionDetaillee&&(r[0]=$(0,n*2,a*2,n*2,"blue"),r[0].pointilles=5,r[1]=$(a*2,n*2,a*2,0,"red"),r[1].pointilles=5,r[2]=L(P(a*2,n*2),"red"),l+=g({xmin:-13.5,ymin:-9,xmax:13.5,ymax:9,scale:.5,pixelsParCm:30},h,x,r,f));break;case"plusPetitAntécédent":{r=[],c=!1;do{for(n=k(y*10+2,M*10-2)/10,i=0;i+1<e.length&&(n>Math.max(e[i][1],e[i+1][1])||n<Math.min(e[i][1],e[i+1][1]));)i++;i+1<e.length&&(c=!0)}while(!c);const s=T([[e[i][0],e[i][1]],[e[i+1][0],e[i+1][1]]],n);s&&(a=s),u=`Lire graphiquement le plus petit antécédent de $${o(n,1)}$ par la fonction $f$.<br>Donner la réponse avec la précision permise par le graphique.<br>`,q(this,t,{reponse:{value:a.toFixed(1),compare:C,options:{tolerance:.1}}}),v[t]=A(a,1),u+=D(this,t),l=`Le plus petit antécédent avec la précision permise par le graphique de $${o(n,1)}$ est $${w(o(a,1))}$.<br>`,this.correctionDetaillee&&(r[0]=$(-15,n*2,15,n*2,"blue"),r[0].pointilles=5,r[1]=$(a*2,n*2,a*2,0,"red"),r[1].pointilles=5,l+=g({xmin:-13.5,ymin:-9,xmax:13.5,ymax:9,scale:.5,pixelsParCm:30},h,x,r,f))}break;case"plusGrandAntécédent":{for(r=[],c=!1;!c;){for(n=k(y*10+2,M*10-2)/10,i=e.length-1;i>0&&(n>Math.max(e[i-1][1],e[i][1])||n<Math.min(e[i-1][1],e[i][1]));)i--;i>0&&(c=!0)}const s=T([[e[i-1][0],e[i-1][1]],[e[i][0],e[i][1]]],n);s&&(a=s),u=`Lire graphiquement le plus grand antécédent de $${o(n,1)}$ par la fonction $f$.<br>Donner la réponse avec la précision permise par le graphique.<br>`,q(this,t,{reponse:{value:a.toFixed(1),compare:C,options:{tolerance:.1}}}),v[t]=A(a,1),u+=D(this,t),l=`Le plus grand antécédent de $${o(n,1)}$ avec la précision permise par le graphique est $${w(o(a,1))}$.<br>`,this.correctionDetaillee&&(r[0]=$(-15,n*2,15,n*2,"blue"),r[0].pointilles=5,r[1]=$(a*2,n*2,a*2,0,"red"),r[1].pointilles=5,l+=g({xmin:-13.5,ymin:-9,xmax:13.5,ymax:9,scale:.5,pixelsParCm:30},h,x,r,f))}break;case"nombreAntécédents":default:for(d=[],r=[],c=0,n=k(y*10+2,M*10-2)/10,i=0;i<e.length-1;){if(R(n,Math.max(e[i][1],e[i+1][1]))&&U(n,Math.min(e[i][1],e[i+1][1]))){const s=T([[e[i][0],e[i][1]],[e[i+1][0],e[i+1][1]]],n);s&&(a=s),d.push(a)}i++}switch(d=V(j(d,.1)),c=d.length,u=`Lire graphiquement le nombre d'antécédents de $${o(n,1)}$ par la fonction $f$.<br>`,u+=D(this,t),c){case 0:l=`$${o(n,1)}$ ${X("ne possède pas d'antécédent")} sur $[-4;4]$.<br>`;break;case 1:l=`$${o(n,1)}$ ${X("possède un unique antécédent")} sur $[-4;4]$.<br>`,l=`L'antécédent de $${o(n,1)}$ est aux environs de $${o(d[0],1)}$.<br>`;break;default:l=`$${o(n,1)}$ possède $${w(c)}$ antécédents sur $[-4;4]$.<br>`,l+=`Les antécédents de $${o(n,1)}$ sont aux environs des nombres suivants : `;for(let s=0;s<c-1;s++)l+=`$${o(d[s],1)}$ ; `;l+=`$${o(d[c-1],1)}$.<br>`;break}if(q(this,t,{reponse:{value:c}}),v[t]=c,this.correctionDetaillee){r[0]=$(-15,n*2,15,n*2,"blue"),r[0].pointilles=5;for(let s=0;s<c;s++)r[s*2+1]=L(P(d[s]*2,n*2),"red"),r[s*2+1].epaisseur=2,r[s*2+2]=$(d[s]*2,0,d[s]*2,n*2,"red"),r[s*2+2].pointilles=5;l+=g({xmin:-13.5,ymin:-9,xmax:13.5,ymax:9,scale:.5,pixelsParCm:30},h,x,r,f)}break}x.epaisseur=2,this.questionJamaisPosee(t,Q[t],a,n,i)&&(this.listeQuestions[t]=u,this.listeCorrections[t]=l,t++),b++}B(this)}}export{ke as amcReady,Ce as amcType,Pe as dateDeModifImportante,Le as dateDePublication,Ae as default,De as interactifReady,qe as interactifType,we as refs,ve as titre,Te as uuid};
